# Методика проведения fuzzing-тестирования

## Введение

Fuzzing-тестирование — метод тестирования программного обеспечения, заключающийся в подаче на вход программы большого количества случайных или полуслучайных данных для выявления уязвимостей, сбоев или ошибок выполнения[cite: 3913]. Метод ориентирован на обнаружение дефектов обработки входных данных, включая переполнение буфера, ошибки парсинга, некорректное управление памятью, нарушения логики работы программы. Применяется для повышения защищённости программного обеспечения в задачах анализа безопасности, DevSecOps и тестирования на проникновение. В современных приложениях актуальна тема уязвимостей различного рода: переполнение буфера, утечки памяти, плохое шифрование, недостаточная проверка входных данных[cite: 3921]. Фаззинг является технологией тестирования программ в автоматическом режиме с целью выявления потенциальных уязвимостей[cite: 1669].

Цель метода — автоматизация поиска уязвимостей, которые сложно выявить статическим анализом или ручным тестированием. Fuzzing-тестирование позволяет обнаруживать проблемы на этапе разработки, тестирования или эксплуатации, минимизируя риски эксплуатации уязвимостей злоумышленниками. Этот факт предъявляет особые требования к своевременному обнаружению уязвимостей используемого программного обеспечения на этапах его разработки, создания информационной инфраструктуры и проведения аудита готовой инфраструктуры[cite: 5351, 1661]. Документ описывает шаги, инструменты и практики для проведения fuzzing-тестирования, обеспечивая воспроизводимость и полноту процесса. Технология «фаззинг» весьма востребована в информационном сообществе, поскольку позволяет выявить уязвимости в приложениях и системах прежде, чем ими успеют воспользоваться злоумышленники[cite: 5352, 1675]. Фаззинг представляет собой автоматическое тестирование программного обеспечения, заключающееся в том, что на вход исследуемой программы подаются случайные, модифицированные, неправильные значения, вызывая аномалии в поведении программы[cite: 5353, 1676].

Атакующая сторона активно использует наиболее распространенные уязвимости систем: утечки памяти, недостатки шифрования, переполнение буфера, неполную проверку входных данных и т.д.[cite: 5356, 1646]. Фаззинг, также известный как фазз-тестирование, это метод, который позволяет разработчикам и исследователям безопасности выполнять анализ черного ящика в данной программе (сетевые протоколы, двоичные файлы, веб-приложения и т. д.)[cite: 5362]. Целью фаззинга является обнаружение неизвестных уязвимостей или ошибок[cite: 5363]. Нечеткое тестирование выявляет потенциальные ошибки из-за непреднамеренного или аномального поведения в приложении, которое подвергается нечеткому анализу, такого, как сбои, бесконечные циклы или другое поведение, которое пользователь или разработчик могут счесть «плохим»[cite: 5363]. Обычно это делается путем изменения входных данных, вводимых в программу, в надежде на дальнейшее покрытие кода, поэтому каждый уголок и трещина в программа может быть подвержена этому произвольному вводу[cite: 5364]. Тенденция к применению фаззинга на всех этапах жизненного цикла программного обеспечения доказывает уникальность данной методологии для сообщества исследователей безопасности[cite: 4795, 4835]. Преимуществом фаззинга является практически полное отсутствие ложных срабатываний, что довольно часто встречается при использовании статических анализаторов[cite: 3925, 1655]. Фаззинг является одним из наиболее распространенных и эффективных методов динамического анализа[cite: 3419].

## Условия применения

Fuzzing-тестирование применимо к программам, обрабатывающим внешние данные: файлы, сетевые пакеты, пользовательский ввод, API-запросы[cite: 594]. Эффективность метода зависит от качества подготовки, выбора инструментов и анализа результатов. Метод используется в следующих случаях:

* Проверка устойчивости программы к некорректным или аномальным данным.
* Выявление уязвимостей в критических компонентах: парсерах, сетевых протоколах, библиотеках.
* Тестирование программного обеспечения с открытым или закрытым исходным кодом. Фаззинг также эффективен для поиска уязвимостей в программном обеспечении без наличия исходного кода[cite: 3913].
* Интеграция в процессы разработки для раннего обнаружения дефектов.
* Анализ бинарного кода, когда исходный код недоступен.
* Тестирование программных интерфейсов приложений (API)[cite: 3386].
* Тестирование телекоммуникационных протоколов и ПО[cite: 1175].

Ограничения метода: высокие вычислительные затраты, необходимость настройки под конкретную программу, возможная низкая эффективность без качественных исходных данных. Также стоит отметить, что из-за сложности некоторых программ фаззерам бывает трудно «дотянуться» до определенных частей кода[cite: 5380]. Это связано с глубиной вложения или какими-либо другими специфичными условиями исполнения[cite: 5381]. При переходе от монолитной архитектуры к микросервисной, поверхность атаки приложения может значительно увеличиваться из-за возрастания числа сетевых взаимодействий между компонентами, что делает фаззинг особенно актуальным для таких систем[cite: 2924]. Фаззинг считается успешным, если программа потерпела крах или была в другом некорректном состоянии[cite: 3017].

## Подготовка к fuzzing-тестированию

Подготовка определяет успех тестирования, обеспечивая целенаправленность и полноту анализа. Жизненный цикл фаззинга веб-приложений включает такие этапы как идентификация интерфейсов, генерация входных данных, отправка входных данных, мониторинг цели, анализ исключений и составление отчетов[cite: 4016].

### Определение целей и поверхности атаки

Цели тестирования фиксируют ожидаемые результаты и фокус анализа:

* Обнаружение уязвимостей в заданном модуле или функции.
* Проверка обработки специфических форматов данных: JSON, XML, бинарные файлы.
* Выявление утечек памяти, некорректного освобождения ресурсов.
* Оценка устойчивости к стрессовым нагрузкам.

Цели влияют на выбор инструментов, стратегию генерации данных и критерии завершения тестирования. Отсутствие чётких целей приводит к неэффективному использованию ресурсов и пропуску критических уязвимостей. На данном этапе оцениваются особенности исследуемого объекта и выбирается соответствующий метод и инструмент анализа[cite: 6406]. Необходимо определить все возможные варианты входных данных[cite: 6407].

**Определение поверхности атаки (Attack Surface):**

Ключевым шагом подготовки является определение поверхности атаки – совокупности интерфейсов и реализующих их модулей ПО, через которые могут реализовываться угрозы[cite: 3764]. Для системного ПО определение адекватной поверхности атаки чрезвычайно важно, так как необоснованное ее уменьшение может привести к пропуску уязвимостей, а чрезмерное расширение сделает анализ невыполнимым[cite: 4529]. Подход, основанный на определении механизма управления доступом и связанных с ним механизмов защиты как основы поверхности атаки, является научно обоснованным и подтвержденным практикой[cite: 4533]. Один из видов поверхности атаки программного обеспечения (ПО) — это те функции, которые получают данные из недоверенных источников[cite: 2251].

Методы определения поверхности атаки:

* **Анализ помеченных данных (Taint Analysis):** Позволяет выделить модули, участвующие в обработке данных, поступающих от пользователя или из недоверенных источников[cite: 3765]. Инструмент Natch, построенный на базе QEMU, использует отслеживание помеченных данных и интроспекцию виртуальных машин для поиска исполняемых файлов, библиотек и функций, отвечающих за обработку входных данных[cite: 2227, 2228]. Natch помечает входные данные из недоверенных источников и отслеживает их распространение по памяти виртуальной машины[cite: 2276].
* **Экспертный анализ:** Анализ исходного кода и документации для выделения интерфейсов и модулей[cite: 3769].
* **Анализ разности покрытий кода:** Предложенный подход позволяет оценить взаимосвязь входных данных с кодом программы путем вычисления разности покрытий, полученных при различных условиях запуска, и исключения из анализа модулей, вызываемых независимо от входных данных[cite: 3641, 3781]. Утилита `lcov` может использоваться для генерации отчетов о покрытии[cite: 3778], а специализированные скрипты – для расчета разности[cite: 3782].
* **Анализ истории изменений и уязвимостей:** Изучение предыдущих версий ПО и известных уязвимостей может помочь выявить потенциально слабые места.

Цель для фаззинга (fuzz target) – это функция, которая принимает на вход данные и обрабатывает их с использованием тестируемого API[cite: 4807]. Важно узнать аргументы функции, через которые передаются данные для обработки (сам буфер и его длина)[cite: 4809, 4810], тип передаваемых данных (например, HTML, PNG, ZIP-архив)[cite: 4811], и список ресурсов (память, объекты, глобальные переменные), которые должны быть инициализированы перед вызовом целевой функции[cite: 4812]. Если проводится фаззинг внутренних функций, а не API, необходимо учитывать ограничения, накладываемые на данные ранее выполненным кодом[cite: 4813].

### Классификация фаззеров

Фаззеры можно классифицировать по-разному[cite: 5366].

* **По способу генерации входных данных:**
    * **На основе генерации (Generation-based):** Требуется знание формата входных данных программы[cite: 5367]. Для фаззинга формата файла обычно предоставляется файл конфигурации, который определяет формат файла[cite: 5367]. Тестовые наборы генерируются в соответствии с файлом конфигурации[cite: 5368]. При заданном знании формата файла тестовые наборы, сгенерированные фаззерами на основе генерации, способны легче проходить проверку программ и с большей вероятностью могут тестировать более глубокий код целевых программ[cite: 5368]. Однако без понятного документа анализ формата файла сложная работа[cite: 5369]. Данные подготавливаются заранее, на основе протоколов или в соответствие с заданными правилами[cite: 3934]. Такие фаззеры создают условия для тестирования с чистого листа, моделируя необходимый протокол или формат файла[cite: 6410, 4806].
    * **На основе мутации (Mutation-based):** Требуется набор допустимых начальных входных данных (seed inputs)[cite: 5370]. Тестовые наборы генерируются путем изменения исходных входных данных и тестовых наборов, сгенерированных в процессе фаззинга[cite: 5371]. Фаззеры на основе мутаций легче запускать, они более применимы и широко используются современными фаззерами[cite: 5369]. Новые данные получаются за счет незначительных изменений существующих данных[cite: 3933]. Такие фаззеры изменяют существующие образцы данных для создания тестовых условий[cite: 6409, 4806].
* **По доступу к исходному коду и степени анализа программы:**
    * **Белый ящик (WhiteBox fuzzing):** Предполагается доступ к исходному коду программы[cite: 5373]. Это позволяет собрать больше информации путем анализа исходного кода и того, как тестовые сценарии влияют на состояние выполнения программы[cite: 5373]. Предлагается использовать метод белого ящика, а также дополнительные возможности внутри программы, такие как санитайзеры, в целях получения информации о внутреннем состоянии программы для оптимизации входных данных[cite: 5412]. Фаззер Sage является каноническим примером этого метода[cite: 3679].
    * **Серый ящик (GreyBox fuzzing):** Работают без исходного кода, но получают внутреннюю информацию о целевых программах посредством анализа программ (например, легковесная инструментация для сбора покрытия кода)[cite: 5375, 3669]. При тестировании данным методом исследователь не имеет полной спецификации программы и исходных кодов, как это бывает при тестировании методом «белого ящика», однако знаний о системе больше чем при тестировании методом «черного ящика»[cite: 3929]. Часто подразумевается, что знание о тестируемом программном обеспечении получаются в ходе реверсивной инженерии[cite: 3930]. AFL является каноническим примером[cite: 3685].
    * **Черный ящик (BlackBox fuzzing):** Выполняют фаззинг-тест без каких-либо знаний о внутренних компонентах целевой программы[cite: 5374, 3670]. Эффективность такого тестирования часто низкая, так как фаззерам сложно сгенерировать данные, обеспечивающие прирост покрытия[cite: 3672]. Основная идея тестирования системы методом черного ящика состоит в том, что все внутренние особенности реализации системы скрыты от тестировщика[cite: 930].
* **По наличию обратной связи:**
    * **Умные (Smart/Intelligent/Coverage-guided):** Настраивают генерацию тестовых наборов в соответствии с собранной информацией о том, как тестовые наборы влияют на поведение программы (обратная связь, обычно информация о покрытии кода)[cite: 5377]. Для фаззеров, основанных на мутациях, можно использовать информацию обратной связи, чтобы определить, какая часть тестовых наборов должна быть изменена, и способ их изменения[cite: 5378]. Умные фаззеры генерируют лучшие тестовые наборы и повышают эффективность[cite: 5379]. Разработчики фаззеров пытаются бороться с недостаточным покрытием кода различными путями, и здесь на помощь приходит обратная связь, когда фаззер получает информацию о поведении программы благодаря сигнализирующим инструкциям в исполняемом файле[cite: 5383]. Это называется инструментацией и позволяет фаззеру корректировать вход на следующем раунде, чтобы попытаться улучшить покрытие[cite: 5384].
    * **«Тупые» (Dumb):** Генерация тестовых наборов не зависит от состояния выполнения программы. Немые фаззеры обеспечивают лучшую скорость тестирования[cite: 5379].

Существует также классификация фаззеров протоколов на специализированные и неспециализированные[cite: 1231].

### Выбор инструментов

Инструменты выбираются на основе характеристик программы и целей тестирования. Основные инструменты и их применимость описаны в таблице:

| Инструмент       | Назначение                                      | Применимость                          | Ограничения                          | Риски при игнорировании              |
|------------------|------------------------------------------------|---------------------------------------|--------------------------------------|--------------------------------------|
| AFL (American Fuzzy Lop) / AFL++             | Тестирование бинарных программ, фаззинг с обратной связью (grey-box) [cite: 583, 3018] | Программы на C/C++ с исходным кодом (для лучшей инструментации) или бинарные (с QEMU)  | Требует компиляции с AFL-инструментами или запуска в режиме эмуляции (медленнее)[cite: 2788]. Может показывать неудовлетворительное покрытие на специфичных входных данных без доработки (например, добавления словарей)[cite: 3019]. | Пропуск уязвимостей в неподготовленных бинарниках. Низкая эффективность на сложных форматах данных. |
| LibFuzzer        | Тестирование библиотек и функций (in-process, coverage-guided) [cite: 3429] | Код на C/C++ с поддержкой LLVM [cite: 2166]        | Ограничен функциями с чётким входом. Требует написания harness-функции[cite: 3430]. | Невозможность тестирования без интеграции. |
| Honggfuzz        | Универсальное тестирование с многопоточностью (coverage-guided) | Бинарные и исходные программы (разные режимы инструментации) | Высокая нагрузка на ресурсы. Может требовать специфичной настройки. | Снижение производительности без оптимизации. |
| OSS-Fuzz         | Непрерывное тестирование open-source проектов | Проекты с публичным кодом             | Требует интеграции с платформой Google Cloud. | Ограниченный доступ для закрытых проектов. |
| Minifuzz         | Реализация фаззинга формата файлов [cite: 6431]            | Любое приложение, воспринимающее файл как параметр запуска [cite: 6434] |  Простота использования [cite: 4823]                |  Ограниченная функциональность для сложных сценариев. |
| Sulley/Boofuzz | Сетевые фаззеры                                 | Тестирование сетевых протоколов и приложений | Требуют определения структуры протокола. |  Неэффективны без точного описания протокола. |
| Peach Fuzzer     | Smart-фаззинг с поддержкой мутации и генерации [cite: 4825] | Файлы, сетевые сервисы, RPC, COM/DCOM, SQL [cite: 4826] | Большая универсальность может приводить к трудностям в использовании[cite: 4827]. | Требует значительной настройки. |
| FuzzDB           | Коллекция фаззинг-баз и шаблонов [cite: 4827]             | Различные типы фаззинга (пути файлов, шаблоны атак, шаблоны ответов) [cite: 4828, 4829, 4830] | Не является самостоятельным фаззером, а набором данных. | Эффективность зависит от правильного применения баз. |
| Syzkaller        | Фаззинг-тестирование ядер ОС [cite: 48, 2147]                  | Ядра ОС семейства Linux, FreeBSD, Fuchsia, NetBSD, Windows и др. [cite: 2162] | Требует описания системных вызовов на специализированном языке (syzlang)[cite: 4549]. | Сложность настройки для специфичных ядер. |
| Crusher          | Динамический анализ программ, включая фаззинг [cite: 2702] | Приложения пользовательского пространства [cite: 51] | Зависит от поддерживаемых платформ. | Может требовать написания "оберток" для целевых программ[cite: 4563]. |
| S2E              | Платформа для символьного выполнения и анализа [cite: 4921] | Немодифицированные программные стеки x86, x86-64, ARM [cite: 4922] | Требует интеграции и настройки для конкретных задач[cite: 4933]. Сложность в использовании. | Сложность интерпретации результатов символьного выполнения. |
| ELF (Embedded Linux Fuzz) | Динамический анализ IoT-систем на основе полносистемной эмуляции [cite: 6017, 4845] | IoT-устройства под управлением Linux [cite: 4852] | Требует извлечения образа ядра, ФС и initrd из устройства[cite: 4879]. | Зависимость от возможностей эмуляции QEMU. |
| Natch / SNatch   | Определение поверхности атаки, анализ помеченных данных [cite: 2225] | Любые системы, запускаемые в QEMU (включая ядро ОС и драйверы) [cite: 2228] | Работает на базе QEMU, требует настройки интроспекции для конкретной ОС. | Замедление при анализе, не предназначен для вредоносного ПО, которое активно противодействует анализу[cite: 2564]. |
| Google Thread Sanitizer (GTSAN) | Обнаружение ошибок многопоточного программирования (гонки данных, взаимоблокировки) [cite: 3209, 3170] | Программы на C/C++ [cite: 3191] | Фаззинг-модуль GTSAN выполняет потоки последовательно, что замедляет работу[cite: 3173]. | Неэффективен для приложений, зависящих от асинхронных взаимодействий без модификаций. |
| Radamsa          | Универсальный мутационный фаззер ("черный ящик") [cite: 600] | Различные форматы данных, включая графические изображения [cite: 595] | Не использует обратную связь по покрытию кода. | Может быть менее эффективным, чем coverage-guided фаззеры для сложных программ. |
| IOCTL Fuzzer     | Фаззинг IOCTL-запросов драйверов                | Драйверы ОС                               | Специфичен для IOCTL                 | Может требовать прав администратора. |

**По типу воздействия фаззеры можно разделить на:**

* **Локальные:** [cite: 3946]
    * Фаззеры командной строки: для выявления ошибок разбора входных параметров[cite: 3947, 6427].
    * Фаззеры переменных окружения: для выявления ошибок обработки данных из переменных окружения[cite: 3948].
    * Фаззеры файлов: для тестирования ПО, принимающего файлы[cite: 3949, 6430].
* **Удаленные:**
    * Фаззеры сетевых протоколов[cite: 3950, 6439].
    * Фаззеры веб-приложений: получили актуальность с развитием Web 2.0[cite: 3950, 6440].
    * Фаззеры веб-браузеров: тестируют разбор HTML и других расширений[cite: 3951, 6440]. Особое внимание уделяется фаззингу JavaScript-движков (например, V8, SpiderMonkey, JavaScriptCore, Chakra) и DOM. Примеры фаззеров: Fuzzili, Jsfunfuzz, Favocado, SoFi[cite: 3754, 3755, 3756, 3757].
* **In-memory фаззеры:** Мутируют данные непосредственно в памяти процесса, что позволяет тестировать API и библиотеки без перезапуска приложения[cite: 1710]. LibFuzzer является примером такого подхода.

Выбор инструмента определяет глубину анализа и скорость тестирования. Неправильный выбор снижает охват уязвимостей.

### Подготовка окружения

Тестовое окружение изолирует программу и фиксирует её поведение:

* Развёртывание виртуальной машины или контейнера с операционной системой, совместимой с программой.
* Установка зависимостей: компиляторов, библиотек, отладочных утилит.
* Настройка мониторинга: сбор логов, дампов памяти, метрик производительности.

Изоляция исключает влияние внешних факторов, а мониторинг обеспечивает фиксацию сбоев. Неподготовленное окружение искажает результаты или затрудняет их анализ. При работе с IoT-устройствами, особенно важно обеспечить среду выполнения, максимально приближенную к "родной". Использование полносистемной эмуляции, например, с помощью QEMU, может помочь в этом[cite: 6044]. Инструмент ELF (Embedded Linux Fuzz) предназначен для динамического анализа устройств на основе полносистемной эмуляции в QEMU и требует наличия образа ядра, файловой системы и initrd для работы[cite: 6017, 6028, 4879]. Однако, даже в этом случае могут возникнуть трудности, например, с совместимостью версий ОС или динамической инструментацией, которая может сильно снизить производительность. Для проведения динамического анализа бинарного кода IoT-устройства необходимо внесение дополнительных инструментов (отладчики, профилировщики), что не всегда возможно из-за ограничений памяти или специфичных ФС[cite: 6045]. Для тестирования ПО также могут создаваться специализированные испытательные стенды, включающие клиент-серверную схему и монитор состояния[cite: 1350].

### Сбор исходных данных

Исходные данные (также известные как "начальный корпус" или "seed corpus") — основа для генерации тестовых случаев, особенно для мутационных фаззеров[cite: 1740]. Источники данных:

* Корректные входные файлы: документы, изображения, архивы.
* Сохранённые сетевые пакеты или запросы.
* Тестовые наборы из спецификаций программы или существующие юнит-тесты.
* Данные, сгенерированные другими инструментами или вручную.

Качество и разнообразие исходных данных напрямую влияют на эффективность фаззинга. Отсутствие релевантных исходных данных снижает эффективность мутационного фаззинга, так как фаззеру будет сложно "нащупать" интересные пути выполнения. Для программ со специфичными входными данными, стандартный AFL может показывать неудовлетворительное покрытие кода, и может потребоваться доработка, например, создание словарей констант или изменение эвристик фаззинга[cite: 3019, 3045].

## Процесс fuzzing-тестирования

Процесс включает настройку, генерацию данных, запуск и анализ результатов. Тенденция к применению фаззинга на всех этапах жизненного цикла программного обеспечения доказывает его уникальность[cite: 4795, 4835].

### Настройка инструмента

Настройка адаптирует инструмент к программе. Основные параметры:

| Параметр                  | Назначение                                      | Применение                          | Влияние                          | Последствия игнорирования         |
|---------------------------|------------------------------------------------|-------------------------------------|----------------------------------|-----------------------------------|
| Путь к исполняемому файлу | Указывает тестируемый объект                  | Бинарные программы, скрипты         | Определяет точку входа           | Ошибка запуска тестирования       |
| Точки входа (Entry points / Harness) | Задаёт тестируемые функции или API            | Библиотеки, модули, API             | Сужает область анализа, позволяет тестировать конкретные функции | Тестирование нецелевых участков, невозможность тестирования API |
| Параметры мутации         | Контролирует изменения данных                 | Мутационный fuzzing                 | Влияет на разнообразие тестов    | Ограниченный охват ошибок         |
| Ограничение ресурсов      | Устанавливает лимиты времени и памяти         | Все типы fuzzing-а                  | Предотвращает перегрузку системы | Бесконечный цикл или сбой системы |
| Словари (Dictionaries)    | Предоставляют фаззеру специфичные для формата токены (ключевые слова, магические числа) | Фаззинг сложных форматов данных   | Увеличивает вероятность генерации валидных или полувалидных входов, улучшает покрытие | Низкая эффективность на структурированных данных |

Настройка обеспечивает точность и управляемость процесса. Ошибки настройки приводят к ложным результатам.

### Генерация тестовых данных

Методы генерации данных:

* **Случайная генерация (Random Fuzzing / "Dumb" Fuzzing)**: Создание данных без шаблонов или с минимальным знанием формата[cite: 6401]. Применяется для программ с минимальными требованиями к формату или как начальный этап. Ограничение — низкая вероятность попадания в ключевые ветви кода. Это наименее эффективный метод, но самый быстрый для поиска очевидных ошибок[cite: 3937, 6412]. Целевой программе передается большое количество случайных данных[cite: 3937, 1679].
* **Мутационная генерация (Mutation-based Fuzzing)**: Модификация корректных исходных данных (seed inputs) через различные операции: замены битов/байтов, удаление, добавление, дублирование блоков, арифметические операции над числами и т.д.[cite: 1737]. Используется с качественными исходными данными. Повышает релевантность тестов. Фаззеры на основе мутаций берут набор допустимых входных данных и выполняют над ними мутации, чтобы вызвать ошибки или сбои[cite: 6292]. Примеры мутаций: переключение битов, обфускация HTTP-запросов[cite: 6293, 6294]. Этот подход известен как тестирование методом грубой силы, когда фаззер искажает каждый байт, слово или строку в образце данных[cite: 6418, 4818]. Существуют также подходы ручного изменения данных протокола, где исследователь сам вносит ошибочные данные[cite: 1681, 3939].
* **Модельная (или на основе спецификаций/грамматик) генерация (Generation-based/Specification-based/Grammar-based Fuzzing)**: Создание данных по формальной спецификации, грамматике или модели программы/протокола. Требует формального описания формата. Обеспечивает максимальный охват логики и генерацию синтаксически корректных или близких к корректным данных[cite: 6422]. Вместо того чтобы создавать образец для тестирования с жестко заданным кодом, создается грамматика, в которой описывается работа спецификации протокола[cite: 6422]. При фаззинге виртуальных машин JavaScript используется мутация абстрактного синтаксического дерева (AST), где генератору задаются правила грамматики[cite: 827, 831].
* **Эволюционный фаззинг (Evolutionary Fuzzing)**: Вид мутационного фаззинга, который использует генетические алгоритмы для улучшения тестовых примеров[cite: 6298, 3018]. Входные данные, приводящие к новому покрытию кода или интересному поведению, "скрещиваются" и "мутируют" для создания следующего поколения тестов[cite: 6299]. AFL использует этот подход[cite: 3018].
* **Осознанное внесение изменений в данные (Intelligent/Knowledge-based Fuzzing):** Требуются дополнительные исследования для определения, какие части данных должны оставаться константами, а какие изменяться[cite: 3944, 1685]. Этот подход является наиболее интеллектуальным, но требует больше времени исследователя[cite: 3945].
* **Генерация последовательности вызовов API:** Для тестирования API необходимо генерировать не только данные для аргументов функций, но и различные последовательности вызовов этих функций[cite: 3388]. Этот процесс может включать этап "разминки" (warm-up) для сбора начального покрытия [cite: 3478] и последующую мутацию как аргументов[cite: 3406], так и самой последовательности вызовов[cite: 3408]. Могут использоваться шаблоны для определения начальных сценариев, зависимостей между функциями (например, использование возвращаемого значения одной функции как аргумента другой) и предварительных/пост-условий вызовов[cite: 3493, 3495]. Для генерации данных для NFC-тестирования могут использоваться функции, создающие конфликты в сообщениях NDEF на основе анализа протокола[cite: 1395, 1396, 1483].

Выбор метода зависит от доступных данных, сложности программы и целей тестирования. Неправильный выбор снижает эффективность тестирования. Важно также порождать некорректные данные и затем исполнять их[cite: 6407]. Существует несколько методов генерации входных данных: генерация случайных данных (менее результативна) [cite: 4024] и мутация валидных данных с добавлением аномалий[cite: 4025]. Современные фаззеры могут автоматически анализировать структуру входных/выходных данных и генерировать тесты на основе этих знаний[cite: 4026, 4027].

### Запуск тестирования

Запуск выполняется в контролируемом окружении с мониторингом:

* Многократное выполнение программы с различными входными данными.
* Сбор информации о сбоях, исключениях, использовании ресурсов.
* Прерывание по достижении лимитов времени, количества тестов или обнаружения критических ошибок.

Запуск выявляет аномалии в поведении программы. Отсутствие контроля приводит к пропуску сбоев. После формирования данных их необходимо отправить в интерфейс, обеспечивающий взаимодействие с исследуемым приложением[cite: 4029]. В случае API-фаззинга, сгенерированная последовательность вызовов и аргументы передаются клиентской части, которая выполняет эти вызовы на целевой системе (например, мобильном устройстве)[cite: 3475].

### Анализ результатов

Анализ идентифицирует уязвимости и ошибки:

* Фиксация сбоев: сегфолты, зависания, аварийные завершения.
* Проверка дампов памяти на переполнение буфера, некорректные указатели.
* Сравнение логов с ожидаемым поведением программы.

Результаты классифицируются: критические уязвимости, нестабильность, ложные срабатывания. Неполный анализ упускает реальные проблемы. Важным шагом является мониторинг исключений (Target Monitoring, Exception Analysis), позволяющий оценить причины возникновения исключений[cite: 6408, 4032], и определение возможности эксплуатации найденных уязвимостей. Большинство фаззеров ведут логи, а передовые могут делать снимки состояния системы при ошибке[cite: 4033]. Заключительный этап – составление отчета (Reporting), где накапливается вся информация и формируются библиотеки уязвимостей[cite: 4035, 4036].

**Типы выявляемых ошибок:**

* **Сбои компилятора (Compiler Crashes):** Наиболее распространенный и легко обнаруживаемый тип ошибок[cite: 5833]. Для их обнаружения достаточно проанализировать сообщение, с которым завершается работа компилятора[cite: 5834].
* **Ошибки некорректной компиляции (Miscompilations):** Компилятор работает корректно, но поведение программы не соответствует семантике языка[cite: 5837]. Для поиска таких ошибок необходимо скомпилировать программу с разными компиляторами (или разными версиями/режимами одного компилятора), инструментировать скомпилированный код и проверить его поведение во время выполнения[cite: 5838].
* **Проблемы производительности (Performance Bugs):** Слишком долгое время компиляции или аномально высокое время выполнения программы[cite: 5840]. Обнаруживаются с помощью "системы голосования" (сравнения с другими компиляторами/режимами) и тщательного измерения времени выполнения с учетом погрешностей[cite: 5841].
* **Уязвимости типа "нарушение управления доступом":** Злоумышленник может получить доступ к привилегированным функциям приложения[cite: 6335]. Это может быть достигнуто путем изменения параметров URL или веб-формы[cite: 6336]. Особенно характерно для веб-приложений с иерархической ролевой структурой[cite: 6338].
* **Отказ в обслуживании (DoS):** Не дает нападающему прав доступа, но отсутствие доступа к ресурсу является серьезной угрозой[cite: 4041].
* **Межсайтовый скриптинг (XSS):** Позволяет хакеру контролировать действия клиентов в веб-браузере[cite: 4042].
* **SQL-инъекция:** Может привести к полному контролю над серверной системой[cite: 4043, 4044].
* **Слабый контроль доступа:** Наличие открытых служебных файлов и каталогов[cite: 4045].
* **Слабости в системе аутентификации:** Слабые пароли, передача учетных данных в открытом виде[cite: 4046].
* **Плохое управление сессиями:** Недостаточно случайные или короткоживущие идентификаторы сессий[cite: 4047].
* **Неверно примененные методы HTTP:** Использование методов GET и POST для не предназначенных для них операций[cite: 4051].
* **Исполнение удаленных команд:** Если вводимые пользователем данные не фильтруются и передаются другим приложениям или ОС[cite: 4053].
* **Инъекция удаленного кода:** Особенно опасно для PHP-приложений при плохом кодировании[cite: 4054].
* **Расщепление HTTP-запроса (HTTP Response Splitting):** Если пользователь может ввести CRLF в заголовки ответа[cite: 4055].
* **Подделка межсайтовых запросов (CSRF):** Атакующий может заставить аутентифицированную жертву выполнить нежелательные действия[cite: 4056, 4057].
* Технология фаззинга также позволяет выявлять ошибки контроля доступа, ошибки в логике устройства, направления ввода, требующие идентификации пользователя, повреждение памяти и многоступенчатые уязвимости[cite: 4834].
* **Ошибки многопоточного программирования:** Такие как гонки данных (data races) и взаимоблокировки (deadlocks)[cite: 3209]. Инструменты вроде Google Thread Sanitizer (GTSAN) могут использоваться в сочетании с фаззингом для их обнаружения[cite: 3172].
* **Ошибки работы с памятью и неопределенное поведение:** Обнаруживаются с помощью символьной интерпретации и предикатов безопасности (например, деление на ноль, выход за границы массива, целочисленное переполнение)[cite: 232, 270, 295].
* **Аутентификационные данные в коде программы (CWE-798)[cite: 3105], отладочная информация, приводящая к повышению привилегий (CWE-267)[cite: 3105], скрытые каналы передачи информации (CWE-489)[cite: 3105], некорректное удаление остаточной информации (CWE-762)[cite: 3105].**

## Методы повышения эффективности

* **Комбинирование инструментов**: Использование AFL и LibFuzzer для охвата разных типов уязвимостей.
* **Оптимизация данных**: Регулярное обновление исходных данных на основе найденных сбоев. Создание словарей специфичных для формата данных (например, для AFL) может значительно улучшить покрытие кода для программ, работающих с такими данными[cite: 3045].
* **Параллельное тестирование**: Распределение задач по нескольким ядрам или узлам. Для многопоточных приложений предложен метод распараллеливания независимых переходов, который позволяет выполнять локальные вычисления параллельно, управляя последовательностью выполнения потоков только в точках синхронизации[cite: 3178]. Это может ускорить фаззинг-планировщики[cite: 3181].
* **Интеграция с CI/CD**: Автоматизация fuzzing-а в процессах разработки[cite: 4].
* **Анализ внутреннего состояния программы:** Использование графа потока управления для генерации входных данных, направленных на уязвимые участки кода[cite: 5406]. Это включает построение графа потока управления, поиск паттернов ошибок, и генерацию данных на основе этой информации и сигналов от фаззера и санитайзеров[cite: 5414, 5417, 5418].
* **Использование санитайзеров:** Функции внутри программы (например, AddressSanitizer, ThreadSanitizer, MemorySanitizer, KASAN, KCSAN), которые позволяют обнаружить аномальное состояние или поведение программы, такое как ошибки работы с памятью, гонки данных и др.[cite: 286, 2151].
* **Улучшение покрытия кода:** Использование информации обратной связи (например, от инструментации) для корректировки входных данных и достижения более глубоких участков кода. Динамическая бинарная инструментация (DBI) позволяет анализировать программу на несколько порядков быстрее, чем классическая отладка, за счет вставки специальных инструкций в бинарный код[cite: 5299, 5302]. Для AFL, отключение проверки входной контрольной суммы в тестируемой программе [cite: 3049] или добавление эвристик для пропуска детерминированного фаззинга для очень больших файлов может ускорить процесс[cite: 3046]. Использование системы для сбора и анализа покрытия (например, на основе Gcov и lcov) помогает минимизировать корпус и визуализировать результаты[cite: 55, 2170].
* **Гибридный фаззинг (Hybrid Fuzz Testing):** Объединение фаззинга с символьным выполнением (Dynamic Symbolic Execution - DSE) для обнаружения ошибок и более эффективного исследования путей выполнения[cite: 229, 262]. DSE позволяет добавлять предикаты безопасности для поиска ошибок работы с памятью и неопределенного поведения[cite: 230, 5092]. Символьная интерпретация KLEE способна автоматически генерировать тесты для достижения высокого покрытия и поиска ошибок[cite: 271]. Платформа S2E предоставляет возможности символьного выполнения с использованием полносистемной эмуляции[cite: 4921]. Инструмент ELF интегрирован с S2E для поддержки гибридного фаззинга IoT-устройств[cite: 4846, 4877].
* **Дедупликация и редукция ошибок:** Автоматическая обработка найденных ошибок для удаления дубликатов и нерелевантной информации из тестовых примеров, что упрощает ручной анализ. Для дедупликации могут использоваться сравнение стектрейсов или методы изоляции ошибок. Редукция может включать как языково-независимые методы (например, иерархическая дельта-отладка, статическое обратное срезание), так и языково-специфические трансформации. Алгоритм слайсинга предиката пути позволяет устранять избыточные ограничения из предиката пути без потери точности при символьном выполнении[cite: 5082, 5115]. Инструмент Casr позволяет проводить автоматизированную дедупликацию, кластеризацию и оценку критичности аварийных завершений[cite: 449].
* **Применение байесовских сетей:** Для управления процессом тестирования и анализа результатов, особенно при тестировании однородных веб-приложений[cite: 6367]. Динамические байесовские сети могут использоваться для моделирования временных процессов и адаптации вероятностной модели к задачам фаззинга[cite: 5231]. Это позволяет накапливать статистическую информацию и улучшать локализацию ошибок. Использование байесовских сетей для описания фаззинга программ обработки графических изображений позволяет определить связи между структурными компонентами тестирования[cite: 604].
* **Направленный фаззинг (Directed Fuzzing):** Фокусировка фаззинга на определенных участках кода, которые считаются более критичными или были недавно изменены[cite: 71]. Корреляция результатов статического и динамического анализа позволяет реализовывать направленный фаззинг для подтверждения срабатываний статических анализаторов[cite: 8, 97].
* **Анализ поверхности атаки:** Точное определение поверхности атаки позволяет сконцентрировать усилия фаззинга на наиболее вероятных точках входа уязвимостей. Инструменты, использующие отслеживание помеченных данных (taint tracking) и интроспекцию виртуальных машин (VMI), такие как Natch, могут помочь в автоматическом определении функций и модулей, обрабатывающих внешние данные[cite: 2227, 2228].
* **Минимизация корпуса (Corpus Minimization):** Регулярная минимизация набора входных данных (корпуса) для удаления избыточных или неэффективных тестов, что ускоряет процесс фаззинга[cite: 439].
* **Оптимизация сетевого фаззинга:** Для сетевых протоколов, особенно закрытых, важно восстановить спецификацию протокола и протокольный автомат[cite: 2741, 2742]. Фаззинг stateful-протоколов требует управления состоянием[cite: 2773]. Обход проверок контрольных сумм (например, инвертированием условных переходов при инструментации) может быть необходим при отсутствии алгоритма их вычисления[cite: 2828].
* **Использование интеллектуальных агентов:** Программы, самостоятельно выполняющие задания по фаззингу в течение длительных промежутков времени и способные выбирать инструменты и адаптировать стратегии[cite: 1691, 1692].
* **Применение машинного обучения:** Для генерации и фильтрации тестовых примеров, выбора эффективных мутаций[cite: 148].

Методы увеличивают скорость и глубину анализа. Их игнорирование замедляет процесс и снижает качество результатов. Важно также отметить, что разработка безопасного системного ПО требует комплексного подхода, включающего нормативную базу, формальные модели управления доступом, статический и динамический анализ, а также аналитическую обработку результатов[cite: 4083, 4084, 4085, 4086, 4087, 4088].

## Распространённые ошибки

| Ошибка                          | Причина                                      | Последствия                          | Способы устранения                 |
|---------------------------------|----------------------------------------------|--------------------------------------|------------------------------------|
| Неправильный выбор инструмента  | Несоответствие типу программы или целям тестирования. | Пропуск уязвимостей, низкая эффективность. | Тщательный анализ требований перед выбором, возможно использование нескольких инструментов. |
| Некачественные или недостаточные исходные данные  | Отсутствие релевантных примеров, слишком малый или однообразный корпус. | Низкая эффективность мутационного тестирования, плохое покрытие. | Сбор разнообразных данных из реальных сценариев, документации, генерация синтетических данных. |
| Недостаточный мониторинг        | Пропуск сбоев, их причин или другой аномальной активности. | Неполный анализ результатов, пропуск уязвимостей. | Использование отладочных утилит, санитайзеров, систем логирования и мониторинга ресурсов. |
| Ограниченное время тестирования | Завершение до достижения достаточного охвата или нахождения более глубоких ошибок. | Пропуск скрытых или сложных уязвимостей. | Увеличение выделяемых ресурсов и времени, использование более эффективных стратегий фаззинга. |
| Недостаточное покрытие кода     | Фаззер не может "дотянуться" до некоторых частей кода из-за сложности программы, специфических условий исполнения или неэффективных стратегий генерации. | Пропуск уязвимостей в этих частях кода. | Использование техник обратной связи (coverage-guided fuzzing), инструментации, гибридного фаззинга, оптимизация входных данных и параметров мутации. |
| Проблемы совместимости фаззера  | Фаззер может быть несовместим с различными версиями ОС, библиотеками или сильно привязан к особенностям конкретной ОС/архитектуры. | Невозможность провести тестирование или некорректные результаты. | Тщательный выбор и настройка фаззера, проверка совместимости, использование эмуляции или виртуализации. |
| Сложность определения причин сбоя | При использовании "тупых" или случайных методов генерации очень сложно определить, какая именно часть входных данных вызвала сбой[cite: 3938]. | Затрудненный анализ и исправление ошибок, много времени на триаж. | Использование "умных" фаззеров, автоматическая минимизация тестовых примеров (test case reduction), детальное логирование. |
| Игнорирование поверхности атаки | Тестирование компонентов, не взаимодействующих с внешними данными, или пропуск важных точек входа. | Неэффективное использование ресурсов, пропуск реальных векторов атак. | Тщательное определение и анализ поверхности атаки перед началом фаззинга. |
| Неэффективная обработка ошибок | Отсутствие автоматической дедупликации и приоритизации найденных сбоев. | Большой объем ручной работы по анализу результатов, дублирование усилий. | Внедрение систем управления ошибками с функциями дедупликации, кластеризации и минимизации. |

Ошибки снижают ценность fuzzing-а. Их устранение повышает надёжность результатов.

## Проверочные механизмы

* **Воспроизводимость сбоев**: Повторение обнаруженных ошибок с теми же данными. Сохранение входных данных, вызвавших сбой (crashing inputs), является обязательным.
* **Кросс-проверка**: Подтверждение уязвимостей другими инструментами или методами (например, статический анализ, ручная проверка).
* **Метрики охвата**: Анализ покрытия кода (например, покрытие блоков, ребер, путей) с помощью профилировщиков (gcov, llvm-cov, sanitizer coverage)[cite: 3687]. Использование компонента сбора покрытия кода, который фиксирует адреса выполненных базовых блоков. Инструмент `afl-cov` может использоваться для анализа покрытия, сгенерированного AFL[cite: 3037]. Для оценки эффективности тестирования необходимо оценить степень покрытия бинарного кода тестами[cite: 5324]. Для ядер ОС сбор покрытия может осуществляться с помощью kcov[cite: 114], а для визуализации используется lcov [cite: 55] или Lighthouse[cite: 2452, 2499].
* **Логирование**: Сравнение логов с ожиданиями для выявления отклонений. Детальное логирование действий фаззера и реакции программы.
* **Анализ сбоев (Crash Analysis):** Использование отладчиков (gdb, WinDbg) и инструментов анализа дампов памяти для определения причины сбоя и оценки его эксплуатабельности.
* **Минимизация тестовых примеров (Test Case Minimization):** Уменьшение размера входных данных, вызвавших сбой, до минимально необходимого для воспроизведения ошибки[cite: 643]. Это значительно упрощает анализ.
* **Триаж ошибок (Bug Triage):** Классификация и приоритизация найденных ошибок по степени их критичности и вероятности эксплуатации.

Механизмы подтверждают достоверность результатов и исключают ложные срабатывания.

## Заключение

Fuzzing-тестирование — мощный и широко применяемый инструмент для выявления уязвимостей и ошибок в программном обеспечении через автоматизированное тестирование входных данных[cite: 1676]. Эффективность метода зависит от тщательной подготовки (включая определение поверхности атаки), правильного выбора и настройки инструментов, качества исходных данных (начального корпуса), стратегий генерации и мутации, а также глубокого анализа результатов и непрерывного улучшения процесса. Применение описанных шагов, методов (включая различные типы генерации данных, использование обратной связи, анализ состояния программы, гибридные подходы) и проверочных механизмов обеспечивает воспроизводимость и полноту тестирования, что в конечном итоге значительно повышает безопасность и надежность программного обеспечения в инженерной практике.

Несмотря на некоторые ограничения, такие как высокие вычислительные затраты и сложность достижения полного покрытия кода в комплексных системах, фаззинг остается востребованной и прогрессивной технологией в области аудита и обеспечения безопасности ПО. Фаззинг веб-приложений[cite: 4010], API[cite: 3388], операционных систем[cite: 2141], компиляторов и IoT-устройств [cite: 4845] демонстрирует свою эффективность в обнаружении широкого спектра дефектов. Важно помнить, что фаззинг хорошо находит определенные типы уязвимостей, такие как переполнение буфера или отказ в обслуживании, но может быть менее эффективен против скрытых угроз или логических ошибок. Поэтому его следует применять в комплексе с другими методами тестирования и анализа безопасности в рамках общего жизненного цикла безопасной разработки (Secure Development Lifecycle - SDL)[cite: 227, 4077]. Современные тенденции развития индустрии ПО позволяют по-новому взглянуть на проблему обнаружения программных дефектов, и фаззинг здесь играет важную роль[cite: 3989]. Независимые исследователи и производители коммерческих продуктов продолжают разрабатывать и улучшать технологии фаззинга, стремясь к автоматизации поиска и улучшению механизмов обнаружения ошибок[cite: 4832, 4833].
