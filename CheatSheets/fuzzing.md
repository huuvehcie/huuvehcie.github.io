# Методика проведения fuzzing-тестирования

## Содержание

1. [Введение](#введение) 
2. [Условия применения](#условия-применения) 
3. [Подготовка к fuzzing-тестированию](#подготовка-к-fuzzing-тестированию) 
 1. [Определение целей и поверхности атаки](#определение-целей-и-поверхности-атаки) 
 2. [Классификация фаззеров](#классификация-фаззеров) 
 3. [Выбор инструментов](#выбор-инструментов) 
 4. [Подготовка окружения](#подготовка-окружения) 
 5. [Сбор исходных данных](#сбор-исходных-данных) 
4. [Процесс fuzzing-тестирования](#процесс-fuzzing-тестирования) 
 1. [Настройка инструмента](#настройка-инструмента) 
 2. [Генерация тестовых данных](#генерация-тестовых-данных) 
 3. [Запуск тестирования](#запуск-тестирования) 
 4. [Анализ результатов](#анализ-результатов) 
5. [Методы повышения эффективности](#методы-повышения-эффективности) 
6. [Распространённые ошибки](#распространённые-ошибки) 
7. [Проверочные механизмы](#проверочные-механизмы) 
8. [Заключение](#заключение)

---

## Введение 
Fuzzing-тестирование — метод тестирования программного обеспечения, заключающийся в подаче на вход программы большого количества случайных или полуслучайных данных для выявления уязвимостей, сбоев или ошибок выполнения. Метод ориентирован на обнаружение дефектов обработки входных данных, включая переполнение буфера, ошибки парсинга, некорректное управление памятью, нарушения логики работы программы. Применяется для повышения защищённости программного обеспечения в задачах анализа безопасности, DevSecOps и тестирования на проникновение.

В современных приложениях актуальна тема уязвимостей различного рода: переполнение буфера, утечки памяти, плохое шифрование, недостаточная проверка входных данных. Фаззинг является технологией тестирования программ в автоматическом режиме с целью выявления потенциальных уязвимостей. Цель метода — автоматизация поиска уязвимостей, которые сложно выявить статическим анализом или ручным тестированием. Fuzzing-тестирование позволяет обнаруживать проблемы на этапе разработки, тестирования или эксплуатации, минимизируя риски эксплуатации уязвимостей злоумышленниками.

Этот факт предъявляет особые требования к своевременному обнаружению уязвимостей используемого программного обеспечения на этапах его разработки, создания информационной инфраструктуры и проведения аудита готовой инфраструктуры. Документ описывает шаги, инструменты и практики для проведения fuzzing-тестирования, обеспечивая воспроизводимость и полноту процесса. Технология «фаззинг» весьма востребована в информационном сообществе, поскольку позволяет выявить уязвимости в приложениях и системах прежде, чем ими успеют воспользоваться злоумышленники. Фаззинг представляет собой автоматическое тестирование программного обеспечения, заключающееся в том, что на вход исследуемой программы подаются случайные, модифицированные, неправильные значения, вызывая аномалии в поведении программы.

Атакующая сторона активно использует наиболее распространенные уязвимости систем: утечки памяти, недостатки шифрования, переполнение буфера, неполную проверку входных данных и т.д. Фаззинг, также известный как фазз-тестирование, это метод, который позволяет разработчикам и исследователям безопасности выполнять анализ черного ящика в данной программе (сетевые протоколы, двоичные файлы, веб-приложения и т. д.). Целью фаззинга является обнаружение неизвестных уязвимостей или ошибок. Нечеткое тестирование выявляет потенциальные ошибки из-за непреднамеренного или аномального поведения в приложении, которое подвергается нечеткому анализу, такого, как сбои, бесконечные циклы или другое поведение, которое пользователь или разработчик могут счесть «плохим». Обычно это делается путем изменения входных данных, вводимых в программу, в надежде на дальнейшее покрытие кода, поэтому каждый уголок и трещина в программе может быть подвержена этому произвольному вводу.

Тенденция к применению фаззинга на всех этапах жизненного цикла программного обеспечения доказывает уникальность данной методологии для сообщества исследователей безопасности. Преимуществом фаззинга является практически полное отсутствие ложных срабатываний, что довольно часто встречается при использовании статических анализаторов. Фаззинг является одним из наиболее распространенных и эффективных методов динамического анализа.

## Условия применения 
Fuzzing-тестирование применимо к программам, обрабатывающим внешние данные: файлы, сетевые пакеты, пользовательский ввод, API-запросы. Эффективность метода зависит от качества подготовки, выбора инструментов и анализа результатов. Метод используется в следующих случаях:
* Проверка устойчивости программы к некорректным или аномальным данным.
* Выявление уязвимостей в критических компонентах: парсерах, сетевых протоколах, библиотеках.
* Тестирование программного обеспечения с открытым или закрытым исходным кодом. Фаззинг также эффективен для поиска уязвимостей в программном обеспечении без наличия исходного кода.
* Интеграция в процессы разработки для раннего обнаружения дефектов.
* Анализ бинарного кода, когда исходный код недоступен.
* Тестирование программных интерфейсов приложений (API).
* Тестирование телекоммуникационных протоколов и ПО.

Ограничения метода: высокие вычислительные затраты, необходимость настройки под конкретную программу, возможная низкая эффективность без качественных исходных данных. Также стоит отметить, что из-за сложности некоторых программ фаззерам бывает трудно «дотянуться» до определенных частей кода. Это связано с глубиной вложения или какими-либо другими специфичными условиями исполнения. При переходе от монолитной архитектуры к микросервисной, поверхность атаки приложения может значительно увеличиваться из-за возрастания числа сетевых взаимодействий между компонентами, что делает фаззинг особенно актуальным для таких систем. Фаззинг считается успешным, если программа потерпела крах или была в другом некорректном состоянии.

## Подготовка к fuzzing-тестированию 
Подготовка определяет успех тестирования, обеспечивая целенаправленность и полноту анализа. Жизненный цикл фаззинга веб-приложений включает такие этапы как идентификация интерфейсов, генерация входных данных, отправка входных данных, мониторинг цели, анализ исключений и составление отчетов.

### Определение целей и поверхности атаки 
Цели тестирования фиксируют ожидаемые результаты и фокус анализа:
* Обнаружение уязвимостей в заданном модуле или функции.
* Проверка обработки специфических форматов данных: JSON, XML, бинарные файлы.
* Выявление утечек памяти, некорректного освобождения ресурсов.
* Оценка устойчивости к стрессовым нагрузкам.

Цели влияют на выбор инструментов, стратегию генерации данных и критерии завершения тестирования. Отсутствие чётких целей приводит к неэффективному использованию ресурсов и пропуску критических уязвимостей. На данном этапе оцениваются особенности исследуемого объекта и выбирается соответствующий метод и инструмент анализа. Необходимо определить все возможные варианты входных данных.

**Определение поверхности атаки (Attack Surface):** 
Ключевым шагом подготовки является определение поверхности атаки – совокупности интерфейсов и реализующих их модулей ПО, через которые могут реализовываться угрозы. Для системного ПО определение адекватной поверхности атаки чрезвычайно важно, так как необоснованное ее уменьшение может привести к пропуску уязвимостей, а чрезмерное расширение сделает анализ невыполнимым. Подход, основанный на определении механизма управления доступом и связанных с ним механизмов защиты как основы поверхности атаки, является научно обоснованным и подтвержденным практикой. Один из видов поверхности атаки программного обеспечения (ПО) — это те функции, которые получают данные из недоверенных источников.

Методы определения поверхности атаки:

**Поверхность атаки (Attack Surface)** — это совокупность всех возможных точек входа, через которые злоумышленник может взаимодействовать с программным обеспечением или системой. Определение поверхности атаки является ключевым этапом при подготовке к fuzzing-тестированию, поскольку позволяет фокусировать усилия на наиболее уязвимых и доступных для внешнего воздействия частях кода.

Ниже приведена расширенная таблица методов определения поверхности атаки с подробным описанием, преимуществами, недостатками и примерами использования:

| **Метод** | **Описание** | **Инструменты / Техники** | **Преимущества** | **Недостатки** |
|---|---|---|---|---|
| **Анализ помеченных данных (Taint Analysis)** | Отслеживает распространение внешних данных по программе, выявляя модули, обрабатывающие недоверенный ввод. Позволяет понять, какие части программы реагируют на внешние данные и могут быть потенциальной целью атаки. | Natch, SNatch, инструменты на основе QEMU и VMI (Virtual Machine Introspection). | Высокая точность в определении функций, взаимодействующих с внешними данными. Подходит для анализа как пользовательского ввода, так и сетевых запросов. | Требует времени на настройку отслеживания и анализа; может быть замедлено при работе с большими системами. |
| **Экспертный анализ** | Ручной анализ исходного кода, документации, спецификаций и архитектурных решений системы с целью выделения потенциально уязвимых интерфейсов и компонентов. | Ревью кода, статический анализ, экспертные оценки, моделирование угроз (например, STRIDE), DREAD. | Возможность глубокого понимания архитектуры и логики программы. Эффективен при наличии доступа к исходному коду. | Зависит от квалификации специалиста; трудозатратно. |
| **Анализ разности покрытий кода** | Сравнивает выполнение программы при различных входных данных, чтобы выявить участки, зависящие от ввода. Это позволяет отделить те части кода, которые действительно реагируют на внешние данные, от фоновой логики. | lcov, gcov, специализированные скрипты для сравнения покрытия. | Позволяет точно выделять фрагменты кода, реагирующие на внешние данные. Хорошо работает в сочетании с другими методами. | Требует нескольких запусков и сравнений, что увеличивает время подготовки. |
| **Анализ истории изменений и уязвимостей** | Изучение предыдущих версий ПО и исторических данных об уязвимостях с целью выявления слабых мест. Часто используемый для тестирования legacy-систем. | Анализ CVE-баз, репозиториев, баг-трекеров, отчетов об уязвимостях. | Учитывает уже известные проблемы и помогает сосредоточиться на повторяющихся ошибках. Полезен для регрессионного тестирования. | Не гарантирует обнаружения новых типов уязвимостей. |
| **Динамический анализ вызовов** | Мониторинг вызовов API и функций во время работы программы с различными входными данными. Позволяет выявить зависимости между внешним вводом и внутренней логикой. | API Monitor, Process Monitor, динамическая инструментация (Frida, DynamoRIO). | Позволяет видеть, какие функции активно используются и как они реагируют на входные данные. Полезен для тестирования закрытых бинарников. | Может быть сложно автоматизировать; требует наличия работающей среды тестирования. |
| **Автоматизированное сканирование поверхности** | Использование инструментов, способных автоматически находить точки входа и их обработчики. Особенно полезно для веб-приложений и сетевых сервисов. | Burp Suite, OWASP ZAP, Radamsa, AFL++, Boofuzz. | Быстрое выявление возможных точек входа, особенно в сетевых и веб-приложениях. | Ограниченность в анализе внутренней логики и неспособность охватить все случаи использования. |
| **Моделирование угроз (Threat Modeling)** | Применение формальных методологий (например, STRIDE, DREAD) для анализа возможных путей атак. Фокусируется на определении поверхностей, связанных с аутентификацией, авторизацией, передачей данных и т.д. | Microsoft Threat Modeling Tool, IriusRisk, PASTA Framework. | Формализация подхода к определению поверхности атаки с учетом классификации угроз. | Требует знания модели угроз и хорошего понимания архитектуры системы. |
| **Использование графа вызовов** | Построение графа всех функций и их взаимосвязей, чтобы выделить наиболее "глубокие" и критичные точки, доступные через внешний ввод. | Call graph анализаторы: IDA Pro, Ghidra, Binary Ninja. | Визуализирует зависимости и позволяет целенаправленно выбирать участки для тестирования. | Требует ресурсов на построение и анализ графа, особенно в больших проектах. |
| **Пользовательский паттерн-анализ** | Изучение поведения пользователей и входных данных, используемых в реальных условиях. Позволяет адаптировать фаззинг под реальные сценарии использования. | Лог-анализеры, APM-системы, UBA (User Behavior Analytics). | Позволяет адаптировать фаззинг под реальные сценарии использования. | Ограниченность в прогнозировании нетипичного поведения злоумышленника. |
| **Гибридный анализ (статический + динамический)** | Комбинирование статического и динамического анализа для более полного определения поверхности. Позволяет получить как теоретическую, так и практическую картину. | Инструменты, поддерживающие синтез (S2E, KLEE, angr). | Комплексный подход, позволяющий охватить как теоретическую, так и практическую поверхность атаки. | Сложность настройки и согласования результатов из разных источников. |
| **Анализ протоколов и сетевых интерфейсов** | Специализированный метод, ориентированный на определение поверхности атаки в сетевых приложениях, таких как серверы, клиенты, IoT-устройства и другие. | Wireshark, tcpdump, Scapy, Boofuzz, Sulley. | Эффективен для выявления сетевых точек входа и протокольных уязвимостей. | Требует понимания сетевой архитектуры и специфики протоколов. |
| **Символьное выполнение и обратная связь по покрытию** | Использование символьного выполнения и инструментации для анализа пути исполнения программы и выявления функций, доступных через внешний ввод. | Инструменты: S2E, KLEE, AFL, LibFuzzer. | Обеспечивает высокую степень покрытия и возможность отслеживания условий ветвления. | Требует значительных вычислительных ресурсов и времени. |
| **Фаззинг-ориентированный анализ** | Определение поверхности атаки непосредственно через проведение пробного фаззинга. На основе полученных сбоев и покрытия кода можно судить о наиболее уязвимых точках. | AFL, Honggfuzz, LibFuzzer, Radamsa. | Практический подход, показывающий, какие части кода наиболее чувствительны к некорректным данным. | Требует предварительного запуска фаззера и может быть медленным. |

🔍 Почему важно использовать несколько методов?
Единственный подход к определению поверхности атаки часто оказывается недостаточным. Например:
- **Только статический анализ** может упустить динамические особенности программы.
- **Только мутационный фаззинг** может не достичь глубоких функций без начального корпуса.
- **Только граф вызовов** может не учесть влияние внешних факторов и реального окружения.

Поэтому лучшая практика — **комбинировать методы**: например, использовать экспертный анализ и граф вызовов для начального определения области, затем применить taint analysis и покрытие кода для уточнения, и завершить всё фаззингом и символическим выполнением.

🛠️ Рекомендуемые практики
1. **Интеграция с CI/CD:** Автоматизация определения поверхности атаки на ранних этапах разработки.
2. **Обновление поверхности атаки:** При каждом крупном обновлении ПО необходимо пересматривать поверхность атаки.
3. **Использование покрытия кода:** Для оценки того, насколько полно фаззинг охватывает найденную поверхность.
4. **Минимизация поверхности:** Уменьшение числа точек входа и сокращение сложности обработки внешних данных.
5. **Регулярное тестирование:** Повторное определение поверхности атаки и проведение фаззинга после каждого изменения в критических модулях.

📌 Примеры использования
- **IoT-устройства:** Используется Natch или ELF с QEMU для анализа помеченных данных и определения функций, обрабатывающих входные сетевые пакеты.
- **Веб-приложения:** Гибридный подход: экспертный анализ + Burp Suite + покрытие кода + фаззинг API.
- **Компиляторы и языковые среды:** Символьное выполнение (KLEE) + грамматический фаззинг + анализ покрытия (LLVM Coverage).
- **ОС и ядра:** Syzkaller + kcov + покрытие кода + символьное выполнение.


Определение поверхности атаки — это **не просто формальность**, а один из ключевых этапов успешного проведения fuzzing-тестирования. Каждый метод имеет свои сильные стороны и ограничения, поэтому эффективная стратегия включает **гибридный подход**, сочетающий статический, динамический, символьный и экспертный анализ.

Выбор конкретного метода зависит от следующих факторов:
- Наличие исходного кода.
- Архитектура и тип системы (веб, IoT, ядро ОС и т.д.).
- Цели тестирования (поиск переполнений, логических ошибок, утечек и т.д.).
- Доступные ресурсы (время, вычислительная мощность, квалификация команды).

Правильно определённая поверхность атаки позволяет:
- Сократить время на тестирование.
- Повысить вероятность обнаружения уязвимостей.
- Снизить количество ложных срабатываний.
- Улучшить качество и воспроизводимость тестирования.

> ✅ **Совет:** Начинайте с простых методов (экспертный анализ, покрытие кода), затем добавляйте продвинутые (taint analysis, символьное выполнение, гибридный фаззинг) для углубленного исследования.

Цель для фаззинга (fuzz target) – это функция, которая принимает на вход данные и обрабатывает их с использованием тестируемого API. Важно узнать аргументы функции, через которые передаются данные для обработки (сам буфер и его длина), тип передаваемых данных (например, HTML, PNG, ZIP-архив), и список ресурсов (память, объекты, глобальные переменные), которые должны быть инициализированы перед вызовом целевой функции. Если проводится фаззинг внутренних функций, а не API, необходимо учитывать ограничения, накладываемые на данные ранее выполненным кодом.

### Классификация фаззеров 
Фаззеры можно классифицировать по-разному:

| **Категория** | **Тип / Подтип** | **Описание** | **Примеры** | **Преимущества** |
|---|---|---|---|---|
| По способу генерации входных данных |
| На основе генерации (Generation-based) | Требуется знание формата входных данных программы. Для фаззинга формата файла обычно предоставляется файл конфигурации, который определяет формат файла. Тестовые наборы генерируются в соответствии с файлом конфигурации. При заданном знании формата файла тестовые наборы, сгенерированные фаззерами на основе генерации, способны легче проходить проверку программ и с большей вероятностью могут тестировать более глубокий код целевых программ. Однако без понятного документа анализ формата файла — сложная работа. Данные подготавливаются заранее, на основе протоколов или в соответствие с заданными правилами. Такие фаззеры создают условия для тестирования "с чистого листа", моделируя необходимый протокол или формат файла. | Peach Fuzzer, Sulley, GRAMMARATOR, AFL++ (с грамматиками), Boofuzz | — Высокая точность покрытия форматов<br>— Обеспечивает глубокий доступ к внутренним функциям<br>— Увеличивает вероятность достижения редких участков кода<br>— Подходит для сложных форматов файлов и сетевых сообщений |
| На основе мутации (Mutation-based) | Требуется набор допустимых начальных входных данных (seed inputs). Тестовые наборы генерируются путем изменения исходных входных данных и тестовых наборов, сгенерированных в процессе фаззинга. Фаззеры на основе мутаций легче запускать, они более применимы и широко используются современными фаззерами. Новые данные получаются за счет незначительных изменений существующих данных. Такие фаззеры изменяют существующие образцы данных для создания тестовых условий. | AFL, Radamsa, Honggfuzz, LibFuzzer, Eclipser, QSYM | — Простота запуска и настройки<br>— Не требует знаний о формате данных<br>— Быстро начинает находить явные ошибки<br>— Широко применимы к любым программам<br>— Хорошо работает с seed corpus |
| По доступу к исходному коду и степени анализа программы |
| Белый ящик (WhiteBox fuzzing) | Предполагается доступ к исходному коду программы. Это позволяет собрать больше информации путем анализа исходного кода и того, как тестовые сценарии влияют на состояние выполнения программы. Предлагается использовать метод белого ящика, а также дополнительные возможности внутри программы, такие как санитайзеры, в целях получения информации о внутреннем состоянии программы для оптимизации входных данных. Фаззер Sage является каноническим примером этого метода. | Sage, S2E, KLEE | — Максимальное покрытие кода<br>— Возможность анализа всех возможных путей исполнения<br>— Обнаружение глубоких уязвимостей<br>— Использование формальных методов для поиска ошибок |
| Серый ящик (GreyBox fuzzing) | Работают без исходного кода, но получают внутреннюю информацию о целевых программах посредством анализа программ (например, легковесная инструментация для сбора покрытия кода). При тестировании данным методом исследователь не имеет полной спецификации программы и исходных кодов, как это бывает при тестировании методом «белого ящика», однако знаний о системе больше, чем при тестировании методом «черного ящика». Часто подразумевается, что знание о тестируемом ПО получается в ходе реверсивной инженерии. AFL является каноническим примером. | AFL, AFL++, LibFuzzer, Honggfuzz | — Хорошее соотношение между скоростью и покрытием кода<br>— Работает с бинарными файлами и отсутствием исходников<br>— Поддерживает обратную связь по покрытию кода<br>— Легко масштабируется |
| Черный ящик (BlackBox fuzzing) | Выполняют фаззинг-тест без каких-либо знаний о внутренних компонентах целевой программы. Эффективность такого тестирования часто низкая, так как фаззерам сложно сгенерировать данные, обеспечивающие прирост покрытия. Основная идея тестирования системы методом черного ящика состоит в том, что все внутренние особенности реализации системы скрыты от тестировщика. | Radamsa, старые версии Sulley, PROTOS | — Не требует модификаций целевой программы<br>— Применим к закрытым системам и проприетарному ПО<br>— Может использоваться при удаленном тестировании |
| По наличию обратной связи |
| Умные (Smart/Intelligent/Coverage-guided) | Настраивают генерацию тестовых наборов в соответствии с собранной информацией о том, как тестовые наборы влияют на поведение программы (обратная связь, обычно информация о покрытии кода). Для фаззеров, основанных на мутациях, можно использовать информацию обратной связи, чтобы определить, какую часть тестовых наборов следует изменить и каким образом. Умные фаззеры генерируют лучшие тестовые наборы и повышают эффективность. Разработчики фаззеров пытаются бороться с недостаточным покрытием кода различными путями, и здесь на помощь приходит обратная связь, когда фаззер получает информацию о поведении программы благодаря сигнализирующим инструкциям в исполняемом файле. Это называется инструментацией и позволяет фаззеру корректировать вход на следующем раунде, чтобы попытаться улучшить покрытие. | AFL, AFL++, LibFuzzer, Syzkaller | — Автоматическая адаптация под программу<br>— Высокое покрытие кода<br>— Быстрое выявление новых участков<br>— Самообучение через мутации и эволюционные алгоритмы |
| «Тупые» (Dumb) | Генерация тестовых наборов не зависит от состояния выполнения программы. Немые фаззеры обеспечивают лучшую скорость тестирования. Они работают без анализа реакции программы, поэтому подходят для первоначального этапа или простых задач. | Radamsa, FileFuzz, старые фаззеры | — Минимальные требования к ресурсам<br>— Простота использования<br>— Высокая скорость работы<br>— Подходит для начального этапа тестирования |

Существует также классификация фаззеров протоколов на специализированные и неспециализированные.

### Выбор инструментов 
Инструменты выбираются на основе характеристик программы и целей тестирования. Основные инструменты и их применимость описаны в таблице:
| Инструмент | Назначение | Применимость | Ограничения | Риски при игнорировании |
|---|---|---|---|---|
| AFL (American Fuzzy Lop) / AFL++ | Тестирование бинарных программ, фаззинг с обратной связью (grey-box) | Программы на C/C++ с исходным кодом (для лучшей инструментации) или бинарные (с QEMU) | Требует компиляции с AFL-инструментами или запуска в режиме эмуляции (медленнее). Может показывать неудовлетворительное покрытие на специфичных входных данных без доработки (например, добавления словарей). | Пропуск уязвимостей в неподготовленных бинарниках. Низкая эффективность на сложных форматах данных. |
| LibFuzzer | Тестирование библиотек и функций (in-process, coverage-guided) | Код на C/C++ с поддержкой LLVM | Ограничен функциями с чётким входом. Требует написания harness-функции. | Невозможность тестирования без интеграции. |
| Honggfuzz | Универсальное тестирование с многопоточностью (coverage-guided) | Бинарные и исходные программы (разные режимы инструментации) | Высокая нагрузка на ресурсы. Может требовать специфичной настройки. | Снижение производительности без оптимизации. |
| OSS-Fuzz | Непрерывное тестирование open-source проектов | Проекты с публичным кодом | Требует интеграции с платформой Google Cloud. | Ограниченный доступ для закрытых проектов. |
| Minifuzz | Реализация фаззинга формата файлов | Любое приложение, воспринимающее файл как параметр запуска | Простота использования | Ограниченная функциональность для сложных сценариев. |
| Sulley/Boofuzz | Сетевые фаззеры | Тестирование сетевых протоколов и приложений | Требуют определения структуры протокола. | Неэффективны без точного описания протокола. |
| Peach Fuzzer | Smart-фаззинг с поддержкой мутации и генерации | Файлы, сетевые сервисы, RPC, COM/DCOM, SQL | Большая универсальность может приводить к трудностям в использовании. | Требует значительной настройки. |
| FuzzDB | Коллекция фаззинг-баз и шаблонов | Различные типы фаззинга (пути файлов, шаблоны атак, шаблоны ответов) | Не является самостоятельным фаззером, а набором данных. | Эффективность зависит от правильного применения баз. |
| Syzkaller | Фаззинг-тестирование ядер ОС | Ядра ОС семейства Linux, FreeBSD, Fuchsia, NetBSD, Windows и др. | Требует описания системных вызовов на специализированном языке (syzlang). | Сложность настройки для специфичных ядер. |
| Crusher | Динамический анализ программ, включая фаззинг | Приложения пользовательского пространства | Зависит от поддерживаемых платформ. | Может требовать написания "оберток" для целевых программ. |
| S2E | Платформа для символьного выполнения и анализа | Немодифицированные программные стеки x86, x86-64, ARM | Требует интеграции и настройки для конкретных задач. Сложность в использовании. | Сложность интерпретации результатов символьного выполнения. |
| ELF (Embedded Linux Fuzz) | Динамический анализ IoT-систем на основе полносистемной эмуляции | IoT-устройства под управлением Linux | Требует извлечения образа ядра, ФС и initrd из устройства. | Зависимость от возможностей эмуляции QEMU. |
| Natch / SNatch | Определение поверхности атаки, анализ помеченных данных | Любые системы, запускаемые в QEMU (включая ядро ОС и драйверы) | Работает на базе QEMU, требует настройки интроспекции для конкретной ОС. | Замедление при анализе, не предназначен для вредоносного ПО, которое активно противодействует анализу. |
| Google Thread Sanitizer (GTSAN) | Обнаружение ошибок многопоточного программирования (гонки данных, взаимоблокировки) | Программы на C/C++ | Фаззинг-модуль GTSAN выполняет потоки последовательно, что замедляет работу. | Неэффективен для приложений, зависящих от асинхронных взаимодействий без модификаций. |
| Radamsa | Универсальный мутационный фаззер ("черный ящик") | Различные форматы данных, включая графические изображения | Не использует обратную связь по покрытию кода. | Может быть менее эффективным, чем coverage-guided фаззеры для сложных программ. |
| IOCTL Fuzzer | Фаззинг IOCTL-запросов драйверов | Драйверы ОС | Специфичен для IOCTL | Может требовать прав администратора. |

**По типу воздействия фаззеры можно разделить на:**
* **Локальные:**
 * Фаззеры командной строки: для выявления ошибок разбора входных параметров.
 * Фаззеры переменных окружения: для выявления ошибок обработки данных из переменных окружения.
 * Фаззеры файлов: для тестирования ПО, принимающего файлы.
* **Удаленные:**
 * Фаззеры сетевых протоколов.
 * Фаззеры веб-приложений: получили актуальность с развитием Web 2.0.
 * Фаззеры веб-браузеров: тестируют разбор HTML и других расширений. Особое внимание уделяется фаззингу JavaScript-движков (например, V8, SpiderMonkey, JavaScriptCore, Chakra) и DOM. Примеры фаззеров: Fuzzili, Jsfunfuzz, Favocado, SoFi.
* **In-memory фаззеры:** Мутируют данные непосредственно в памяти процесса, что позволяет тестировать API и библиотеки без перезапуска приложения. LibFuzzer является примером такого подхода.

Выбор инструмента определяет глубину анализа и скорость тестирования. Неправильный выбор снижает охват уязвимостей.

### Подготовка окружения 
Тестовое окружение изолирует программу и фиксирует её поведение:
* Развёртывание виртуальной машины или контейнера с операционной системой, совместимой с программой.
* Установка зависимостей: компиляторов, библиотек, отладочных утилит.
* Настройка мониторинга: сбор логов, дампов памяти, метрик производительности.

Изоляция исключает влияние внешних факторов, а мониторинг обеспечивает фиксацию сбоев. Неподготовленное окружение искажает результаты или затрудняет их анализ. При работе с IoT-устройствами, особенно важно обеспечить среду выполнения, максимально приближенную к "родной". Использование полносистемной эмуляции, например, с помощью QEMU, может помочь в этом. Инструмент ELF (Embedded Linux Fuzz) предназначен для динамического анализа устройств на основе полносистемной эмуляции в QEMU и требует наличия образа ядра, файловой системы и initrd для работы. Однако, даже в этом случае могут возникнуть трудности, например, с совместимостью версий ОС или динамической инструментацией, которая может сильно снизить производительность. Для проведения динамического анализа бинарного кода IoT-устройства необходимо внесение дополнительных инструментов (отладчики, профилировщики), что не всегда возможно из-за ограничений памяти или специфичных ФС. Для тестирования ПО также могут создаваться специализированные испытательные стенды, включающие клиент-серверную схему и монитор состояния.

### Сбор исходных данных 
Исходные данные (также известные как "начальный корпус" или "seed corpus") — основа для генерации тестовых случаев, особенно для мутационных фаззеров. Источники данных:
* Корректные входные файлы: документы, изображения, архивы.
* Сохранённые сетевые пакеты или запросы.
* Тестовые наборы из спецификаций программы или существующие юнит-тесты.
* Данные, сгенерированные другими инструментами или вручную.

Качество и разнообразие исходных данных напрямую влияют на эффективность фаззинга. Отсутствие релевантных исходных данных снижает эффективность мутационного фаззинга, так как фаззеру будет сложно "нащупать" интересные пути выполнения. Для программ со специфичными входными данными, стандартный AFL может показывать неудовлетворительное покрытие кода, и может потребоваться доработка, например, создание словарей констант или изменение эвристик фаззинга.

## Процесс fuzzing-тестирования 
Процесс включает настройку, генерацию данных, запуск и анализ результатов. Тенденция к применению фаззинга на всех этапах жизненного цикла программного обеспечения доказывает его уникальность.

### Настройка инструмента 
Настройка адаптирует инструмент к программе. Основные параметры:
| Параметр | Назначение | Применение | Влияние | Последствия игнорирования |
|---|---|---|---|---|
| Путь к исполняемому файлу | Указывает тестируемый объект | Бинарные программы, скрипты | Определяет точку входа | Ошибка запуска тестирования |
| Точки входа (Entry points / Harness) | Задаёт тестируемые функции или API | Библиотеки, модули, API | Сужает область анализа, позволяет тестировать конкретные функции | Тестирование нецелевых участков, невозможность тестирования API |
| Параметры мутации | Контролирует изменения данных | Мутационный fuzzing | Влияет на разнообразие тестов | Ограниченный охват ошибок |
| Ограничение ресурсов | Устанавливает лимиты времени и памяти | Все типы fuzzing-а | Предотвращает перегрузку системы | Бесконечный цикл или сбой системы |
| Словари (Dictionaries) | Предоставляют фаззеру специфичные для формата токены (ключевые слова, магические числа) | Фаззинг сложных форматов данных | Увеличивает вероятность генерации валидных или полувалидных входов, улучшает покрытие | Низкая эффективность на структурированных данных |

Настройка обеспечивает точность и управляемость процесса. Ошибки настройки приводят к ложным результатам.

### Генерация тестовых данных 
Методы генерации данных:

| **Метод** | **Описание** | **Применение / Особенности** | **Примеры инструментов / технологий** |
|-----------|--------------|-------------------------------|--------------------------------------|
| **Случайная генерация (Random Fuzzing / "Dumb" Fuzzing)** | Создание данных без шаблонов или с минимальным знанием формата. Применяется для программ с минимальными требованиями к формату или как начальный этап. Ограничение — низкая вероятность попадания в ключевые ветви кода. Это наименее эффективный метод, но самый быстрый для поиска очевидных ошибок. Целевой программе передается большое количество случайных данных. | — Подходит для начального анализа<br>— Требует минимума подготовки<br>— Эффективен против простых проверок | Radamsa, FileFuzz |
| **Мутационная генерация (Mutation-based Fuzzing)** | Модификация корректных исходных данных (seed inputs) через различные операции: замены битов/байтов, удаление, добавление, дублирование блоков, арифметические операции над числами и т.д. Используется с качественными исходными данными. Повышает релевантность тестов. Фаззеры на основе мутаций берут набор допустимых входных данных и выполняют над ними мутации, чтобы вызвать ошибки или сбои. Примеры мутаций: переключение битов, обфускация HTTP-запросов. Этот подход известен как тестирование методом грубой силы, когда фаззер искажает каждый байт, слово или строку в образце данных. Существуют также подходы ручного изменения данных протокола, где исследователь сам вносит ошибочные данные. | — Требует seed corpus<br>— Высокая применимость<br>— Легко автоматизируется | AFL, Honggfuzz, Eclipser, QSYM |
| **Модельная (или на основе спецификаций/грамматик) генерация (Generation-based/Specification-based/Grammar-based Fuzzing)** | Создание данных по формальной спецификации, грамматике или модели программы/протокола. Требует формального описания формата. Обеспечивает максимальный охват логики и генерацию синтаксически корректных или близких к корректным данных. Вместо того чтобы создавать образец для тестирования с жестко заданным кодом, создается грамматика, в которой описывается работа спецификации протокола. При фаззинге виртуальных машин JavaScript используется мутация абстрактного синтаксического дерева (AST), где генератору задаются правила грамматики. | — Высокое покрытие сложных форматов<br>— Подходит для форматов с четкой структурой<br>— Требует знаний о формате | Peach Fuzzer, GRAMMARATOR, Grammarinator, AFL++ (с грамматиками) |
| **Эволюционный фаззинг (Evolutionary Fuzzing)** | Вид мутационного фаззинга, который использует генетические алгоритмы для улучшения тестовых примеров. Входные данные, приводящие к новому покрытию кода или интересному поведению, "скрещиваются" и "мутируют" для создания следующего поколения тестов. AFL использует этот подход. | — Самообучение на основе успешных тестов<br>— Адаптивность к особенностям программы<br>— Улучшение набора тестовых данных со временем | AFL, AFL++, Eclipser, AFLSmart |
| **Осознанное внесение изменений в данные (Intelligent/Knowledge-based Fuzzing)** | Требуются дополнительные исследования для определения, какие части данных должны оставаться константами, а какие изменяться. Этот подход является наиболее интеллектуальным, но требует больше времени исследователя. | — Высокая точность тестирования<br>— Учет семантики формата<br>— Минимизация бесполезных тестов | Boofuzz, Sulley, custom-фаззинговые решения |
| **Генерация последовательности вызовов API** | Для тестирования API необходимо генерировать не только данные для аргументов функций, но и различные последовательности вызовов этих функций. Этот процесс может включать этап "разминки" (warm-up) для сбора начального покрытия и последующую мутацию как аргументов, так и самой последовательности вызовов. Могут использоваться шаблоны для определения начальных сценариев, зависимостей между функциями (например, использование возвращаемого значения одной функции как аргумента другой) и предварительных/пост-условий вызовов. Для генерации данных для NFC-тестирования могут использоваться функции, создающие конфликты в сообщениях NDEF на основе анализа протокола. | — Тестирование последовательностей вызовов<br>— Поддержка зависимостей между функциями<br>— Автоматическая генерация сценариев | RESTler, APIFuzzer, Boofuzz, Peach Fuzzer |

Выбор метода зависит от доступных данных, сложности программы и целей тестирования. Неправильный выбор снижает эффективность тестирования. Важно также порождать некорректные данные и затем исполнять их. Существует несколько методов генерации входных данных: генерация случайных данных (менее результативна) и мутация валидных данных с добавлением аномалий. Современные фаззеры могут автоматически анализировать структуру входных/выходных данных и генерировать тесты на основе этих знаний.

### Запуск тестирования 
Запуск выполняется в контролируемом окружении с мониторингом:
* Многократное выполнение программы с различными входными данными.
* Сбор информации о сбоях, исключениях, использовании ресурсов.
* Прерывание по достижении лимитов времени, количества тестов или обнаружения критических ошибок.

Запуск выявляет аномалии в поведении программы. Отсутствие контроля приводит к пропуску сбоев. После формирования данных их необходимо отправить в интерфейс, обеспечивающий взаимодействие с исследуемым приложением. В случае API-фаззинга, сгенерированная последовательность вызовов и аргументы передаются клиентской части, которая выполняет эти вызовы на целевой системе (например, мобильном устройстве).

### Анализ результатов 
Анализ идентифицирует уязвимости и ошибки:
* Фиксация сбоев: сегфолты, зависания, аварийные завершения.
* Проверка дампов памяти на переполнение буфера, некорректные указатели.
* Сравнение логов с ожидаемым поведением программы.

Результаты классифицируются: критические уязвимости, нестабильность, ложные срабатывания. Неполный анализ упускает реальные проблемы. Важным шагом является мониторинг исключений (Target Monitoring, Exception Analysis), позволяющий оценить причины возникновения исключений, и определение возможности эксплуатации найденных уязвимостей. Большинство фаззеров ведут логи, а передовые могут делать снимки состояния системы при ошибке. Заключительный этап – составление отчета (Reporting), где накапливается вся информация и формируются библиотеки уязвимостей.

**Типы выявляемых ошибок:**

| **Тип ошибки / уязвимости** | **Описание** | **Методы обнаружения / особенности** |
|-----------------------------|--------------|-------------------------------------|
| **Сбои компилятора (Compiler Crashes)** | Наиболее распространенный и легко обнаруживаемый тип ошибок. Возникают при некорректной обработке входных данных или внутренних ошибках компилятора. | Для их обнаружения достаточно проанализировать сообщение завершения работы компилятора. |
| **Ошибки некорректной компиляции (Miscompilations)** | Компилятор работает корректно, но поведение программы не соответствует семантике языка программирования. Приводит к логическим ошибкам или непредсказуемому выполнению кода. | Необходимо тестирование с разными компиляторами, версиями и режимами компиляции. Инструментация кода и анализ во время выполнения. |
| **Проблемы производительности (Performance Bugs)** | Слишком долгое время компиляции или аномально высокое время выполнения программы. | Обнаруживаются с помощью "системы голосования" (сравнение с другими компиляторами/режимами) и точного измерения времени выполнения с учетом погрешностей. |
| **Уязвимости типа "нарушение управления доступом"** | Злоумышленник может получить доступ к привилегированным функциям приложения через манипуляции с параметрами URL или формой. | Характерны для веб-приложений с ролевой моделью доступа. Фаззинг позволяет находить такие уязвимости через модификацию входных параметров. |
| **Отказ в обслуживании (DoS)** | Атака, которая блокирует доступ легитимных пользователей к ресурсам, без предоставления прав злоумышленнику. | Выполняется подачей специфических данных, вызывающих перегрузку системы или зависание. |
| **Межсайтовый скриптинг (XSS)** | Позволяет внедрять и исполнять вредоносные скрипты от имени жертвы в браузере. | Обнаруживается путем тестирования полей ввода, особенно в веб-приложениях, на восприимчивость к внедрению JavaScript. |
| **SQL-инъекция** | Внедрение SQL-кода через поля ввода, что может привести к получению контроля над базой данных сервера. | Тестирование строковых параметров на возможность внедрения SQL-команд. |
| **Слабый контроль доступа** | Наличие открытых служебных файлов и каталогов, доступных без проверки авторизации. | Обнаруживается при фаззинге путей доступа и запросов к файловой системе или API. |
| **Слабости в системе аутентификации** | Использование слабых паролей, передача учетных данных в открытом виде. | Анализ методов аутентификации и тестирование на устойчивость к подбору, прослушиванию и манипуляциям. |
| **Плохое управление сессиями** | Недостаточно случайные или короткоживущие идентификаторы сессий. | Проверяется тестированием генерации токенов и анализа их предсказуемости. |
| **Неверное применение HTTP-методов** | Использовние GET и POST для операций, которые должны использовать более безопасные методы (например, PUT, DELETE). | Анализ реакции приложения на изменение метода HTTP и параметров запроса. |
| **Исполнение удаленных команд (RCE)** | Если вводимые пользователем данные не фильтруются и передаются другим приложениям или ОС. | Фаззинг полей ввода, особенно тех, которые связаны с запуском внешних процессов или shell-скриптов. |
| **Инъекция удаленного кода (Remote Code Execution)** | Особенно опасно для PHP-приложений при плохом кодировании и отсутствии фильтрации. | Тестирование интерфейсов, принимающих код (eval, exec и др.), особенно в web-формах и API. |
| **Расщепление HTTP-запроса (HTTP Response Splitting)** | Возможность ввода CRLF в заголовки ответа, что может быть использовано для манипуляций с HTTP-ответами. | Анализ обработки заголовков и тестирование на вставку символов `\r\n`. |
| **Подделка межсайтовых запросов (CSRF)** | Атакующий заставляет аутентифицированную жертву выполнять нежелательные действия в приложении. | Тестирование отсутствия защиты от CSRF-токена и обработки HTTP-заголовков. |
| **Ошибки контроля доступа и логики** | Включают ошибки в реализации логики приложения, в том числе направления ввода, требующие идентификации пользователя. | Обнаружение через фаззинг параметров, влияющих на права и логику работы системы. |
| **Повреждение памяти и многоступенчатые уязвимости** | Такие как переполнение буфера, использование после освобождения, двойное освобождение и другие. | Обнаруживается с помощью санитайзеров (ASan, UBSan), символьного выполнения и покрытия кода. |
| **Ошибки многопоточного программирования** | Гонки данных (data races), взаимоблокировки (deadlocks). | Используются инструменты вроде Google Thread Sanitizer (GTSAN), AFL, Honggfuzz с поддержкой многопоточных сценариев. |
| **Ошибки работы с памятью и неопределенное поведение** | Деление на ноль, выход за границы массива, целочисленное переполнение и другие. | Обнаруживаются с помощью символьного выполнения, KLEE, S2E, ASan и других санитайзеров. |
| **Аутентификационные данные в коде (CWE-798)** | Хранение секретов, таких как пароли, ключи API, в открытом виде в коде. | Фаззинг конфигураций, переменных окружения, файлов на наличие явных учетных данных. |
| **Отладочная информация, приводящая к повышению привилегий (CWE-267)** | Использование отладочных функций или тестовых эндпоинтов, дающих повышенные привилегии. | Анализ скрытых эндпоинтов и тестирование на активацию отладочных режимов. |
| **Скрытые каналы передачи информации (CWE-489)** | Использование структур данных или протоколов для передачи данных вне явного канала. | Анализ побочных эффектов ввода и трассировка потока данных внутри приложения. |
| **Некорректное удаление остаточной информации (CWE-762)** | Утечки временных данных, кэшированных объектов, которые остаются в памяти или файловой системе. | Тестирование очистки временных данных, буферов, кэша и сессионных переменных. |

## Методы повышения эффективности 

| **Метод** | **Описание** | **Применение / Инструменты** | **Польза / Преимущества** |
|-----------|--------------|-------------------------------|-----------------------------|
| **Комбинирование инструментов** | Использование нескольких фаззеров (например, AFL и LibFuzzer) для увеличения охвата уязвимостей. Каждый фаззер может находить разные типы ошибок. | AFL, LibFuzzer, Honggfuzz, OSS-Fuzz | — Повышает вероятность обнаружения разных классов багов<br>— Увеличивает покрытие кода |
| **Оптимизация данных** | Регулярное обновление исходных данных на основе найденных сбоев. Создание словарей специфичных для формата входных данных. | AFL (словари), LibFuzzer (seed corpus), Radamsa | — Улучшает покрытие кода<br>— Повышает шансы пройти проверки форматов<br>— Ускоряет обнаружение новых путей |
| **Параллельное тестирование** | Распределение задач по нескольким ядрам или узлам. Для многопоточных приложений используется распараллеливание независимых переходов. | AFL++, Honggfuzz (multitarget), ClusterFuzz, distributed-AFL | — Сокращает время выполнения<br>— Повышает стабильность анализа<br>— Подходит для CI/CD |
| **Интеграция с CI/CD** | Автоматизация фаззинга в процессах сборки и тестирования проекта. | GitHub Actions, GitLab CI, Google OSS-Fuzz | — Обеспечивает регулярный анализ безопасности<br>— Находит уязвимости на ранних этапах |
| **Анализ внутреннего состояния программы** | Использование графа потока управления для генерации целевых тестовых данных, направленных на критичные участки кода. | IDA Pro, Ghidra, BinKit, KLEE | — Позволяет фокусироваться на уязвимых зонах<br>— Улучшает точность фаззинга |
| **Использование санитайзеров** | Применение AddressSanitizer, ThreadSanitizer, MemorySanitizer и других для выявления subtle bugs в памяти и многопоточности. | ASan, UBSan, MSan, TSan, KASAN | — Высокая чувствительность к ошибкам<br>— Обнаружение неявных уязвимостей<br>— Поддержка отладки и воспроизведения |
| **Улучшение покрытия кода** | Использование обратной связи от программы для корректировки входных данных и достижения более глубоких участков кода. Может включать DBI, Gcov/lcov. | AFL, AFL++ (persistent mode), gcov, lcov | — Повышает эффективность фаззинга<br>— Минимизирует повторяющиеся данные<br>— Ускоряет прохождение проверок |
| **Гибридный фаззинг** | Комбинирование фаззинга с символьным выполнением (DSE/KLEE/S2E) для исследования сложных условий и путей исполнения. | S2E, KLEE, QSYM, angr, ELF | — Глубокое исследование логики<br>— Обнаружение труднодоступных багов<br>— Поддержка полносистемного анализа |
| **Дедупликация и редукция ошибок** | Удаление дубликатов и избыточных данных из набора найденных сбоев. | Casr, afl-tmin, afl-cmin, delta-debugging | — Упрощает анализ найденных ошибок<br>— Снижает нагрузку на исследователя<br>— Повышает читаемость и воспроизводимость |
| **Применение байесовских сетей** | Использование вероятностных моделей для моделирования аномалий и оптимизации выборки тестовых данных. | Байесовские сети + custom фаззинг | — Адаптивная стратегия фаззинга<br>— Лучшая локализация ошибок<br>— Полезно при тестировании однородных систем |
| **Направленный фаззинг (Directed Fuzzing)** | Фокусировка фаззинга на наиболее критичных или изменённых частях кода. | AFL++, GREYONE, Angora | — Целевой поиск уязвимостей<br>— Эффективен при ревью кода<br>— Ускоряет обнаружение проблем в новых модулях |
| **Анализ поверхности атаки** | Точное определение функций, обрабатывающих внешние данные, чтобы сконцентрировать усилия фаззинга. | Natch, SNatch, VMI-инструменты, taint analysis | — Повышает точность фаззинга<br>— Исключает тестирование несущественных модулей<br>— Оптимизация времени и ресурсов |
| **Минимизация корпуса** | Уменьшение размера начального набора данных до наиболее значимых образцов. | AFL’s `afl-cmin`, `afl-tmin`, Casr | — Ускоряет фаззинг<br>— Уменьшает объем данных<br>— Повышает качество seed corpus |
| **Оптимизация сетевого фаззинга** | Восстановление протокола, поддержка stateful-сценариев, обход проверок контрольных сумм. | Boofuzz, AFLNet, Sulley | — Поддержка сложных протоколов<br>— Возможность тестирования API с авторизацией<br>— Учет состояния системы |
| **Использование интеллектуальных агентов** | Автономные программы, способные адаптировать стратегию фаззинга и выбирать инструменты самостоятельно. | AI-based фаззинговые платформы | — Долгосрочный автоматический анализ<br>— Самообучающаяся система<br>— Подходит для больших проектов |
| **Применение машинного обучения** | Использование ML-моделей для генерации и фильтрации тестовых примеров, выбора мутаций. | Learn&Fuzz, Neural Fuzzing, DeepHunter | — Автоматическое обучение на успешных тестах<br>— Улучшенное покрытие форматов<br>— Адаптация к особенностям программы |

📌 Примечания:
- Все перечисленные методы могут применяться **совместно**, что значительно усиливает результат.
- Эффективность фаззинга зависит не только от самого фаззера, но и от **подготовки данных**, **мониторинга**, **инструментации** и **последующего анализа**.

Методы увеличивают скорость и глубину анализа. Их игнорирование замедляет процесс и снижает качество результатов. Важно также отметить, что разработка безопасного системного ПО требует комплексного подхода, включающего нормативную базу, формальные модели управления доступом, статический и динамический анализ, а также аналитическую обработку результатов.

## Распространённые ошибки 
| Ошибка | Причина | Последствия | Способы устранения |
|---|---|---|---|
| Неправильный выбор инструмента | Несоответствие типу программы или целям тестирования. | Пропуск уязвимостей, низкая эффективность. | Тщательный анализ требований перед выбором, возможно использование нескольких инструментов. |
| Некачественные или недостаточные исходные данные | Отсутствие релевантных примеров, слишком малый или однообразный корпус. | Низкая эффективность мутационного тестирования, плохое покрытие. | Сбор разнообразных данных из реальных сценариев, документации, генерация синтетических данных. |
| Недостаточный мониторинг | Пропуск сбоев, их причин или другой аномальной активности. | Неполный анализ результатов, пропуск уязвимостей. | Использование отладочных утилит, санитайзеров, систем логирования и мониторинга ресурсов. |
| Ограниченное время тестирования | Завершение до достижения достаточного охвата или нахождения более глубоких ошибок. | Пропуск скрытых или сложных уязвимостей. | Увеличение выделяемых ресурсов и времени, использование более эффективных стратегий фаззинга. |
| Недостаточное покрытие кода | Фаззер не может "дотянуться" до некоторых частей кода из-за сложности программы, специфических условий исполнения или неэффективных стратегий генерации. | Пропуск уязвимостей в этих частях кода. | Использование техник обратной связи (coverage-guided fuzzing), инструментации, гибридного фаззинга, оптимизация входных данных и параметров мутации. |
| Проблемы совместимости фаззера | Фаззер может быть несовместим с различными версиями ОС, библиотеками или сильно привязан к особенностям конкретной ОС/архитектуры. | Невозможность провести тестирование или некорректные результаты. | Тщательный выбор и настройка фаззера, проверка совместимости, использование эмуляции или виртуализации. |
| Сложность определения причин сбоя | При использовании "тупых" или случайных методов генерации очень сложно определить, какая именно часть входных данных вызвала сбой. | Затрудненный анализ и исправление ошибок, много времени на триаж. | Использование "умных" фаззеров, автоматическая минимизация тестовых примеров (test case reduction), детальное логирование. |
| Игнорирование поверхности атаки | Тестирование компонентов, не взаимодействующих с внешними данными, или пропуск важных точек входа. | Неэффективное использование ресурсов, пропуск реальных векторов атак. | Тщательное определение и анализ поверхности атаки перед началом фаззинга. |
| Неэффективная обработка ошибок | Отсутствие автоматической дедупликации и приоритизации найденных сбоев. | Большой объем ручной работы по анализу результатов, дублирование усилий. | Внедрение систем управления ошибками с функциями дедупликации, кластеризации и минимизации. |

Ошибки снижают ценность fuzzing-а. Их устранение повышает надёжность результатов.

## Проверочные механизмы 
* **Воспроизводимость сбоев**: Повторение обнаруженных ошибок с теми же данными. Сохранение входных данных, вызвавших сбой (crashing inputs), является обязательным.
* **Кросс-проверка**: Подтверждение уязвимостей другими инструментами или методами (например, статический анализ, ручная проверка).
* **Метрики охвата**: Анализ покрытия кода (например, покрытие блоков, ребер, путей) с помощью профилировщиков (gcov, llvm-cov, sanitizer coverage). Использование компонента сбора покрытия кода, который фиксирует адреса выполненных базовых блоков. Инструмент `afl-cov` может использоваться для анализа покрытия, сгенерированного AFL. Для оценки эффективности тестирования необходимо оценить степень покрытия бинарного кода тестами. Для ядер ОС сбор покрытия может осуществляться с помощью kcov, а для визуализации используется lcov или Lighthouse.
* **Логирование**: Сравнение логов с ожиданиями для выявления отклонений. Детальное логирование действий фаззера и реакции программы.
* **Анализ сбоев (Crash Analysis):** Использование отладчиков (gdb, WinDbg) и инструментов анализа дампов памяти для определения причины сбоя и оценки его эксплуатабельности.
* **Минимизация тестовых примеров (Test Case Minimization):** Уменьшение размера входных данных, вызвавших сбой, до минимально необходимого для воспроизведения ошибки. Это значительно упрощает анализ.
* **Триаж ошибок (Bug Triage):** Классификация и приоритизация найденных ошибок по степени их критичности и вероятности эксплуатации.

Механизмы подтверждают достоверность результатов и исключают ложные срабатывания.

## Заключение 
Fuzzing-тестирование — мощный и широко применяемый инструмент для выявления уязвимостей и ошибок в программном обеспечении через автоматизированное тестирование входных данных. Эффективность метода зависит от тщательной подготовки (включая определение поверхности атаки), правильного выбора и настройки инструментов, качества исходных данных (начального корпуса), стратегий генерации и мутации, а также глубокого анализа результатов и непрерывного улучшения процесса. Применение описанных шагов, методов (включая различные типы генерации данных, использование обратной связи, анализ состояния программы, гибридные подходы) и проверочных механизмов обеспечивает воспроизводимость и полноту тестирования, что в конечном итоге значительно повышает безопасность и надежность программного обеспечения в инженерной практике.

Несмотря на некоторые ограничения, такие как высокие вычислительные затраты и сложность достижения полного покрытия кода в комплексных системах, фаззинг остается востребованной и прогрессивной технологией в области аудита и обеспечения безопасности ПО. Фаззинг веб-приложений, API, операционных систем, компиляторов и IoT-устройств демонстрирует свою эффективность в обнаружении широкого спектра дефектов. Важно помнить, что фаззинг хорошо находит определенные типы уязвимостей, такие как переполнение буфера или отказ в обслуживании, но может быть менее эффективен против скрытых угроз или логических ошибок. Поэтому его следует применять в комплексе с другими методами тестирования и анализа безопасности в рамках общего жизненного цикла безопасной разработки (Secure Development Lifecycle - SDL). Современные тенденции развития индустрии ПО позволяют по-новому взглянуть на проблему обнаружения программных дефектов, и фаззинг здесь играет важную роль. Независимые исследователи и производители коммерческих продуктов продолжают разрабатывать и улучшать технологии фаззинга, стремясь к автоматизации поиска и улучшению механизмов обнаружения ошибок.
