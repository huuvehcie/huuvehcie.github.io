# Методические рекомендации по определению поверхности атаки программного обеспечения

## Содержание

1. [Общие положения](#1-общие-положения)
2. [Цель и назначение методики](#2-цель-и-назначение-методики)
3. [Исходные данные для анализа](#3-исходные-данные-для-анализа)
   - [3.1 Идентификация объекта тестирования](#31-идентификация-объекта-тестирования)
   - [3.2 Тип и структура входных данных](#32-тип-и-структура-входных-данных)
   - [3.3 Каналы и интерфейсы приёма данных](#33-каналы-и-интерфейсы-приёма-данных)
   - [3.4 Поведение и контекст исполнения](#34-поведение-и-контекст-исполнения)
   - [3.5 Метрики анализа и механизмы обратной связи](#35-метрики-анализа-и-механизмы-обратной-связи)
4. [Этапы анализа поверхности атаки](#4-этапы-анализа-поверхности-атаки)
   - [4.1 Предварительное изучение и моделирование](#41-предварительное-изучение-и-моделирование)
   - [4.2 Статический анализ](#42-статический-анализ)
   - [4.3 Динамический анализ](#43-динамический-анализ)
   - [4.4 Построение угрозовой модели](#44-построение-угрозовой-модели)
   - [4.5 Приоритизация векторов атак](#45-приоритизация-векторов-атак)
   - [4.6 Подготовка к фаззинг-тестированию](#46-подготовка-к-фаззинг-тестированию)
   - [4.7 Документирование результатов](#47-документирование-результатов)
5. [Универсальные подходы и методы](#5-универсальные-подходы-и-методы)
6. [Особенности анализа по типам приложений](#6-особенности-анализа-по-типам-приложений)
7. [Карта фаззинга и её построение](#7-карта-фаззинга-и-её-построение)
8. [Интеграция с нормативами ФСТЭК](#8-интеграция-с-нормативами-фстэк)
9. [Оформление результатов и отчётов](#9-оформление-результатов-и-отчётов)
10. [Глоссарий терминов](#10-глоссарий-терминов)
11. [Типичные ошибки](#11-типичные-ошибки)
12. [Советы практика](#12-советы-практика)
13. [Проверка понимания](#13-проверка-понимания)

---

## 1. Общие положения

**Поверхность атаки программного обеспечения (ПА ПО)** — это совокупность всех интерфейсов, точек входа, каналов связи и механизмов, через которые внешние субъекты (пользователи, сервисы, устройства) могут передавать данные в систему, инициировать её поведение или косвенно повлиять на обработку информации.

Для задач фаззинг-тестирования анализ поверхности атаки позволяет:
- определить, какие участки кода наиболее подвержены атакам;
- выстроить стратегию фаззинга по критериям риска и критичности;
- сократить число ложноположительных находок и повысить полноту тестирования.

Анализ ПА проводится **итеративно**. Он включает не только выявление явных каналов передачи данных, но и:
- понимание архитектурных границ доверия,
- анализ логики обработки пользовательского ввода,
- оценку неявных механизмов передачи и обработки данных (скрипты, конфиги, заглушки).

---

## 2. Цель и назначение методики

Настоящие методические рекомендации предназначены для специалистов по безопасности, фаззинг-тестировщиков и аналитиков, выполняющих:
- ручной или автоматизированный анализ защищённости ПО;
- подготовку ПО к сертификации по требованиям ФСТЭК РФ;
- внедрение фаззинг-тестирования в CI/CD;
- аудит open-source или проприетарных решений.

**Методика не зависит от конкретных инструментов.** Основной акцент сделан на универсальность и применимость как для систем с открытым кодом, так и для бинарей.

Рекомендации соответствуют терминам и подходам из:
- [ГОСТ Р ИСО/МЭК 15408 (Common Criteria)](https://www.iso.org/standard/50341.html),
- [Руководящих документов ФСТЭК РФ](https://fstec.ru).

---

## 3. Исходные данные для анализа поверхности атаки

Анализ поверхности атаки невозможен без полного и системного сбора технической информации о тестируемом программном обеспечении, его окружении, интерфейсах, архитектуре и способах обработки данных. Эта информация позволяет выстроить осмысленный план фаззинга, локализовать критичные точки взаимодействия и сформировать карту уязвимостей.

### 3.1 Таблица исходных параметров

| **Параметр** | **Подробное назначение / зачем нужен** |
|-------------|------------------------------------------|
| **Целевая программа**<br>(исполняемый файл, бинарь: `.elf`, `.exe`, `.apk`, `.dll`, `.so`) | Определяет, что именно будет подвергаться фаззингу. Это конечная точка запуска, к которой привязывается процесс генерации входных данных. Структура бинаря влияет на выбор архитектуры анализа (например, необходимость эмуляции, наличие символов отладки, поддержка coverage). |
| **Формат входных данных**<br>(JSON, XML, YAML, CSV, HTML, JPEG, PNG, GIF, BMP, TIFF, MP4, AVI, MKV, PDF, DOCX, XLSX, ZIP, TAR, GZIP, ISO, ELF, PE, APK, protobuf, ASN.1, BER, DER, Bencode, Base64, Unicode, CSV, binary blobs с собственным парсингом) | Формат определяет лексико-синтаксическую структуру входных данных, от которой зависит, возможно ли использовать генеративный фаззинг, как именно проводить мутации, как выявлять структурные дефекты. Также влияет на выбор мутационных стратегий: побитовые, покусочные, уровневые. Некоторые форматы требуют stateful-фаззинга из-за межэлементных связей (например, ASN.1, XML с IDREF). |
| **Протокол передачи**<br>(TCP, UDP, HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3, FTP, TFTP, DNS, SMTP, POP3, IMAP, SMBv1, SMBv2, SMBv3, SSH, Telnet, SNMPv1, SNMPv2, SNMPv3, SIP, RTP, MQTT, AMQP, WebSocket, CoAP, gRPC, SOAP, RDP, LDAP, NTP, ICMP) | Задает логический и сетевой контекст передачи входных данных. Фаззер должен учитывать специфику протокола, порядок заголовков, особенности длины пакетов, структуру сообщений. Также влияет на выбор инструментов (например, fuzzapi для REST, AFLNet для TCP), а при Stateful-протоколах — требует построения модели состояний. |
| **Интерфейс ввода**<br>(stdin, файловая система, аргументы командной строки, API-запрос, HTTP endpoint, сокет, именованный канал, Unix Domain Socket, Shared Memory, FIFO, Named Pipe, WebSocket, RPC, D-Bus, Bluetooth socket, последовательный порт, HID/USB, OTA-интерфейс, JTAG/SWD, SPI, I²C, CAN-шина, CLI-токен, HTTP Form, GraphQL endpoint, sysfs, procfs, gRPC метод) | Определяет, где и как данные поступают в приложение. Влияет на механизм подключения фаззера (например, через harness-функции, инструменты запуска или обёртки). Позволяет отфильтровать недостижимые участки кода, исключить бесполезные точки и сосредоточить фаззинг на интерфейсах, действительно обрабатывающих внешние данные. |
| **Стратегия фаззинга**<br>(мутационная, генеративная, грамматическая, гибридная, guided, directed, feedback-driven, grammar-based, evolutionary) | Определяет механизм построения тестов: мутационная — изменяет реальные входы, генеративная — строит данные с нуля по схеме, guided — управляется покрытием. Стратегия напрямую влияет на охват кода, возможность выявления логических багов, глубину анализа вложенных структур. |
| **Набор валидных входов (Seed corpus)** | Используется как начальный материал для фаззинга. Позволяет фаззеру эволюционно улучшать покрытие, начиная с рабочих примеров. В фаззере используется для сравнения успешных путей, восстановления состояния, обучения моделей мутаций. Чем разнообразнее corpus — тем выше эффективность. |
| **Спецификация структуры данных**<br>(JSON Schema, XML Schema, DTD, protobuf .proto, ASN.1, custom grammar, PEG, context-free grammar) | Позволяет фаззеру создавать корректные и валидные входы, при этом моделируя граничные состояния, циклические вложенности и зависимости. Критично при фаззинге строго формализованных протоколов или форматов, где любая ошибка синтаксиса вызывает немедленное отклонение ввода. |
| **Обратная связь (coverage, edge coverage, block coverage, crash info, taint tracking, return codes, sanitizer hooks)** | Используется фаззером для управления направлением генерации. Позволяет исключать дубликаты, находить уникальные пути, останавливать бессмысленные мутации. Наличие coverage делает фаззинг guided, повышая эффективность на порядки. |
| **Триггеры ошибок**<br>(сигналы SIGSEGV/SIGABRT, assert-failures, stack traces, падения по таймауту, exit codes, логовые шаблоны, специфичные ошибки в выводе, core dumps, ASAN/UBSAN reports) | Позволяют автоматически идентифицировать не только сбои, но и потенциально опасные состояния (например, use-after-free, double-free, heap overflow, integer overflow). |
| **Ограничения исполнения**<br>(таймаут в мс, max_exec_per_input, ограничение по памяти, CPU, watchdog-сигналы, лимиты по глубине вложенности, количество уровней вызовов, максимальный размер входа) | Позволяют обеспечить стабильность тестов, избежать зависаний, снизить нагрузку, определить потенциальные DoS-состояния, связанные с глубокими структурами. |
| **Контекст исполнения (права, режимы запуска, архитектура, наличие отладочной информации)** | Необходим для настройки harness, трассировки, определения валидных системных вызовов. Например, в режиме root могут быть задействованы дополнительные привилегированные функции. Архитектура влияет на бинарную совместимость инструментария. |
| **Механизмы логирования и мониторинга**<br>(stdout, stderr, syslog, journald, лог-файлы, auditd, hook-функции, трассировка strace/ltrace, sanitizer hooks, custom logger) | Позволяют отслеживать внутреннее поведение приложения и выявлять ошибки, которые не приводят к аварийному завершению (например, логическая ошибка, пустой вывод, бесконечный цикл). |
| **Архитектура платформы**<br>(x86, x86_64, ARMv7, ARM64, MIPS, PowerPC, RISC-V, SPARC, AVR) | Влияет на выбор эмулятора (QEMU, Unicorn), специфику инструментов трассировки, компиляции, отладки, сборки обвязки, поддержку ASAN/UBSAN и совместимость с Coverage-инструментами. |
| **Вариант сборки**<br>(debug, release, с ASAN, с coverage-инструментами, без оптимизаций, с полной трассировкой) | Определяет возможность получения отладочной информации, трассировки и отчётов ASAN. Например, релизная сборка может скрыть краш без SIGSEGV. |
| **Entry Points / Target Functions**<br>(функции парсинга, обработчики, syscalls, callback'и, parser-функции, main entrypoints) | Являются целями фаззинга. Фокусировка на конкретных entrypoints позволяет повысить эффективность, особенно при модульной архитектуре или при фаззинге библиотек. |
| **Источник покрытия (GCOV, llvm-cov, QEMU, ptrace, AFL shared memory, DynamoRIO, Intel PT)** | Используется для управления фаззингом по покрытию. Позволяет обнаруживать ранее непосещённые пути, уточнять результативность мутаций и отбрасывать бесполезные варианты. |

---

## 4. Этапы анализа поверхности атаки

Анализ поверхности атаки проводится поэтапно, начиная с общей архитектурной картины и заканчивая конкретизацией точек входа и приоритизацией фаззинга. Каждый этап направлен на выявление конкретных аспектов уязвимостей: от необработанных данных до недокументированных интерфейсов.

---

### 4.1 Предварительное изучение и моделирование

| Этап | Назначение |
|------|------------|
| Анализ документации | Выявление архитектурных компонентов, доверенных и недоверенных границ, спецификаций API и форматов. Используются технические описания, архитектурные диаграммы, OpenAPI/Swagger, пользовательская документация. |
| Определение доверенных границ (trust boundaries) | Установление точек пересечения данных между зонами с различным уровнем доверия (пользователь → служба, веб-интерфейс → API, внешний JSON → десериализатор). Это ключевой шаг для построения модели атак. |
| Моделирование потоков данных | Построение схем: DFD (Data Flow Diagram), FSM (Finite State Machine), архитектурных схем взаимодействия. Отмечаются все входы и выходы, передаваемые данные, преобразования, преобразователи форматов, вызовы внешних функций. |
| Уточнение интерфейсов | Формирование списка интерфейсов, их технических характеристик (порт, протокол, авторизация, режимы доступа), возможных нестандартных конфигураций. |
| Документирование сценариев использования | Определение всех способов запуска ПО: ручной, системный, через API, через планировщик, по событию, через автозапуск, внешнее сообщение. Помогает выявить неочевидные входы. |

---

### 4.2 Статический анализ

| Объект анализа | Методы и цель |
|----------------|---------------|
| Исходный код | Анализ trust boundaries, выявление функций, взаимодействующих с вводом (file_read, recv, parse_json, fread, sscanf), поиск небезопасных конструкций (`strcpy`, `memcpy`, `eval`, `system`, `gets`), отсутствие проверок границ. Используются инструменты: `grep`, `flawfinder`, `Cppcheck`, `Bandit`, `semgrep`. |
| Конфигурации | Анализ конфигурационных скриптов, переменных окружения, файлов запуска (unit-файлы systemd, конфиги init.d, файлы `.env`, `config.yaml`, `settings.xml`). Выявление потенциальных "логических бэкдоров", insecure defaults. |
| Сторонние библиотеки | Проверка внешних зависимостей: openSSL, libxml, zlib, curl, Qt, GTK, ffmpeg, sqlite, и др. Ищутся известные CVE, версии, наличие патчей. |
| Уровень сборки | Оценка использования флагов безопасности (`-fstack-protector`, `RELRO`, `PIE`, `ASLR`, `FORTIFY_SOURCE`), бинарного hardening. Важно при анализе безопасности ELF/PE/APK. |
| Переменные и макросы компиляции | Поиск conditionally compiled участков: `#ifdef DEBUG`, `#ifndef NDEBUG`, `#ifdef _WIN32`, влияющих на поверхность атаки при разных сборках. |

---

### 4.3 Динамический анализ

| Метод | Назначение |
|-------|------------|
| Захват сетевой активности | Используются `tcpdump`, `Wireshark`, `tshark`, `mitmproxy`, `burp`. Позволяют зафиксировать реальные соединения, параметры запросов, заголовки, cookie, передачи по WebSocket, обнаружить незадокументированные методы. |
| Трассировка системных вызовов | `strace`, `ltrace`, `auditd`, `DTrace`, `Procmon`. Позволяют определить доступ к файлам, сокетам, mmap, ioctl, execve, fork, getenv. Обнаруживают обработку нестандартных вводов. |
| Динамическая трассировка API | Использование `Frida`, `Valgrind`, `Pin`, `rr`, `Ghidra trace`, позволяет отследить исполнение определённых функций, цепочки вызовов, аргументы при вызове критичных API. |
| Поведенческий анализ в песочнице | Запуск в `Firejail`, `Docker`, `QEMU`, `Unicorn`, позволяет наблюдать влияние на сеть, ФС, память, без риска для основной системы. |
| Мониторинг логов и журналов | `syslog`, `journald`, custom logging. Фиксация runtime-ошибок, assert'ов, тайм-аутов, отказов в доступе, переполнений. |

---

### 4.4 Построение угрозовой модели

| Подход | Применение |
|--------|------------|
| STRIDE | Классификация по категориям: Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege. Позволяет отнести каждую точку входа к типу риска. |
| DREAD | Используется для расчёта приоритета: Damage, Reproducibility, Exploitability, Affected Users, Discoverability. Полезно для составления roadmap тестов. |
| MITRE ATT&CK Mapping | Отнесение точек входа и поведения к известным техникам атаки (Initial Access, Execution, Persistence, etc.) |
| MUC (Model Use Case) | Моделирование типовых злоупотреблений — формулируются сценарии: «атака на API методом `POST /upload` с неконтролируемым размером», «использование старого токена для обхода авторизации». |

---

### 4.5 Приоритизация векторов атак

| Критерий | Что оценивается |
|----------|-----------------|
| Удалённость доступа | Интерфейсы с возможностью удалённого подключения (HTTP, WebSocket, FTP) получают более высокий приоритет, чем локальные IPC или stdin. |
| Уровень прав | Интерфейсы, взаимодействующие с root-действиями (управление устройствами, конфигурация, обновления) — более критичны. |
| Формат и сложность данных | Форматы с высокой вложенностью и спецификой (ASN.1, XML, бинарные контейнеры с offset'ами) приоритетны. |
| Частота использования | Точки, активно используемые системой или пользователем, представляют больший риск. |
| Наличие истории уязвимостей | Интерфейсы, в которых ранее находились CVE или баги, включаются в зону внимания в первую очередь. |
| Потенциал разрушения | Вход, ведущий к выполнению кода, удалению файлов, изменению состояния системы — считается приоритетным. |

---

### 4.6 Подготовка к фаззинг-тестированию

| Подэтап | Назначение |
|--------|------------|
| Выбор целевых точек | Формирование списка функций, API, интерфейсов, на которые будет направлен фаззинг. |
| Построение harness | Разработка обвязки, которая запускает код с заданным вводом (например, через fuzzer entrypoint). |
| Выбор фаззера | AFL, LibFuzzer, honggfuzz, Peach, boofuzz, RESTler, Radamsa, zzuf — в зависимости от типа интерфейса и покрытия. |
| Подготовка тестовых данных | Создание seed corpus, генераторов, грамматик, кастомных мутаций, фиктивных зависимостей. |
| Интеграция мониторинга | Настройка coverage, логирования, автоматического анализа крашей, тайм-аутов, сигналов. |

---

### 4.7 Документирование результатов

| Компонент | Назначение |
|-----------|------------|
| Таблицы точек входа | Содержат список интерфейсов, описание, критичность, путь к воспроизведению, потенциальные векторы. |
| Архитектурные схемы | Диаграммы компонентов, доверенных границ, DFD, графы вызовов. |
| Приоритеты фаззинга | Отдельный файл или раздел, содержащий обоснование очередности фаззинга. |
| Сводные отчёты | Подготовка к подаче в рамках сертификации (ГОСТ, ФСТЭК, ISO), включение в отчёты по защищённости. |

---

## 5. Универсальные подходы и методы анализа поверхности атаки

Анализ поверхности атаки требует применения комплекса методик, охватывающих как код, так и архитектуру, поведение во время исполнения, конфигурацию и сетевое окружение. Ниже представлены универсальные подходы, применимые к программному обеспечению любого типа.

---

### 5.1 Статический анализ

| Метод | Назначение |
|-------|------------|
| **Анализ исходного кода** | Обнаружение точек входа (функций, принимающих внешние данные), trust boundaries (границы между модулями, уровнями привилегий), а также конструкций, вызывающих подозрения: прямые обращения к памяти (`malloc`, `memcpy`, `strcpy`), использование eval, insecure deserialization, вызовы внешних команд (`system`, `popen`, `execve`), отсутствие проверок (`if`, `assert`) на границах массива, строки, параметров. |
| **Поиск опасных паттернов** | Сигнатурный поиск функций из списка небезопасных API: `gets`, `strcat`, `scanf`, `realpath`, `setuid`, `chown`, `mktemp`, `rand`, а также пользовательских реализаций сериализаторов, XML/JSON парсеров. |
| **Анализ конфигурации и скриптов запуска** | Выявление параметров, влияющих на поведение: разрешение сетевых портов, включение/отключение auth, debug mode, insecure defaults, пути загрузки библиотек, задание внешних IP-адресов. |
| **Проверка используемых библиотек** | Составление списка всех зависимостей (`ldd`, `objdump`, `nm`, `pip freeze`, `npm list`, `gradle dependencies`), выявление их версий, сопоставление с CVE, определение включённых функций. |
| **Анализ структуры бинарей** | Проверка наличия символов отладки, ASLR, RELRO, NX, PIE, FORTIFY_SOURCE, stack canaries. Используются `checksec`, `readelf`, `objdump`, `goblin`, `elflint`. |

---

### 5.2 Динамический и поведенческий анализ

| Метод | Назначение |
|-------|------------|
| **Мониторинг системных вызовов** (`strace`, `ltrace`, `auditd`) | Определение точек взаимодействия приложения с ОС: доступ к файлам, сокетам, shared memory, вызовы fork/exec, системные сигналы. |
| **Трассировка API** (`Frida`, `Valgrind`, `DynamoRIO`, `rr`) | Наблюдение за внутренними вызовами функций, просмотр аргументов, возвратов, работы со структурой данных. |
| **Инструменты анализа памяти** (`ASAN`, `UBSAN`, `Valgrind`, `Electric Fence`) | Выявление ошибок: use-after-free, heap overflow, integer overflow, race conditions, memory leaks. |
| **Поведенческий анализ в песочнице** (`Firejail`, `Docker`, `QEMU`, `Unicorn`, `gVisor`, `Flatpak`) | Безопасное выполнение с наблюдением за выходами, файловыми операциями, сетевыми запросами. |
| **Анализ логов исполнения** | Анализ логов, журналов, stdout/stderr, системных сообщений на предмет сбоев, необработанных исключений, тайм-аутов, падений. |

---

### 5.3 Сетевой анализ и перехват трафика

| Метод | Назначение |
|-------|------------|
| **Сканирование портов и сервисов** (`nmap`, `masscan`, `netstat`, `ss`) | Выявление доступных сетевых точек входа, слушающих интерфейсов, сервисов, а также их баннеров и версий. |
| **Перехват и анализ трафика** (`Wireshark`, `tcpdump`, `tshark`, `mitmproxy`, `ZAP`, `Burp Suite`) | Получение содержимого входных сообщений, определение параметров API, токенов, cookies, headers, формат запросов и ответов, анализ нестандартных протоколов, обнаружение скрытых endpoint'ов. |
| **Проверка криптографической конфигурации** (`testssl.sh`, `sslscan`, `sslyze`, `nmap -script ssl*`) | Определение использования устаревших алгоритмов, открытых TLS портов, слабых цепочек сертификатов, неверных настроек SSL/TLS. |

---

### 5.4 Анализ API и взаимодействий

| Метод | Назначение |
|-------|------------|
| **Сбор и анализ API-документации** (Swagger/OpenAPI, gRPC proto, Postman Collection, WSDL, RAML, AsyncAPI) | Выявление всех endpoint'ов, их параметров, типов данных, логики авторизации, ограничения методов, вариантов входов и выхода. |
| **Ручной вызов API** (`curl`, `httpie`, `Postman`, `SoapUI`, `grpcurl`) | Позволяет вручную проверить, как система обрабатывает корректные и некорректные данные, наличие валидации, проверок типов, ограничений доступа. |
| **Инструментальный API-фаззинг** (`RESTler`, `graphql-fuzzer`, `fuzzapi`, `Boofuzz`, `OWASP ZAP Fuzzer`, `Wfuzz`, `Burp Intruder`) | Автоматическая генерация запросов на основе документации или прокси-логов. Тестируются поля, порядок параметров, вложенность, наличие обязательных и необязательных аргументов. |

---

### 5.5 Файловый анализ

| Метод | Назначение |
|-------|------------|
| **Анализ обработки файлов** | Определение точек входа через `open`, `fread`, `parse_file`, `load_config`, `deserialize`. Проверка наличия фильтрации расширений, проверки сигнатур, ограничений на размер и структуру. |
| **Фаззинг форматов** (`AFL`, `Radamsa`, `zzuf`, `Peach`, `Boofuzz`, `libFuzzer`) | Используется для проверки устойчивости парсеров, обхода проверок валидности, атаки через спецсимволы, скрытые структуры. |
| **Directory Traversal** | Проверка, можно ли подставить в имя файла конструкции типа `../`, `%2e%2e/`, `..\\`, чтобы выйти за пределы корневого каталога. |
| **Символьные и жёсткие ссылки** | Тестируются атаки через `symlink`, `hardlink`, атака на конфигурацию или временные файлы. |

---

### 5.6 Аппаратные и встроенные интерфейсы

| Метод | Назначение |
|-------|------------|
| **Сканирование интерфейсов** (`lsusb`, `lspci`, `dmesg`, `udevadm`, `i2cdetect`, `can-utils`) | Определение наличия UART, SPI, I²C, CAN, GPIO, JTAG, Bluetooth, Wi-Fi, NFC, RF. |
| **Фаззинг по шинам** (`SocketCAN`, `custom UART fuzzer`, `firmware SPI injector`) | Инъекция некорректных команд, симуляция устройств, проверка на переход в отладочные или привилегированные режимы. |
| **Извлечение и анализ прошивки** (`binwalk`, `Firmware-mod-kit`, `Ghidra`, `IDA Pro`, `QEMU`) | Анализ bootloader'ов, web-интерфейсов, init-сценариев, shell-интерпретаторов, обнаружение "скрытых" меню и команд. |

---

### 5.7 Подходы к полноте и перекрёстной проверке

| Подход | Назначение |
|--------|------------|
| **Сравнение статического и динамического анализа** | Все точки входа, найденные при статическом анализе, должны быть подтверждены динамикой. Всё, что активно при запуске — должно быть найдено статикой. Несовпадения указывают на недокументированные или забытые участки. |
| **Использование шаблонов угроз (OWASP, CWE, CAPEC)** | Проверка на типовые сценарии: SQL-инъекции, XSS, CSRF, open redirect, SSRF, insecure deserialization, command injection, race condition, memory corruption. |
| **Обратное моделирование из логов** | Выявление ошибок, неявных API, обходных путей на основе записей в логах исполнения. |
| **Сравнительный анализ версий** | Используется для нахождения diff'ов между обновлениями — помогает выявить закрытые уязвимости и новые точки входа. |

---

## 6. Особенности анализа по типам приложений

Разные типы программного обеспечения имеют свои характерные поверхности атаки. Методика анализа в каждом случае должна учитывать специфику архитектуры, интерфейсов, протоколов, используемых форматов данных и механизма исполнения.

---

### 6.1 Веб-приложения

| Компонент / точка входа | Назначение и вектор анализа |
|--------------------------|-----------------------------|
| **HTTP(S) запросы** (GET, POST, PUT, DELETE, PATCH) | Основной канал передачи пользовательских данных. Анализируется URI, query-параметры, заголовки, тело запроса, методы. Проверяется обработка специальных символов, отсутствие фильтрации, возможность инъекций. |
| **Заголовки HTTP** (`User-Agent`, `Referer`, `Cookie`, `X-Forwarded-For`, `Authorization`, `Content-Type`) | Могут использоваться в логике приложения. Ошибки в обработке — источник уязвимостей типа header injection, bypass-аутентификации. |
| **Формы HTML** | Исходные данные поступают через формы: поля input, select, textarea. Анализируются параметры, CSRF-токены, client-side валидация. |
| **Файлы cookie и сессии** | Проверяется: длина токена, способ генерации, срок действия, привязка к IP/агенту, возможность перебора, формат сессионных идентификаторов. |
| **JavaScript (клиентский код)** | Анализируются точки, в которых пользовательские данные попадают в DOM: `innerHTML`, `document.write`, `eval`, `Function()`, атрибуты `href`, `src`, `on*`. Основной вектор — XSS. |
| **Загрузка файлов** | Проверка расширений, сигнатур, размера, места сохранения. Ищутся уязвимости: directory traversal (`../../etc/passwd`), выполнение через MIME-тип (`.php`, `.exe`). |
| **AJAX и WebSocket** | Точки API, не отображающиеся напрямую на сайте. Анализ: логика авторизации, параметры, JSON/XML. Возможны IDOR, CSRF, bypass auth. |
| **API (REST/GraphQL)** | Поля, вложенные структуры, enum-значения, фильтрация. GraphQL уязвим к introspection, alias-overload, batch-query abuse. |
| **Встраиваемые CMS/фреймворки** (WordPress, Django, Laravel, Flask, Express, Spring, Ruby on Rails) | Используемые модули часто включают дополнительные незащищённые endpoint'ы. Необходимо изучать конфигурации маршрутизации, включённых компонентов. |
| **Форматы передачи данных** (JSON, XML, URL-encoded, FormData, multipart/form-data) | Для каждого — своя логика фаззинга. XML — возможны XXE, XPath-инъекции. JSON — анализ вложенности, сериализации, обход валидации. |
| **Инструменты анализа** | `Burp Suite`, `OWASP ZAP`, `Wfuzz`, `sqlmap`, `Arachni`, `Nikto`, `GraphQLmap`, `Postman`, `Restler`, `Fuzzapi`. |

---

### 6.2 Десктопные приложения

| Компонент / интерфейс | Назначение и вектор анализа |
|------------------------|-----------------------------|
| **Пользовательский интерфейс (GUI)** | Ввод через формы, клики, drag&drop, clipboard. Анализируются поля ввода, размер и типы данных, переносимые объекты. |
| **Аргументы командной строки (CLI)** | Потенциально небезопасные параметры: пути, ключи, выражения. Проверка на переполнения буфера, некорректную обработку `--help`, `--config`, `--file`. |
| **Файлы конфигурации** | YAML, INI, JSON, XML — используются для хранения настроек. Проверяется наличие eval, exec, импортов, переопределения путей. |
| **Обработка пользовательских файлов** | Открытие документов, изображений, мультимедиа. Возможны уязвимости: десериализация, парсеры, устаревшие форматы (OLE, TIFF, AVI). |
| **Логика автозагрузки и обновления** | Файлы в `%APPDATA%`, `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`, `launchctl`, `systemd`. Проверяется возможность подмены, инжекции. |
| **Взаимодействие с ОС** | Использование COM/ActiveX, named pipes, файлов в `%TEMP%`, API `ShellExecute`, `CreateProcess`. Анализируются пути передачи данных и прав. |
| **Инструменты анализа** | `Ghidra`, `OllyDbg`, `IDA`, `WinDbg`, `Process Monitor`, `Dependency Walker`, `PEStudio`, `Sysinternals Suite`. |

---

### 6.3 Мобильные приложения

#### Android

| Компонент | Назначение |
|-----------|------------|
| **Activity / Intent Filters** | Определяют точки входа. Проверяется: возможность вызова из другого приложения, наличие `android:exported`, передаваемые extras. |
| **Broadcast Receivers** | Часто не проверяют источник сообщения. Возможны атаки через custom Intent'ы. |
| **Content Providers** | Доступ к файлам/БД. Ошибки в URI-обработке, race conditions. |
| **WebView** | Источник XSS, открытие произвольных URL, доступ к JS-интерфейсам. Проверяется конфигурация `setJavaScriptEnabled`, `addJavascriptInterface`. |
| **Локальные БД (SQLite)** | Проверяется: шифрование, доступ, таблицы, SQL-инъекции при передаче пользовательских данных. |
| **AndroidManifest.xml** | Разрешения, экспортируемые компоненты, интенты, провайдеры. Ошибки конфигурации — источник уязвимостей. |
| **Инструменты** | `apktool`, `jadx`, `MobSF`, `Frida`, `adb`, `Xposed`, `Burp Suite`, `qark`, `dex2jar`. |

#### iOS

| Компонент | Назначение |
|-----------|------------|
| **URL Scheme Handlers** | Возможность вызвать приложение извне. Часто приводят к SSRF, spoofing, bypass auth. |
| **Obj-C методы** | Перехват через `class-dump`, `cycript`, `Frida`. Проверка аргументов, отсутствия проверок. |
| **Интеграции с iCloud, Bluetooth, GPS** | Проверка доступов, валидации данных от устройств. |
| **Jailbreak-пути** | Проверка наличия небезопасных API, доступов к защищённым частям системы. |
| **Инструменты** | `Frida`, `Cycript`, `class-dump`, `needle`, `iRET`, `objection`, `SSL Kill Switch`. |

---

### 6.4 Встраиваемые (Embedded) системы

| Компонент | Назначение и вектор анализа |
|-----------|-----------------------------|
| **Интерфейсы ввода-вывода** (UART, SPI, I²C, GPIO, CAN, SWD, JTAG) | Позволяют перехватывать трафик, запускать отладку, войти в инженерный режим. Проверяется доступность портов, команды, наличие защит. |
| **Прошивка** | Анализируется: binwalk → извлечение → squashfs → скрипты init → пароли → сетевые интерфейсы. Проверка наличия: скрытых CLI, root shell, debug меню. |
| **Радиоинтерфейсы** (Wi-Fi, BLE, ZigBee, LoRa, NFC) | Используются как каналы взаимодействия. Проверяются: пары ключей, spoofing, man-in-the-middle, replay-атаки, недокументированные команды. |
| **Веб-интерфейсы управления** | Часто уязвимы: отсутствие auth, XSS, CSRF, подмена конфигураций. Анализ с точки зрения веб-приложения. |
| **Механизмы обновления (OTA)** | Проверка: подписи, downgrade protection, integrity check, возможность перезаписи образа. |
| **Инструменты анализа** | `binwalk`, `Firmware Analysis Toolkit`, `Ghidra`, `JTAGulator`, `QEMU`, `Unicorn`, `logic analyzer`, `radare2`. |

---

## 7. Карта фаззинга и её построение

**Карта фаззинга (fuzzing map)** — это структурированный документ или диаграмма, отражающая:
- все выявленные точки входа, принимающие данные от внешних источников;
- типы и форматы данных, обрабатываемых на входе;
- способ передачи этих данных;
- применимую стратегию фаззинга и выбранные инструменты;
- приоритетность в соответствии с критичностью.

---

### 7.1 Таблица построения fuzzing map

| Компонент | Описание и назначение |
|-----------|------------------------|
| **Точка входа (Entry Point)** | Конкретный механизм или интерфейс, через который внешние данные поступают в систему: API, CLI-параметры, парсеры файлов, сокеты, HTTP-запросы, shared memory, аппаратные интерфейсы. |
| **Тип данных** | Формат и структура: JSON, XML, ZIP, MP4, ASN.1, protobuf, ELF, Base64, HTML, PDF, multipart, FormData, граф структуры, бинарные фреймы, сериализованные объекты, строки, команды. |
| **Канал передачи** | Способ доставки данных: TCP, UDP, stdin, аргументы командной строки, файлы, HTTP body, WebSocket, pipes, Bluetooth, shared memory, POST-запрос. |
| **Обработка/функция** | Функция или цепочка, принимающая данные: `parse_json()`, `load_file()`, `recv()`, `parse_headers()`, `process_packet()`, `deserialize_payload()`, `fscanf()`. |
| **Trust Boundary** | Является ли переход границей доверия: пользователь → система, внешний клиент → API, необработанные данные → ядро. |
| **Формальная схема** | Наличие спецификации: JSON Schema, XML DTD, .proto, grammar-файл, регулярные выражения, список допустимых параметров. |
| **Тип фаззинга** | Подход: мутационный, генеративный, грамматический, guided, coverage-based, protocol state-based, symbolic. |
| **Инструмент** | Подходящие фаззеры: `AFL++`, `libFuzzer`, `honggfuzz`, `Radamsa`, `RESTler`, `Boofuzz`, `Peach`, `zzuf`, `ZAP Fuzzer`, `GraphQLmap`, `gfuzz`, `Fuzzapi`, `Atheris`, `Fuzzilli`, кастомные скрипты. |
| **Метод запуска** | Обвязка или harness: standalone binary, `main(argc, argv)`, через shared lib, внутри контейнера, fuzz target, встраивание фреймворка (`libfuzzer`, `afl_fuzz_entrypoint`). |
| **Обратная связь** | Coverage-guided (`SanCov`, `libFuzzer`), signal-based (`SIGSEGV`, `SIGABRT`), логический output (response code, timeout, exit code), memory sanitizer, path divergence, custom hooks. |
| **Приоритет** | Высокий — удалённый интерфейс без аутентификации, средний — локальный парсер с ограниченными правами, низкий — файл конфигурации, не изменяемый извне. |

---

### 7.2 Пример упрощённой карты фаззинга (фрагмент)

| Entry Point      | Format     | Interface | Function        | Strategy     | Fuzzer        | Priority |
|------------------|------------|-----------|------------------|--------------|---------------|----------|
| `/api/upload`    | `multipart/form-data` | HTTP      | `handle_upload()` | Grammar-based | RESTler       | High     |
| `--file=config`  | `YAML`     | CLI args  | `load_config()`  | Mutational   | libFuzzer     | Medium   |
| `/dev/ttyUSB0`   | binary frame | UART     | `parse_frame()`  | Generative   | custom script | High     |
| `/data/input.xml`| `XML`      | File      | `xml_parse()`    | Grammar-based | Peach         | Medium   |
| WebSocket `msg`  | JSON       | WebSocket | `process()`      | Coverage-guided | AFL++       | High     |
| RPC `.proto`     | Protobuf   | TCP       | `rpc_dispatch()` | Structured   | Boofuzz       | High     |

---

### 7.3 Цель и эффект карты фаззинга

- **Повышение полноты охвата:** карта исключает слепые зоны, где интерфейс не был протестирован.
- **Рационализация усилий:** можно начать фаззинг с наиболее критичных точек, минимизируя затраты.
- **Формализация процесса:** карта документирует всё, что потом можно перенести в CI/CD и повторно использовать.
- **Согласование с безопасниками:** карта служит интерфейсом коммуникации между пентестерами, разработкой и QA.

---

## 8. Интеграция с нормативами ФСТЭК

Анализ поверхности атаки и построение карты фаззинга напрямую соотносятся с требованиями нормативных документов ФСТЭК России. Корректное выполнение этих процедур обеспечивает соответствие требованиям по контролю защищённости и обоснование охвата фаззинг-тестированием при сертификации.

---

### 8.1 Соответствие требованиям ФСТЭК

| Элемент анализа | Связанный документ / требование | Назначение в рамках регламента |
|------------------|-------------------------------|--------------------------------|
| **Идентификация точек входа** | РД ФСТЭК.4.003–2020 «Методика определения типа и класса угроз» | Установление границ доверия и потенциальных каналов несанкционированного воздействия. |
| **Построение модели нарушителя** | РД ФСТЭК.4.003, Профили защиты | Анализ критических точек с позиции возможностей внешнего или внутреннего нарушителя. |
| **Приоритизация и категоризация угроз** | Классификаторы ФСТЭК, STRIDE, DREAD | Уточнение класса угроз, приоритетов тестирования и перечня защитных мероприятий. |
| **Описание поверхностей атаки** | Методика анализа уязвимостей ИСПДн, ГИС, СУБД | Подлежит включению в документацию на этапе оценки соответствия (Акт анализа уязвимостей, Модель угроз). |
| **Формирование отчёта по результатам анализа** | ФСТЭК «Требования к отчёту по результатам оценки защищённости» | Представление карты фаззинга, покрытия входов, используемых методов и результатов анализа. |

---

### 8.2 Сопоставление шагов методики и требований ФСТЭК

| Шаг методики анализа ПА | Требование ФСТЭК | Назначение |
|--------------------------|------------------|------------|
| Сбор интерфейсов и точек входа | Модель угроз, границы доверия | Установление зон воздействия и каналов атаки. |
| Статический анализ источников данных | Анализ уязвимостей | Идентификация возможных векторов воздействия и потенциальных багов. |
| Динамический запуск и трассировка | Подтверждение достижимости точек кода | Обоснование применимости тестов и полноты покрытия. |
| Построение карты фаззинга | Акт оценки защищённости | Является доказательством охвата всех интерфейсов. |
| Документирование coverage и крашей | Журнал тестирования, Протоколы | Используется для подтверждения выполнения требуемых процедур. |

---

## 9. Оформление результатов и отчётов

Результаты анализа поверхности атаки, построения карты фаззинга и последующего тестирования должны быть оформлены в виде технической документации, соответствующей внутренним регламентам организации, требованиям регуляторов (ФСТЭК, МинЦифры, ФСБ, РКН, ГРЧЦ), а также потребностям команд разработки, QA и ИБ.

---

### 9.1 Типы документации

| Документ | Назначение |
|----------|------------|
| **Отчёт по анализу поверхности атаки** | Содержит описание всех выявленных точек входа, типов данных, каналов передачи, взаимодействующих функций, границ доверия и предполагаемых векторов атак. Используется как самостоятельный документ и как часть модели угроз. |
| **Карта фаззинга (Fuzzing Map)** | Подробная таблица, описывающая, какие интерфейсы подвергались фаззингу, с какими параметрами, какими средствами, с какой обратной связью и на каких условиях исполнения. |
| **Отчёт о тестировании (Crash/Issue Report)** | Список обнаруженных проблем с трассировками, входными данными, логами, метками времени, типами ошибок (heap overflow, UAF, logic bug). |
| **Отчёт по покрытиям (Coverage Report)** | Содержит данные о покрытии кода, функций, блоков, путей (edge/path coverage). Отражает эффективность фаззинга, полноту и возможные слепые зоны. |
| **Итоговый протокол фаззинга** | Комплексный документ: включает карту фаззинга, список использованных инструментов, конфигурацию окружения, запусков, версии сборок, количество выполненных тестов, процент покрытия, статистику сбоев. |
| **Акт анализа уязвимостей** | Документ, входящий в пакет сертификации (ФСТЭК), включает выводы по результатам анализа ПА и выявленных уязвимостей. |

---

### 9.2 Рекомендуемая структура отчёта по ПА

```plaintext
1. Общие сведения о программном обеспечении
   - Название, версия, архитектура, сборка, источник

2. Сценарии запуска и взаимодействия
   - CLI, API, загрузка данных, файл конфигурации

3. Выявленные точки входа
   - Таблица точек с интерфейсами, функциями, форматом данных

4. Типы данных и их спецификации
   - JSON Schema, protobuf, ASN.1, XML DTD и т.д.

5. Трассировка обработки данных
   - Вход → функция → поведение

6. Trust Boundaries
   - Границы между уровнями доступа и контекстами

7. Потенциальные векторы атак
   - Конкретные механизмы: переполнения, инъекции, уязвимости конфигурации

8. Карта фаззинга
   - Полная таблица всех протестированных интерфейсов и параметров

9. Приоритизация
   - На основе удалённости, привилегий, истории уязвимостей

10. Используемые инструменты и методы
    - Fuzzers, coverage tools, analysis frameworks

11. Результаты тестирования
    - Кол-во тестов, краши, критичность, устранение

12. Заключение и рекомендации
    - Что требуется исправить, на что обратить внимание, зоны риска
```

### 9.3 Таблица фиксации точки входа (примеры)

| Интерфейс             | Функция          | Формат данных   | Метод обработки                        | Boundary             | Coverage | Приоритет |
|-----------------------|------------------|------------------|----------------------------------------|-----------------------|----------|-----------|
| `/api/upload`         | `handle_upload()`| `multipart`      | парсинг тела, сохранение, валидация    | внешний → сервер      | 85%      | высокий   |
| `--input config.yaml` | `load_config()`  | `YAML`           | десериализация, маппинг                | CLI → runtime         | 91%      | средний   |
| `UART /dev/ttyUSB0`   | `parse_frame()`  | бинарный фрейм   | парсинг вручную, memcopy               | аппаратный → ядро     | 65%      | высокий   |

---

### 9.4 Минимальные требования к документу

| Компонент             | Требования |
|------------------------|------------|
| **Трассируемость**     | Любой краш, найденный фаззером, должен быть сопоставим с входными данными, точкой входа и функцией. |
| **Достоверность покрытия** | Используются проверенные инструменты (`llvm-cov`, `gcov`, `AFL coverage map`). Поясняется, как получены данные. |
| **Версионирование**    | Указывается версия фаззера, сборки, зависимостей. Обязательно наличие контрольных сумм (SHA256). |
| **Повторяемость тестов** | Указаны флаги запуска, сценарии, тайм-ауты, переменные окружения. Желательно include файла запуска. |
| **Формализация результатов** | Все данные в виде таблиц, ссылок на входные файлы, отчётов, логов, трасс. Приложения — обязательны. |

## 10. Глоссарий терминов

| Термин | Определение |
|--------|-------------|
| **Анализ поверхности атаки (Attack Surface Analysis)** | Процесс выявления всех возможных точек входа, через которые внешние данные могут попасть в систему и потенциально повлиять на её поведение или безопасность. Включает анализ интерфейсов, каналов связи, функций обработки данных и границ доверия. |
| **Fuzzing (фаззинг)** | Метод автоматизированного тестирования, при котором в систему вводятся случайно сгенерированные или специально мутированные данные с целью вызвать сбой, аварийное завершение или проявление уязвимости. |
| **Coverage** | Метрика, показывающая, насколько полно тестами (в т.ч. фаззингом) охвачен исходный код или исполняемый модуль: количество покрытых функций, блоков, путей, ветвлений. |
| **Seed Corpus** | Начальный набор валидных входных данных, используемых фаззером как база для мутаций. Чем разнообразнее и репрезентативнее корпус — тем выше эффективность тестирования. |
| **Trust Boundary** | Граница между компонентами системы, обладающими различным уровнем доверия. Например, пользовательский ввод → внутренний парсер. Пересечение границы без валидации создаёт потенциальную уязвимость. |
| **Entry Point** | Точка входа в приложение или библиотеку, через которую осуществляется обработка внешних данных. Может быть функция, API-метод, CLI-параметр, файл, сокет и т.п. |
| **Harness** | Обвязка, запускающая тестируемую функцию/программу с определённым вводом. Используется для подключения фаззера к конкретной точке входа в код. |
| **Crash** | Аварийное завершение программы в результате ошибки: SIGSEGV, stack overflow, abort, divide by zero, assertion fail. В фаззинге фиксируется как потенциальная уязвимость. |
| **ASAN (Address Sanitizer)** | Инструмент, отслеживающий ошибки работы с памятью: выход за границы буфера, use-after-free, double-free и т.п. Работает на этапе исполнения. |
| **UBSAN (Undefined Behavior Sanitizer)** | Инструмент, отслеживающий неопределённое поведение в C/C++ коде: переполнения, неверные преобразования типов, нарушения стандартов. |
| **SIGSEGV / SIGABRT / SIGFPE / SIGBUS** | Сигналы ОС, указывающие на критическую ошибку в приложении: выход за границы памяти, деление на ноль, некорректное освобождение памяти. |
| **Directed Fuzzing** | Подход к фаззингу, при котором инструментарий направлен на достижение заранее заданной функции или участка кода (targeted path). Используется при regression-testing и в доказательном фаззинге. |
| **Grammar-based Fuzzing** | Фаззинг с генерацией входов на основе формального описания структуры данных (грамматики, схемы, DTD, protobuf). Даёт более корректные входы и глубже тестирует парсеры. |
| **Mutational Fuzzing** | Метод, при котором входные данные изменяются случайным или систематическим образом: побитово, на уровне структур, по шаблонам. Применим, когда есть валидный seed corpus. |
| **Generative Fuzzing** | Метод фаззинга, в котором данные создаются "с нуля" без мутаций, на основе описания структуры. Особенно полезен, если corpus отсутствует или его невозможно получить. |
| **Fuzzer** | Инструмент, осуществляющий фаззинг: генерацию данных, подачу их в систему, мониторинг поведения. Примеры: AFL++, libFuzzer, honggfuzz, Peach, Boofuzz. |
| **Sanitizer** | Класс инструментов, вставляющих проверки в код для обнаружения ошибок исполнения: ASAN, MSAN, TSan, UBSAN, LeakSanitizer. |
| **Fuzz Target** | Целевая функция или компонент, на который направлен фаззинг. Может быть парсер, протокол, API-метод, конвертер, декодер и т.д. |
| **Symbolic Execution** | Метод тестирования, при котором возможные пути выполнения вычисляются на основе символьных (абстрактных) значений переменных. Используется в гибридном фаззинге. |
| **Taint Analysis** | Метод отслеживания движения внешних данных по коду. Позволяет определить, как пользовательский ввод влияет на поведение системы. |
| **Heap Overflow / Stack Overflow** | Типы ошибок при выходе за пределы допустимой области памяти: heap — в динамической памяти, stack — в стеке вызовов. Могут привести к выполнению произвольного кода. |
| **Use-After-Free (UAF)** | Ошибка, при которой программа обращается к области памяти после её освобождения. Классическая уязвимость, ведущая к крашам и RCE. |
| **Race Condition** | Ошибка, возникающая при параллельном доступе к разделяемым данным без синхронизации. Может привести к порче данных, утечке, эскалации прав. |
| **Timeout** | Состояние, при котором входные данные вызывают "зависание" логики. Могут указывать на DoS, бесконечный цикл или тяжёлую обработку. |

---

## 11. Типичные ошибки при анализе поверхности атаки

Анализ поверхности атаки — высокоуровневая, но технически насыщенная процедура. Ниже приведены типичные ошибки, которые совершаются при её выполнении, с пояснением последствий и рекомендациями по устранению.

---

### 11.1 Ошибки сбора исходных данных

| Ошибка | Последствия | Техническое объяснение / пример |
|--------|-------------|----------------------------------|
| **Игнорирование нестандартных интерфейсов** (например, D-Bus, shared memory, sysfs, UART) | Пропуск реальных каналов воздействия | Например, `/dev/shm/unsafe_buffer` может обрабатываться daemon'ом без фильтрации. |
| **Отсутствие анализа CLI-параметров и аргументов запуска** | Незамеченные векторы командной инъекции или path traversal | Программа может принимать путь к файлу, который может быть `../../etc/passwd`. |
| **Неполная инвентаризация API** | Недостаточное покрытие фаззингом, пропущенные методы | Swagger-файл содержит `POST /delete_user`, который скрыт от UI, но доступен. |
| **Пренебрежение внешними конфигурациями и переменными окружения** | Поверхность атаки может расширяться динамически | Пример: `DEBUG_MODE=1` активирует дополнительные endpoint'ы. |

---

### 11.2 Ошибки при построении модели данных

| Ошибка | Последствия | Техническое объяснение |
|--------|-------------|------------------------|
| **Упрощённое описание формата данных (JSON, XML, protobuf)** | Фаззер не может корректно строить вложенные структуры → низкое покрытие | Пример: JSON должен включать `items[]`, `meta.info`, `details[].extra`, но схема описывает только `items`. |
| **Игнорирование переходов состояний (stateful fuzzing)** | Фаззер не достигает защищённых/глубоких состояний | REST API требует: 1) login → 2) issue_token → 3) POST /action. Если фаззинг "слепой", эти шаги не моделируются. |
| **Ориентация только на краши (crash-based fuzzing)** | Уязвимости логики и авторизации остаются вне зоны охвата | Пример: IDOR (`GET /user/100`) не приводит к крашу, но позволяет читать чужие данные. |

---

### 11.3 Ошибки при выполнении анализа

| Ошибка | Последствия | Техническое пояснение |
|--------|-------------|------------------------|
| **Использование неподходящих фаззеров** | Фаззер не охватывает нужный протокол/формат → тестирование неэффективно | Пример: использование `Radamsa` для protobuf-структур вместо генеративного фаззера. |
| **Игнорирование coverage feedback** | Низкая эффективность фаззинга, повторение одних и тех же путей | Без обратной связи (`-fsanitize-coverage`) AFL++ не отличит новые ветки от старых. |
| **Неучёт условий исполнения** (архитектура, переменные окружения, права) | Поведение программы отличается от ожидаемого → ложные результаты | Пример: сборка в режиме `release` без отладочной информации не выдаёт корректный stacktrace. |
| **Запуск без изоляции и контроля ресурсов** | Возможны необратимые действия в системе, нестабильность фаззинга | Без `chroot`, `Firejail`, `Docker` fuzz target может удалить/повредить файлы или зависнуть на сутки. |

---

### 11.4 Ошибки оформления результатов

| Ошибка | Последствия | Техническое объяснение |
|--------|-------------|------------------------|
| **Отсутствие трассировки входа → ошибка → краш** | Невозможно воспроизвести и устранить проблему | Пример: найден краш, но нет входных данных, нет функции, нет coverage — разработчик не может понять, что произошло. |
| **Несвязные документы без карты фаззинга** | Невозможно доказать полноту охвата | Регулятор не примет отчёт, если не представлены все точки входа, инструменты и методы. |
| **Неформализованный список интерфейсов** | В отчёте присутствует "общая болтовня", не связанная с реальной архитектурой | Недопустимы формулировки: "есть API", "обрабатывает файлы". Должно быть: `/api/upload`, формат: multipart, метод: POST, функция: `handle_upload()` и т.д. |

---

## 12. Советы практика

Этот раздел включает конкретные рекомендации, полученные в процессе реального анализа ПО, подготовки к фаззинг-тестированию и сопровождения сертификаций. Каждое предложение — это способ избежать типичных ошибок, повысить полноту охвата и улучшить взаимодействие между командами.

---

### 12.1 Организационные и процессные советы

| Совет | Пояснение |
|-------|-----------|
| **Начинайте с составления карты входов, а не с запуска фаззера** | Даже самый мощный фаззер не поможет, если вы не знаете, какие интерфейсы нужно тестировать. Сначала — инвентаризация. |
| **Фиксируйте границы доверия явно, в виде схем и таблиц** | Модель trust boundaries позволяет целенаправленно выявлять векторы атак и точно объяснить тестовое покрытие. |
| **Используйте один формат описания входа: Interface → Format → Function → Execution → Risk** | Это облегчает передачу результатов между тестировщиком, разработчиком и безопасником. Пример: `API /upload`, формат `multipart`, функция `upload_handler()`, вход в sandbox, риск: bypass auth. |
| **Раз в 2–3 месяца пересматривайте карту фаззинга** | Система меняется. Новые версии, патчи, модули — значит, и поверхность атаки изменилась. |
| **Сопоставляйте найденные уязвимости с моделью угроз** | Это помогает объяснить значимость багов и уточнить приоритеты. Появился новый краш → какой STRIDE-класс он затрагивает? Какой компонент? |

---

### 12.2 Технические приёмы

| Приём | Пояснение |
|-------|-----------|
| **Добавьте кастомные логгеры в код до запуска фаззинга** | Даже простое логгирование параметров функций (имя, тип, размер, номер вызова) в `/tmp/fuzz.log` поможет быстро понять, на чём падает программа. |
| **Отключите оптимизации компиляции на время анализа** | Используйте `-O0 -g` + ASAN + coverage flags. Оптимизации могут "спрятать" важные участки или затруднить отладку краша. |
| **Добавьте "force-crash" при выявлении недопустимого состояния** | Вместо return error используйте `abort()`. Это ускорит обучение фаззера. |
| **Убедитесь, что все краши воспроизводимы вручную** | Добавляйте к crash report: путь до фаззера, входной файл, переменные окружения, параметры запуска. |
| **Трассируйте даже успешные кейсы** | Анализ некрашевых путей позволяет увидеть, как далеко продвигаются входные данные. Используйте `trace.log`, даже если всё "работает". |

---

### 12.3 Взаимодействие с другими командами

| Совет | Пояснение |
|-------|-----------|
| **Согласовывайте приоритеты тестирования с владельцем продукта / архитектором** | Некоторые точки входа могут быть логически закрыты (например, только при отладке). Уточняйте у команды, стоит ли их фаззить. |
| **Передавайте карту фаззинга в QA и DevSecOps** | Эта информация может быть интегрирована в тест-кейсы, CI/CD пайплайны и систему управления инцидентами. |
| **Не используйте язык "на взлом" при составлении отчётов** | Говорите технически: "непроверенный вход", "доступ без авторизации", "отсутствие валидации". Это повышает доверие к отчёту. |
| **Включайте примеры трасс в отчёт (в приложении)** | Даже 1–2 строки логов, показывающие `parse_json() -> handle_input() -> crash`, помогут разработчику быстрее воспроизвести ошибку. |
| **Оставляйте технические теги и аннотации в исходниках (по согласованию)** | Например: `// FUZZ_ENTRY`, `// USER_INPUT`, `// UNTRUSTED_SOURCE`. Это упрощает дальнейший аудит и фаззинг в новых версиях. |

---

## 13. Проверка понимания

Этот раздел предназначен для:
- самопроверки уровня усвоения материала;
- верификации качества анализа;
- интервьюирования команды по фаззинг-проекту;
- оценки готовности отчётности к внешнему аудиту (например, ФСТЭК или заказчик).

---

### 13.1 Контрольные вопросы

1. **Что такое поверхность атаки и чем она отличается от модели угроз?**
2. **Какие источники данных используются для определения точек входа?**
3. **Что такое trust boundary и как её определить на практике?**
4. **Перечислите все возможные интерфейсы ввода данных, которые стоит учитывать при анализе.**
5. **Как отличить мутационный фаззинг от генеративного?**
6. **Какие форматы данных требуют обязательной схемы или грамматики для эффективного фаззинга?**
7. **Как влияет структура входных данных (например, вложенность, цикличность) на стратегию фаззинга?**
8. **Почему важно использовать coverage-инструменты при фаззинге?**
9. **Как документировать связь: "вход → функция → поведение → результат"?**
10. **Какие методы анализа позволяют обнаружить недокументированные точки входа?**
11. **Почему недостаточно просто искать краши в процессе фаззинга?**
12. **В каких случаях Directed fuzzing более оправдан, чем Blind fuzzing?**
13. **Какие требования ФСТЭК напрямую связаны с анализом поверхности атаки?**
14. **Что должна содержать карта фаззинга, чтобы считаться полной?**
15. **Как отличить "неприоритетный" вход от "высокорискового"?**
16. **Какие документы нужно подготовить в рамках анализа ПА перед сертификацией?**
17. **Почему важно сохранять трассы и входы всех успешных кейсов фаззинга?**
18. **Можно ли анализировать ПА без исходного кода? Если да, то как?**
19. **Какие инструменты фаззинга применимы к сетевым интерфейсам?**
20. **Какие признаки указывают на ошибку при построении карты фаззинга?**

---

### 13.2 Чек-лист готовности анализа ПА

| Утверждение | Выполнено? |
|-------------|------------|
| Все интерфейсы ввода данных описаны и категоризированы | ✅ / ❌ |
| Для каждого интерфейса указан формат, способ передачи, обрабатывающая функция | ✅ / ❌ |
| Установлены все trust boundaries | ✅ / ❌ |
| Выделены критичные точки входа (по DREAD/STRIDE) | ✅ / ❌ |
| Построена карта фаззинга в табличной или графовой форме | ✅ / ❌ |
| Указаны используемые инструменты, способы запуска, методы обратной связи | ✅ / ❌ |
| Результаты фаззинга задокументированы с входами, трассами и stacktrace | ✅ / ❌ |
| Оценено покрытие кода (edge, block, function-level) | ✅ / ❌ |
| Подготовлен формализованный отчёт, пригодный для сертификации | ✅ / ❌ |
| Проведена повторная проверка слепых зон и недостижимых путей | ✅ / ❌ |
| Команда ознакомлена с моделью ПА и использует её в планировании QA и DevSecOps | ✅ / ❌ |

---

**Если большинство пунктов ✅ — анализ поверхности атаки считается завершённым технически обоснованно и пригоден к использованию в фаззинг-кампании или сертификации.**
