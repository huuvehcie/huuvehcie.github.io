# Руководство по использованию API через Bash

## Содержание

1.  [Введение](#введение)
2.  [Используемые термины и определения](#термины-и-определения)
3.  [REST API](#rest-api)
    * [Работа с REST API с использованием `curl` и `jq`](#работа-с-rest-api-с-использованием-curl-и-jq)
4.  [SOAP API](#soap-api)
    * [Работа с SOAP API с использованием `curl` и `xmlstarlet`](#работа-с-soap-api-с-использованием-curl-и-xmlstarlet)
5.  [GraphQL API](#graphql-api)
    * [Работа с GraphQL API с использованием `curl` и `jq`](#работа-с-graphql-api-с-использованием-curl-и-jq)
6.  [gRPC API](#grpc-api)
    * [Работа с gRPC API с использованием `grpcurl`](#работа-с-grpc-api-с-использованием-grpcurl)
7.  [Общий справочник команд и конфигураций](#общий-справочник-команд-и-конфигураций)

## Введение

Это руководство предназначено для начинающих специалистов, желающих научиться взаимодействовать с различными типами API (REST, SOAP, GraphQL, gRPC) без написания кода на языках программирования. Вместо этого мы будем использовать готовые шаблоны команд для утилиты `bash`, что позволяет быстро подставлять необходимые значения и получать результаты в легко читаемом человеком формате. Основное внимание уделено практическому применению команд и инструментов командной строки, таких как `curl`, `jq`, `xmlstarlet` и `grpcurl`. Руководство структурировано таким образом, чтобы предоставить максимально сжатую, но детализированную информацию, с акцентом на таблицы для представления ключевых аспектов.

Каждый раздел, посвященный определенному типу API, начинается с пояснительного текста. Этот текст вводит в контекст рассматриваемого типа API, объясняет его основные принципы, типичные сценарии использования и почему взаимодействие с ним через командную строку может быть полезным. Далее следует подробная таблица, которая является ядром раздела. Таблица содержит команды, их назначение, параметры, рабочие примеры, разбор типичных ошибок и их решения, а также информацию о влиянии команд на систему и их взаимодействии с другими компонентами. Примеры в таблицах снабжены комментариями для лучшего понимания. Цель такого подхода — дать пользователю не только "что" и "как" делать, но и "зачем" и "какие могут быть последствия". Это позволяет сформировать более глубокое понимание процессов взаимодействия с API и подготовиться к решению реальных задач.

## Термины и определения

| Термин/Аббревиатура | Объяснение                                                                                                                                                                                                                                                                                          |
| :------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| API                 | **Application Programming Interface (Интерфейс Программирования Приложений)**. Набор правил, протоколов и инструментов для построения программного обеспечения и приложений. API позволяет различным программам взаимодействовать друг с другом без необходимости знать детали их внутренней реализации. Представьте это как меню в ресторане: вы выбираете блюдо (функцию), и кухня (сервер) готовит его для вас, не раскрывая рецепт. |
| REST (RESTful) API  | **Representational State Transfer (Передача состояния представления)**. Архитектурный стиль для создания веб-сервисов. REST API используют стандартные HTTP-методы (GET, POST, PUT, DELETE и др.) для выполнения операций над ресурсами, идентифицируемыми через URL. Данные обычно передаются в форматах JSON или XML. REST ценится за простоту, масштабируемость и гибкость. |
| SOAP API            | **Simple Object Access Protocol (Простой протокол доступа к объектам)**. Протокол для обмена структурированными сообщениями в веб-сервисах, обычно использующий XML для формата сообщений и HTTP(S) в качестве транспортного протокола. SOAP более строгий и стандартизированный, чем REST, часто используется в корпоративных системах, требующих высокой надежности и безопасности. Он определяет собственный стандарт безопасности (WS-Security) и транзакций. |
| GraphQL API         | **Graph Query Language (Язык запросов графов)**. Язык запросов для API и среда выполнения на стороне сервера для обработки этих запросов. GraphQL позволяет клиентам запрашивать только те данные, которые им нужны, и ничего более. Это решает проблемы избыточной (over-fetching) или недостаточной (under-fetching) выборки данных, характерные для REST. Клиент определяет структуру ответа. |
| gRPC                | **Google Remote Procedure Call (Удаленный вызов процедур Google)**. Высокопроизводительная, опенсорсная универсальная RPC-система. gRPC использует Protocol Buffers (Protobuf) в качестве языка описания интерфейсов и формата сериализации сообщений, а также HTTP/2 для транспортировки. Это обеспечивает эффективность, низкие задержки и поддержку потоковой передачи данных. |
| HTTP                | **HyperText Transfer Protocol (Протокол передачи гипертекста)**. Основа передачи данных в World Wide Web. Определяет, как сообщения форматируются и передаются, и какие действия должны предпринимать веб-серверы и браузеры в ответ на различные команды.                                                                                                     |
| HTTPS               | **HyperText Transfer Protocol Secure (Безопасный протокол передачи гипертекста)**. Расширение HTTP, поддерживающее шифрование с помощью криптографических протоколов SSL/TLS. Обеспечивает безопасное соединение между клиентом и сервером.                                                                                                  |
| URL                 | **Uniform Resource Locator (Унифицированный указатель ресурса)**. Строка символов, указывающая местонахождение ресурса в интернете. Например, `https://api.example.com/users`.                                                                                                                            |
| URI                 | **Uniform Resource Identifier (Унифицированный идентификатор ресурса)**. Строка символов, идентифицирующая ресурс. URL является частным случаем URI.                                                                                                                                                         |
| Endpoint (Конечная точка) | Конкретный URL в API, по которому можно получить доступ к определенному ресурсу или выполнить операцию. Например, `/users` или `/products/123`.                                                                                                                                                           |
| HTTP-методы         | Команды, используемые в HTTP для указания желаемого действия для указанного ресурса. Основные методы: `GET` (получение), `POST` (создание), `PUT` (обновление/замена), `DELETE` (удаление), `PATCH` (частичное обновление), `OPTIONS` (получение информации о возможностях).                               |
| Заголовки (Headers) | Часть HTTP-запроса или ответа, содержащая метаданные. Например, `Content-Type` (тип содержимого), `Authorization` (данные для аутентификации).                                                                                                                                                               |
| Тело запроса/ответа (Body) | Часть HTTP-запроса или ответа, содержащая передаваемые данные. Например, JSON-объект с информацией о новом пользователе при POST-запросе.                                                                                                                                                                  |
| JSON                | **JavaScript Object Notation**. Легковесный текстовый формат обмена данными, легко читаемый человеком и легко обрабатываемый машинами. Широко используется в REST API. Пример: `{"name": "Иван", "age": 30}`.                                                                                                 |
| XML                 | **Extensible Markup Language (Расширяемый язык разметки)**. Текстовый формат, предназначенный для хранения и передачи структурированных данных. Используется в SOAP API и иногда в REST API. Более многословен, чем JSON. Пример: `<user><name>Иван</name><age>30</age></user>`.                             |
| CRUD                | Акроним для четырех основных функций постоянного хранения: **Create (Создание), Read (Чтение), Update (Обновление), Delete (Удаление)**. Эти операции часто сопоставляются с HTTP-методами: POST (Create), GET (Read), PUT/PATCH (Update), DELETE (Delete).                                                    |
| `curl`              | **Client URL (Клиент URL)**. Мощная утилита командной строки для передачи данных с использованием различных сетевых протоколов, включая HTTP, HTTPS, FTP и др. Основной инструмент для взаимодействия с REST и SOAP API из командной строки.                                                                  |
| `jq`                | Утилита командной строки для обработки JSON-данных. Позволяет фильтровать, извлекать и преобразовывать JSON-структуры. Очень полезна для форматирования и анализа ответов от API.                                                                                                                             |
| `xmlstarlet`        | Утилита командной строки для работы с XML-документами. Позволяет выполнять запросы XPath, проверять, преобразовывать и редактировать XML. Аналог `jq` для XML.                                                                                                                                                 |
| `grpcurl`           | Утилита командной строки для взаимодействия с gRPC-сервисами. Позволяет вызывать RPC-методы, просматривать схемы сервисов и метаданные. Аналог `curl` для gRPC.                                                                                                                                                 |
| WSDL                | **Web Services Description Language (Язык описания веб-сервисов)**. XML-формат для описания сетевых сервисов. WSDL-документ определяет местоположение сервиса, доступные операции (методы) и формат сообщений. Используется в SOAP.                                                                                |
| Protobuf (Protocol Buffers) | Механизм сериализации структурированных данных, разработанный Google. Языково- и платформенно-нейтральный, расширяемый. Используется в gRPC для определения сервисов и структуры сообщений. Файлы с расширением `.proto` описывают эти структуры.                                                             |
| Аутентификация (Authentication) | Процесс проверки личности пользователя или системы, пытающейся получить доступ к API. Примеры: Basic Auth, API-ключи, OAuth 2.0, Bearer Token.                                                                                                                                                             |
| Авторизация (Authorization) | Процесс определения того, какие ресурсы и операции доступны аутентифицированному пользователю или системе.                                                                                                                                                                                             |
| Статус-код HTTP     | Трехзначное число, возвращаемое сервером в ответ на HTTP-запрос. Указывает на результат обработки запроса. Например, `200 OK` (успешно), `404 Not Found` (не найдено), `500 Internal Server Error` (внутренняя ошибка сервера).                                                                                 |
| Идемпотентность     | Свойство операции, означающее, что многократное её выполнение дает тот же результат, что и однократное. В контексте API, методы `GET`, `PUT`, `DELETE` обычно идемпотентны, а `POST` — нет.                                                                                                                  |
| `bash`              | **Bourne Again SHell**. Популярная командная оболочка в Unix-подобных системах. Скрипты на `bash` позволяют автоматизировать последовательности команд.                                                                                                                                                            |
| Пайп (`\|`)         | **Конвейер (Pipe)**. В командной строке `bash` символ `|` используется для перенаправления стандартного вывода одной команды на стандартный ввод другой. Например, `curl ... | jq .` передает вывод `curl` на обработку `jq`.                                                                                  |
| "Заслать запрос"    | Жаргонное выражение, означающее "отправить запрос" к API.                                                                                                                                                                                                                                                         |
| "Ручка" / "Хэндлер" | Жаргонное название endpoint'а или конкретного обработчика запроса на сервере.                                                                                                                                                                                                                                  |
| "Протухший токен"   | Жаргонное выражение, означающее, что срок действия токена аутентификации (например, JWT или OAuth-токена) истек, и он больше недействителен для доступа к API.                                                                                                                                                  |

## REST API

REST (Representational State Transfer) API являются наиболее распространенным типом API в вебе на сегодняшний день. Они основаны на архитектурном стиле, который использует стандартные HTTP-методы (GET, POST, PUT, DELETE и т.д.) для взаимодействия с ресурсами, представленными через URL. Данные обычно передаются в формате JSON, хотя XML и другие форматы также могут использоваться. Простота, гибкость и отсутствие жестких требований к состоянию между запросами делают REST API популярным выбором для широкого спектра приложений, от простых веб-сервисов до сложных микросервисных архитектур.

Взаимодействие с REST API из командной строки, в частности с помощью утилиты `curl`, является фундаментальным навыком для разработчиков, тестировщиков и системных администраторов. Это позволяет быстро проверять доступность и корректность работы API, отлаживать запросы, автоматизировать рутинные задачи и интегрировать API в скрипты без необходимости написания полноценных приложений. Следующая таблица подробно описывает использование `curl` для работы с REST API, включая различные параметры, примеры запросов, способы обработки ответов с помощью `jq` для лучшей читаемости, а также разбор типичных ошибок и их решений. Эта таблица служит практическим руководством для отправки запросов, управления заголовками, аутентификации и обработки данных, что поможет вам эффективно взаимодействовать с любым RESTful сервисом.

### Работа с REST API с использованием `curl` и `jq`

| Команда/Инструмент                  | Назначение                                                                                                | Параметры (основные)                                                                                                                                                                                                                                                                                                                                                      | Примеры (с комментариями)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Ошибки и Решения                                                                                                                                                                                                                           | Влияние                                                                                                                                                                      | Взаимодействие                                                                                                                                                                 |
| :---------------------------------- | :-------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `curl [URL]`                        | Отправка простого GET-запроса на указанный URL.                                                           | `-s`: Тихий режим (не показывать прогресс/ошибки).<br>`-S`: Показывать ошибки, если `-s` используется.<br>`-i`: Включить HTTP-заголовки ответа в вывод.<br>`-L`: Следовать редиректам.                                                                                                                                                                                      | ```bash\n# Получить главную страницу google.com\ncurl [https://www.google.com](https://www.google.com)\n\n# Получить список пользователей (JSON)\ncurl [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)\n\n# Получить данные с редиректом и показать заголовки\ncurl -iL [http://httpbin.org/redirect/1](http://httpbin.org/redirect/1)\n```                                                                                                                                                                                                                                                                                        | **Ошибка:** `curl: (6) Could not resolve host: nonexistant.url`<br>**Решение:** Проверьте правильность URL и ваше DNS-соединение.<br>**Ошибка:** `Timeout was reached`<br>**Решение:** Проверьте сетевое соединение, возможно, сервер перегружен или недоступен. Увеличьте таймаут с помощью `--connect-timeout` или `-m`. | Генерирует сетевой GET-запрос. Минимальная нагрузка на клиент. Может вызвать нагрузку на сервер в зависимости от запрашиваемого ресурса.                                      | С DNS для разрешения имени хоста. С сетевым стеком ОС для TCP/IP соединения. С удаленным HTTP-сервером.                                                                      |
| `curl -X [METHOD] [URL]`            | Отправка запроса с указанным HTTP-методом (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD).                  | `-X POST`: Отправить POST-запрос.<br>`-X PUT`: Отправить PUT-запрос.<br>`-X DELETE`: Отправить DELETE-запрос.                                                                                                                                                                                                                                                                 | ```bash\n# Получить доступные методы для ресурса\ncurl -X OPTIONS [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)\n\n# Удалить пост (фиктивно, т.к. jsonplaceholder не сохраняет изменения)\ncurl -X DELETE [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1)\n```                                                                                                                                                                                                                                                                                                              | **Ошибка:** `405 Method Not Allowed`<br>**Решение:** Сервер не поддерживает указанный HTTP-метод для данного ресурса. Проверьте документацию API.<br>**Ошибка:** Сервер не отвечает или возвращает ошибку при `DELETE` на ресурс, который нельзя удалить.<br>**Решение:** Убедитесь, что операция разрешена и ресурс существует. | В зависимости от метода: `GET` обычно безопасен. `POST`, `PUT`, `DELETE`, `PATCH` могут изменять данные на сервере.                                                             | Взаимодействует с логикой сервера, обрабатывающей различные HTTP-методы. Может требовать прав доступа.                                                                    |
| `curl -H "Header: Value" [URL]`     | Добавление кастомных HTTP-заголовков в запрос.                                                            | `-H "Content-Type: application/json"`: Указать тип передаваемого контента.<br>`-H "Authorization: Bearer <token>"`: Добавить токен авторизации.                                                                                                                                                                                                                             | ```bash\n# Отправить GET-запрос с кастомным заголовком User-Agent\ncurl -H "User-Agent: MyAwesomeClient/1.0" [https://httpbin.org/user-agent](https://httpbin.org/user-agent)\n\n# Отправить GET-запрос с API-ключом в заголовке\ncurl -H "X-API-Key: your_api_key_here" [https://api.example.com/data](https://api.example.com/data)\n```                                                                                                                                                                                                                                                                                             | **Ошибка:** `401 Unauthorized` / `403 Forbidden`<br>**Решение:** Неверный или отсутствующий токен авторизации, или неверный API-ключ. Проверьте правильность заголовка `Authorization` или соответствующего заголовка API-ключа.<br>**Ошибка:** `415 Unsupported Media Type`<br>**Решение:** Заголовок `Content-Type` не указан или указан неверно для отправляемых данных (актуально для POST/PUT). | Заголовки влияют на то, как сервер обрабатывает запрос (например, тип контента, аутентификация, кеширование).                                                                  | Взаимодействует с механизмами аутентификации, авторизации, управления контентом и кеширования на сервере.                                                                    |
| `curl -d "data" [URL]`              | Отправка данных в теле POST-запроса (по умолчанию `application/x-www-form-urlencoded`).                   | `-d '{"key":"value"}'`: Отправить JSON-строку.<br>`-d "@filename.json"`: Отправить данные из файла.<br>`--data-urlencode "param=value with spaces"`: URL-кодировать данные.                                                                                                                                                                                          | ```bash\n# Отправить данные формы\ncurl -d "name=John Doe&email=john@example.com" [https://httpbin.org/post](https://httpbin.org/post)\n\n# Отправить JSON данные (важно также указать Content-Type)\ncurl -X POST -H "Content-Type: application/json" -d '{"title": "foo", "body": "bar", "userId": 1}' [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)\n\n# Отправить данные из файла user_data.json\n# echo '{"name":"Jane"}' > user_data.json \ncurl -X POST -H "Content-Type: application/json" -d @user_data.json [https://httpbin.org/post](https://httpbin.org/post)\n``` | **Ошибка:** `400 Bad Request`<br>**Решение:** Некорректный формат данных или отсутствуют обязательные поля. Проверьте структуру данных и заголовок `Content-Type`.<br>**Ошибка:** Сервер не может обработать данные (например, JSON невалиден).<br>**Решение:** Убедитесь, что JSON синтаксически корректен. Используйте валидатор JSON. | Создает или изменяет ресурс на сервере. Может вызвать значительную нагрузку на сервер при обработке данных.                                                                    | Взаимодействует с логикой создания/обновления ресурсов на сервере. Требует правильного `Content-Type`.                                                                    |
| `curl -u "user:password" [URL]`     | Использование Basic HTTP Authentication.                                                                    |                                                                                                                                                                                                                                                                                                                                                                                       | ```bash\n# Доступ к защищенному ресурсу с Basic Auth\ncurl -u "testuser:testpassword" [https://httpbin.org/basic-auth/testuser/testpassword](https://httpbin.org/basic-auth/testuser/testpassword)\n```                                                                                                                                                                                                                                                                                                                                                                                                                | **Ошибка:** `401 Unauthorized`<br>**Решение:** Неверные имя пользователя или пароль.<br>**Опасно:** Передача учетных данных в командной строке может быть небезопасной (сохраняется в истории).<br>**Решение:** Используйте `.netrc` файл или переменные окружения для безопасного хранения. | Позволяет пройти аутентификацию на сервере.                                                                                                                                     | Взаимодействует с модулем аутентификации сервера.                                                                                                                                |
| `curl ... \| jq '.'`                 | Форматирование и обработка JSON-ответа с помощью `jq`.                                                    | `jq '.fieldName'`: Извлечь значение поля.<br>`jq '.[0]'`: Извлечь первый элемент массива.<br>`jq '.[] | select(.userId == 1)'`: Отфильтровать массив объектов.                                                                                                                                                                                                                            | ```bash\n# Получить список постов и красиво вывести в консоль\ncurl -s [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts) | jq '.'\n\n# Получить только заголовки постов\ncurl -s [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts) | jq '.[].title'\n\n# Получить посты пользователя с ID 1\ncurl -s [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts) | jq '.[] | select(.userId == 1)'\n```                                                                                                                                                                  | **Ошибка:** `jq: error: Could not open file /path/to/nonexistent.json: No such file or directory` (если `jq` пытается открыть файл вместо stdin).<br>**Решение:** Убедитесь, что вывод `curl` корректно передается `jq` через пайп (`|`).<br>**Ошибка:** `jq: parse error: Invalid numeric literal...`<br>**Решение:** Ответ от API не является валидным JSON, или `curl` вернул ошибку (например, HTML страницу ошибки) вместо JSON. Проверьте вывод `curl` без `jq`. | `jq` работает локально, обрабатывая полученные данные. Не влияет на сервер.                                                                                                    | `jq` получает данные от `curl` через стандартный ввод. Требует, чтобы `curl` выводил JSON.                                                                                   |
| `curl -o filename [URL]`            | Сохранение вывода (тела ответа) в файл.                                                                   | `-O` (заглавная O): Сохранить файл с именем, взятым из URL.                                                                                                                                                                                                                                                                                                                    | ```bash\n# Скачать изображение и сохранить как image.jpg\ncurl -o image.jpg [https://via.placeholder.com/150](https://via.placeholder.com/150)\n\n# Скачать файл, используя имя из URL\ncurl -O [https://jsonplaceholder.typicode.com/todos/1](https://jsonplaceholder.typicode.com/todos/1)\n# (сохранит как файл '1')\n```                                                                                                                                                                                                                                                                                                                      | **Ошибка:** `curl: (23) Failed writing body...`<br>**Решение:** Проблемы с правами на запись в директорию или нехватка места на диске.<br>**Ошибка:** Файл сохраняется с неожиданным именем или содержимым.<br>**Решение:** Убедитесь, что URL корректен и что `-o` указан перед URL. Для `-O` проверьте, что URL содержит имя файла. | Сохраняет данные на локальный диск. Может занимать место на диске.                                                                                                               | Взаимодействует с файловой системой ОС.                                                                                                                                          |
| `curl -F "name=@filepath" [URL]`    | Отправка данных формы с файлом (multipart/form-data).                                                     | `-F "key=value"`: Добавить обычное поле формы.                                                                                                                                                                                                                                                                                                                                | ```bash\n# Создать пустой файл для примера\n# touch dummy.txt\n\n# Отправить файл dummy.txt на httpbin.org\ncurl -F "filefield=@dummy.txt" -F "name=testfile" [https://httpbin.org/post](https://httpbin.org/post)\n```                                                                                                                                                                                                                                                                                                                                                                | **Ошибка:** `curl: (26) couldn't open file "nonexistent.txt"`<br>**Решение:** Убедитесь, что файл существует по указанному пути и есть права на его чтение.<br>**Ошибка:** Сервер не может обработать файл (например, не тот тип файла, превышен размер).<br>**Решение:** Проверьте требования API к файлам. | Отправляет локальный файл на сервер. Может потреблять значительный сетевой трафик для больших файлов.                                                                            | Взаимодействует с логикой загрузки файлов на сервере.                                                                                                                            |
| **Важно запомнить** | \- `Content-Type` важен для `POST`/`PUT`. Для JSON это `application/json`.<br>\- `jq` — ваш лучший друг для работы с JSON.<br>\- Всегда проверяйте статус-коды HTTP ответа (`-i` или `-v`).<br>\- Для отладки используйте `-v` (verbose) для подробного вывода. |                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                            |                                                                                                                                                                              |                                                                                                                                                                                |
| **Типичные ошибки (общие)** | \- **401 Unauthorized / 403 Forbidden**: Проблемы с аутентификацией/авторизацией. Проверьте токены, API-ключи, логин/пароль.<br>\- **404 Not Found**: Неправильный URL или ресурс не существует.<br>\- **5xx Server Error**: Проблема на стороне сервера. Попробуйте позже или свяжитесь с поддержкой API. |                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                            |                                                                                                                                                                              |                                                                                                                                                                                |
| **Продвинутые сценарии** | **Автоматизация**: `curl` команды легко встраиваются в bash-скрипты для регулярного сбора данных, мониторинга и т.д.<br>**Безопасность**: Используйте HTTPS. Для Basic Auth рассмотрите `.netrc` или передачу через переменные окружения, а не открытым текстом. Опция `-k` или `--insecure` отключает проверку SSL-сертификата (использовать с осторожностью!). | `-k`: Разрешить небезопасные SSL-соединения.<br>`--netrc-file <file>`: Указать файл `.netrc`.                                                                                                                                                                                                                                     | ```bash\n# Использование .netrc для Basic Auth (файл ~/.netrc должен содержать: machine httpbin.org login testuser password testpassword)\n# chmod 600 ~/.netrc \ncurl --netrc [https://httpbin.org/basic-auth/testuser/testpassword](https://httpbin.org/basic-auth/testuser/testpassword)\n\n# Отключить проверку SSL (не рекомендуется для продакшена!)\n# curl -k [https://self-signed.badssl.com/](https://self-signed.badssl.com/)\n``` | **Ошибка:** Перехват данных при использовании HTTP или `-k`.<br>**Решение:** Всегда используйте HTTPS. Не используйте `-k` без понимания рисков. <br>**Ошибка:** Скрипт не работает из-за изменений в API.<br>**Решение:** Регулярно проверяйте документацию API и обновляйте скрипты. | `-k` снижает безопасность. Использование скриптов повышает эффективность, но требует поддержки.                                                                            | Взаимодействует с файловой системой для `.netrc`. При использовании `-k` изменяется процесс проверки SSL/TLS сертификатов.                                                   |

## SOAP API

SOAP (Simple Object Access Protocol) API представляют собой более формализованный и стандартизированный подход к веб-сервисам по сравнению с REST. Они используют XML для форматирования сообщений и обычно работают поверх HTTP/HTTPS, хотя могут использовать и другие транспортные протоколы. Ключевой особенностью SOAP является использование WSDL (Web Services Description Language) для описания сервиса, его операций, типов данных и способа их передачи. Это обеспечивает строгую контрактацию между клиентом и сервером. SOAP API часто применяются в корпоративных средах, где важны транзакционность, безопасность (например, через WS-Security) и надежность.

Взаимодействие с SOAP API из командной строки с помощью `curl` требует формирования корректного XML-запроса (SOAP Envelope) и отправки его на endpoint сервиса. Ответ также будет представлять собой XML-документ. Для работы с XML-данными, как на этапе подготовки запроса, так и при анализе ответа, полезны утилиты вроде `xmlstarlet` или `xmllint`. Следующая таблица демонстрирует, как конструировать и отправлять SOAP-запросы с помощью `curl`, устанавливать необходимые HTTP-заголовки (например, `SOAPAction`), обрабатывать XML-ответы и решать распространенные проблемы. Понимание этих процессов позволит вам взаимодействовать с SOAP-сервисами для тестирования, отладки или интеграции без необходимости в специализированных SOAP-клиентах или библиотеках программирования.

### Работа с SOAP API с использованием `curl` и `xmlstarlet`

| Команда/Инструмент                   | Назначение                                                                                                   | Параметры (основные для `curl`)                                                                                                                                                                                                                               | Примеры (с комментариями)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Ошибки и Решения                                                                                                                                                                                                                                                                                             | Влияние                                                                                                                                                                                                      | Взаимодействие                                                                                                                                                                     |
| :----------------------------------- | :----------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `curl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: <action_url>" -d @request.xml [ENDPOINT_URL]` | Отправка SOAP-запроса на сервер.                                                                               | `-H "Content-Type: text/xml;charset=UTF-8"` (или `application/soap+xml` для SOAP 1.2): Заголовок типа контента.<br>`-H "SOAPAction: <action_url>"`: Заголовок, указывающий намерение запроса (часто требуется для SOAP 1.1). Для SOAP 1.2 `SOAPAction` не используется, а тип контента `application/soap+xml` включает параметр `action`.<br>`-d @request.xml`: Отправка XML-тела запроса из файла `request.xml`.<br>`--data-binary @request.xml`: Рекомендуется для предотвращения удаления переводов строк `curl`-ом. | ```xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<soap:Envelope xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)" xmlns:xsd="[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)" xmlns:soap="[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)">\n  <soap:Body>\n    <Add xmlns="[http://tempuri.org/](http://tempuri.org/)">\n      <intA>10</intA>\n      <intB>5</intB>\n    </Add>\n  </soap:Body>\n</soap:Envelope>\n```\n\n```bash\n# Отправить SOAP запрос на сложение чисел\ncurl -X POST \\\n     -H "Content-Type: text/xml;charset=UTF-8" \\\n     -H "SOAPAction: \"[http://tempuri.org/Add](http://tempuri.org/Add)\"" \\\n     -d @request.xml \\\n     [http://www.dneonline.com/calculator.asmx](http://www.dneonline.com/calculator.asmx)\n``` | **Ошибка:** `500 Internal Server Error` (часто с SOAP Fault в XML-ответе).<br>**Решение:** Проверьте XML-запрос на валидность, правильность неймспейсов, соответствие WSDL. Проверьте значение `SOAPAction`.<br>**Ошибка:** `415 Unsupported Media Type`.<br>**Решение:** Неправильный `Content-Type`. Должен быть `text/xml` или `application/soap+xml`.                                                                                             | Отправляет XML-данные на сервер. Сервер выполняет операцию, описанную в SOAP-запросе. Может изменять данные на сервере в зависимости от операции.                                                                    | Взаимодействует с SOAP-обработчиком на сервере. Требует точного соответствия WSDL-контракту. Заголовок `SOAPAction` (для SOAP 1.1) критичен для маршрутизации запроса на сервере. |
| `xmlstarlet sel -t -v "//xpath/expression" response.xml` | Извлечение данных из XML-ответа с помощью XPath (используя `xmlstarlet`). `xmllint --xpath "//xpath/expression" response.xml` для `xmllint`. | `sel`: Команда выбора в `xmlstarlet`.<br>`-t -v "//xpath"`: Шаблон для вывода значения, найденного по XPath.<br>`--xpath`: Опция для `xmllint`.                                                                                                              | ```bash\n# Пример ответа от калькулятора (сохраним в response.xml):\n# <?xml version="1.0" encoding="utf-8"?>\n# <soap:Envelope xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)" xmlns:xsd="[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)" xmlns:soap="[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)">\n#   <soap:Body>\n#     <AddResponse xmlns="[http://tempuri.org/](http://tempuri.org/)">\n#       <AddResult>15</AddResult>\n#     </AddResponse>\n#   </soap:Body>\n# </soap:Envelope>\n\n# Сохраняем предыдущий вывод curl в файл response.xml\ncurl -X POST -H "Content-Type: text/xml;charset=UTF-8" -H "SOAPAction: \"[http://tempuri.org/Add](http://tempuri.org/Add)\"" -d @request.xml [http://www.dneonline.com/calculator.asmx](http://www.dneonline.com/calculator.asmx) -o response.xml\n\n# Извлечь результат сложения (AddResult) с указанием неймспейса\nxmlstarlet sel -N s="[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)" -N tns="[http://tempuri.org/](http://tempuri.org/)" -t -v "//s:Body/tns:AddResponse/tns:AddResult" response.xml\n# Ожидаемый вывод: 15\n\n# Аналог с xmllint (требует регистрации неймспейсов несколько иначе или их игнорирования через local-name())\n# xmllint --xpath "/*[local-name()='Envelope']/*[local-name()='Body']/*[local-name()='AddResponse']/*[local-name()='AddResult']/text()" response.xml\n``` | **Ошибка:** `xmlstarlet` или `xmllint` не находит данные (пустой вывод).<br>**Решение:** Неправильный XPath-запрос или неймспейсы не учтены. Используйте `xmlstarlet el response.xml` для просмотра структуры XML. Укажите неймспейсы с помощью `-N prefix=uri`. Для `xmllint` синтаксис XPath для неймспейсов может быть сложнее. <br>**Ошибка:** `Invalid XML` (или похожая ошибка парсинга).<br>**Решение:** Ответ сервера не является валидным XML. Проверьте ответ на ошибки сервера (например, HTML-страница вместо XML). | Локальная обработка XML-данных. Не влияет на сервер.                                                                                                                                                                  | Получает XML-данные от `curl` (обычно через файл или пайп). Требует корректного XML на входе.                                                                                    |
| `xmlstarlet fo response.xml`         | Форматирование XML-ответа для лучшей читаемости (`xmlstarlet`). `xmllint --format response.xml` для `xmllint`. | `fo`: Команда форматирования в `xmlstarlet`.<br>`--format`: Опция для `xmllint`.                                                                                                                                                                                | ```bash\n# Отправить SOAP запрос и отформатировать XML ответ\ncurl -s -X POST \\\n     -H "Content-Type: text/xml;charset=UTF-8" \\\n     -H "SOAPAction: \"[http://tempuri.org/Add](http://tempuri.org/Add)\"" \\\n     -d @request.xml \\\n     [http://www.dneonline.com/calculator.asmx](http://www.dneonline.com/calculator.asmx) \\\n     | xmlstarlet fo\n\n# Или с xmllint\n# curl -s ... | xmllint --format -\n```                                                                                                                                                                                                                                                                                                                                                                                                                                                             | **Ошибка:** Утилита не установлена.<br>**Решение:** Установите `xmlstarlet` (`sudo apt-get install xmlstarlet` или `brew install xmlstarlet`) или `xmllint` (часть `libxml2-utils`).<br>**Ошибка:** Некорректный XML на входе.<br>**Решение:** Убедитесь, что предыдущая команда вернула валидный XML. | Локальная обработка. Помогает в отладке, делая XML читаемым.                                                                                                                                    | Получает XML-данные от `curl` через пайп или из файла.                                                                                                                             |
| Получение WSDL                     | Получение WSDL-файла для изучения структуры сервиса.                                                            | Обычно просто GET-запрос к URL, заканчивающемуся на `?wsdl` или `?WSDL`.                                                                                                                                                                                      | ```bash\n# Получить WSDL для сервиса калькулятора\ncurl [http://www.dneonline.com/calculator.asmx?WSDL](http://www.dneonline.com/calculator.asmx?WSDL) -o calculator.wsdl\n\n# Просмотреть WSDL (он тоже XML)\nxmlstarlet fo calculator.wsdl\n```                                                                                                                                                                                                                                                                                                                                                                                                                                                             | **Ошибка:** `404 Not Found`.<br>**Решение:** URL для WSDL указан неверно или сервис не предоставляет WSDL по этому адресу.<br>**Ошибка:** WSDL нечитаем или сложен.<br>**Решение:** WSDL может быть большим. Используйте `xmlstarlet fo` для форматирования. Сосредоточьтесь на секциях `<portType>`, `<operation>`, `<message>`, `<types>`. | WSDL-файл описывает контракт сервиса. Его получение не влияет на состояние сервиса.                                                                                                    | Сервер предоставляет WSDL-файл по запросу. WSDL используется для понимания, как формировать корректные SOAP-запросы.                                                              |
| **Важно запомнить** | \- SOAP-запросы — это XML внутри XML (SOAP Envelope).<br>\- Пространства имен (namespaces) в XML критически важны.<br>\- `SOAPAction` (для SOAP 1.1) должен соответствовать операции в WSDL.<br>\- Для SOAP 1.2 используется `Content-Type: application/soap+xml; charset=utf-8; action="<action_url>"`. |                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                  |                                                                                                                                                                                  |
| **Типичные ошибки (общие)** | \- Неправильно сформированный SOAP Envelope (синтаксис XML, неймспейсы).<br>\- Ошибки в `SOAPAction` или его отсутствие.<br>\- Проблемы с аутентификацией (SOAP может использовать WS-Security, HTTP Basic Auth и др., что усложняет `curl` запросы без доп. обработки). |                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                  |                                                                                                                                                                                  |

## GraphQL API

GraphQL — это язык запросов для API и серверная среда выполнения для обработки этих запросов. В отличие от REST, где для получения различных данных часто требуется обращаться к нескольким endpoints, GraphQL позволяет клиентам запрашивать только те данные, которые им необходимы, и в той структуре, в которой они нужны, всё это через один endpoint (обычно `/graphql`). Клиент отправляет POST-запрос, содержащий GraphQL-запрос в теле (в формате JSON). Это решает проблемы избыточной (`over-fetching`) или недостаточной (`under-fetching`) выборки данных, что делает GraphQL очень эффективным, особенно для мобильных приложений и сложных пользовательских интерфейсов.

Взаимодействие с GraphQL API из командной строки с помощью `curl` заключается в отправке POST-запроса с JSON-телом, содержащим сам GraphQL-запрос (в поле `query`) и, опционально, переменные (в поле `variables`). Ответ от сервера также приходит в формате JSON. Утилита `jq` незаменима для форматирования и анализа JSON-ответов. Следующая таблица описывает, как формировать и отправлять GraphQL-запросы с помощью `curl`, передавать переменные, обрабатывать ответы и решать типичные проблемы. Это позволит вам эффективно тестировать и использовать GraphQL API, понимая его ключевые отличия от REST и SOAP.

### Работа с GraphQL API с использованием `curl` и `jq`

| Команда/Инструмент                  | Назначение                                                                                                | Параметры (основные для `curl`)                                                                                                                                                                                                                                                                        | Примеры (с комментариями)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Ошибки и Решения                                                                                                                                                                                                                                                           | Влияние                                                                                                                                                                  | Взаимодействие                                                                                                                                                                 |
| :---------------------------------- | :-------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `curl -X POST -H "Content-Type: application/json" -d '{"query": "{graphQL_query}"}' [ENDPOINT_URL]` | Отправка GraphQL-запроса на сервер.                                                                       | `-H "Content-Type: application/json"`: Обязательный заголовок.<br>`-d '{"query": "..."}'`: Тело запроса в формате JSON, содержащее GraphQL-запрос. Поле `query` содержит строку GraphQL-запроса.<br>`[ENDPOINT_URL]`: Обычно один URL для всех GraphQL операций (например, `https://api.example.com/graphql`). | ```bash\n# Пример простого GraphQL запроса (используем публичный API [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api))\n# Запрос: получить id и title поста с id 1\nGRAPHQL_QUERY='{\n  post(id: 1) {\n    id\n    title\n  }\n}'\n\n# Формируем JSON тело для curl\nJSON_PAYLOAD=$(printf '{ "query": "%s" }' "$(echo $GRAPHQL_QUERY | sed 's/"/\\"/g' | tr -d '\\n')")\n\n# Отправка запроса\ncurl -s -X POST \\\n     -H "Content-Type: application/json" \\\n     -d "$JSON_PAYLOAD" \\\n     [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) \\\n     | jq '.'\n\n# Более короткий вариант с одинарными кавычками и экранированием внутри:\ncurl -s -X POST \\\n     -H "Content-Type: application/json" \\\n     -d '{"query": "query { post(id: 1) { id title body } }"}' \\\n     [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) \\\n     | jq '.'\n``` | **Ошибка:** Ответ содержит `{"errors": [...]}`.<br>**Решение:** Ошибка в синтаксисе GraphQL-запроса, запрашиваются несуществующие поля или неверные аргументы. Проверьте схему GraphQL и ваш запрос. Сообщение об ошибке в `errors` обычно подробно описывает проблему.<br>**Ошибка:** `400 Bad Request` (без JSON `errors`).<br>**Решение:** Возможно, тело запроса не является валидным JSON, или отсутствует заголовок `Content-Type: application/json`. | Запрос обрабатывается GraphQL-сервером, который собирает данные из различных источников согласно запросу. Нагрузка на сервер зависит от сложности запроса.            | Взаимодействует с GraphQL-сервером. Один endpoint обрабатывает все запросы. Требует знания GraphQL-схемы для формирования корректных запросов.                        |
| Использование переменных в GraphQL запросе | Передача динамических значений в GraphQL-запрос с помощью переменных для переиспользования запросов и безопасности. | `-d '{"query": "queryName($var: Type) { ... }", "variables": {"var": "value"}}'`: Поле `variables` в JSON-теле содержит объект с переменными. В GraphQL-запросе переменные объявляются с типом (`$var: Type`).                                                                                             | ```bash\n# Запрос: получить пост по ID, используя переменную\nGRAPHQL_QUERY_WITH_VARS='query GetPostById($postId: ID!) {\n  post(id: $postId) {\n    id\n    title\n    user {\n      name\n      email\n    }\n  }\n}'\n\n# Переменные для запроса\nVARIABLES='{ "postId": 2 }'\n\n# Формируем JSON тело (используем jq для безопасного создания JSON)\nJSON_PAYLOAD=$(jq -n --arg query "$GRAPHQL_QUERY_WITH_VARS" --argjson vars "$VARIABLES" '{query: $query, variables: $vars}')\n\n# Отправка запроса\ncurl -s -X POST \\\n     -H "Content-Type: application/json" \\\n     -d "$JSON_PAYLOAD" \\\n     [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) \\\n     | jq '.'\n```                                                                                                                                                                                                                                                                                                                                                                                    | **Ошибка:** В ответе `errors` указано, что переменная не определена или имеет неверный тип.<br>**Решение:** Убедитесь, что имя переменной в `variables` совпадает с именем в запросе (без `$`), и тип переменной в запросе (`Type!`) соответствует значению и требованиям схемы.<br>**Ошибка:** JSON для `variables` невалиден.<br>**Решение:** Проверьте синтаксис JSON для объекта переменных. | Переменные делают запросы более гибкими и безопасными (предотвращают инъекции в строку запроса).                                                                   | GraphQL-сервер использует переменные для выполнения параметризованного запроса.                                                                                      |
| Интроспекция (Introspection Query)     | Получение схемы GraphQL API для понимания доступных типов, полей, запросов (queries), мутаций (mutations) и подписок (subscriptions). | Стандартный интроспективный запрос. Он довольно длинный, часто используют готовые утилиты или копируют его из документации GraphQL.                                                                                                                                     | ```bash\n# Сокращенный пример интроспективного запроса для получения всех типов\nINTROSPECTION_QUERY='{\n  __schema {\n    types {\n      name\n      kind\n    }\n  }\n}'\n\nJSON_PAYLOAD=$(printf '{ "query": "%s" }' "$(echo $INTROSPECTION_QUERY | sed 's/"/\\"/g' | tr -d '\\n')")\n\ncurl -s -X POST \\\n     -H "Content-Type: application/json" \\\n     -d "$JSON_PAYLOAD" \\\n     [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) \\\n     | jq '.'\n\n# Для полного интроспективного запроса см. [https://graphql.org/learn/introspection/](https://graphql.org/learn/introspection/)\n# Можно использовать инструменты типа graphiql-cli или graphql-cli для удобной интроспекции.\n``` | **Ошибка:** Интроспекция может быть отключена на некоторых публичных API из соображений безопасности.<br>**Решение:** Проверьте документацию API или используйте предоставленные инструменты разработчика (например, GraphiQL IDE), если они есть.<br>**Ошибка:** Ответ слишком большой и трудночитаемый.<br>**Решение:** Используйте `jq` для фильтрации и навигации по схеме. | Интроспекция не изменяет данные, но может создавать нагрузку, так как серверу нужно сериализовать всю схему.                                                              | Позволяет клиенту динамически изучать API. Инструменты разработчика (GraphiQL, Postman) используют интроспекцию для автодополнения и валидации.                      |
| Мутации (Mutations)                  | Выполнение операций, изменяющих данные на сервере (аналог POST, PUT, DELETE в REST).                      | Синтаксис мутации похож на query, но используется ключевое слово `mutation`.                                                                                                                                                                                                                | ```bash\n# Пример мутации (создание поста - graphqlzero.almansi.me не поддерживает это без аутентификации, но синтаксис будет таким)\n# MUTATION_QUERY='mutation CreatePost($title: String!, $body: String!) {\n#   createPost(input: {title: $title, body: $body}) {\n#     id\n#     title\n#   }\n# }'\n# VARIABLES='{ "title": "New Post", "body": "Content of new post" }'\n# JSON_PAYLOAD=$(jq -n --arg query "$MUTATION_QUERY" --argjson vars "$VARIABLES" '{query: $query, variables: $vars}')\n\n# curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) | jq '.'\n\n# Пример для API, который поддерживает мутации (гипотетический):\n# curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer YOUR_TOKEN" \\\n# -d '{"query": "mutation { addReview(episode: JEDI, review: {stars: 5, commentary: \\"This is great!\\"}) { stars commentary } }"}' \\\n# [https://api.example.com/graphql](https://api.example.com/graphql)\n``` | **Ошибка:** `401 Unauthorized` / `403 Forbidden` или ошибка в GraphQL `errors` о нехватке прав.<br>**Решение:** Мутации часто требуют аутентификации. Убедитесь, что вы передаете корректный `Authorization` заголовок (например, Bearer Token).<br>**Ошибка:** Мутация не выполнена, данные не изменились.<br>**Решение:** Проверьте GraphQL `errors` в ответе, возможно, входные данные не прошли валидацию. | Мутации изменяют данные на сервере. Важно понимать их влияние и идемпотентность (многие мутации не идемпотентны).                                                    | Взаимодействует с логикой изменения данных на сервере. Часто требует аутентификации и авторизации.                                                                     |
| **Важно запомнить** | \- Всегда один endpoint для всех операций (обычно `/graphql`).<br>\- Запросы всегда `POST` с `Content-Type: application/json`.<br>\- Тело запроса: `{"query": "...", "variables": {...}}`.<br>\- Ответ содержит поле `data` с результатами и/или поле `errors` с ошибками. |                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                            |                                                                                                                                                                                  |                                                                                                                                                                                |
| **Типичные ошибки (общие)** | \- Ошибки синтаксиса в GraphQL-запросе (забыли фигурные скобки, неверные имена полей).<br>\- Запрос невалидных полей (не существуют в схеме).<br>\- Проблемы с переменными (не тот тип, не переданы обязательные).<br>\- JSON в `-d` невалиден (часто из-за проблем с кавычками и экранированием). |                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                            |                                                                                                                                                                                  |                                                                                                                                                                                |

## gRPC API

gRPC (Google Remote Procedure Call) — это современная высокопроизводительная RPC (Remote Procedure Call) система с открытым исходным кодом, которая может работать в любой среде. Она использует HTTP/2 в качестве транспортного протокола и Protocol Buffers (Protobuf) как язык описания интерфейсов (IDL) и формат сериализации сообщений. Это обеспечивает эффективность, типизацию, поддержку потоковой передачи данных (streaming) и генерацию кода для множества языков. gRPC часто используется для построения микросервисов благодаря своей производительности и строгим контрактам.

Для взаимодействия с gRPC-сервисами из командной строки используется утилита `grpcurl`. Она позволяет вызывать RPC-методы, просматривать доступные сервисы и методы (аналогично интроспекции в GraphQL или WSDL в SOAP), а также отправлять метаданные. `grpcurl` может работать с серверами, используя серверную рефлексию (если она включена), или на основе локальных `.proto` файлов, описывающих сервисы. Следующая таблица подробно описывает использование `grpcurl` для различных операций: листинга сервисов и методов, вызова unary RPC (простой запрос-ответ) и работы с потоками (если это возможно в рамках `grpcurl` для простых примеров), а также типичные проблемы и их решения. Это поможет вам начать работу с gRPC API, даже если вы не знакомы с Protobuf или HTTP/2 на низком уровне.

### Работа с gRPC API с использованием `grpcurl`

| Команда/Инструмент                  | Назначение                                                                                                                               | Параметры (основные)                                                                                                                                                                                                                                                                                                                          | Примеры (с комментариями)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Ошибки и Решения                                                                                                                                                                                                                                                                                                                           | Влияние                                                                                                                                                                                                                           | Взаимодействие                                                                                                                                                                                                                                        |
| :---------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `grpcurl [SERVER_ADDRESS] list`     | Получение списка сервисов, доступных на gRPC-сервере (требует включенной серверной рефлексии или `-proto` файла).                            | `[SERVER_ADDRESS]`: Адрес сервера в формате `host:port`.<br>`-plaintext`: Использовать HTTP (нешифрованное соединение). По умолчанию используется TLS.<br>`-proto <file.proto>`: Использовать указанный proto-файл для определения сервисов.<br>`-import-path <path>`: Путь к директории с proto-файлами, если они импортируют другие. | ```bash\n# Пример для публичного gRPC-сервиса (grpcb.in похож на httpbin для gRPC)\n# Список сервисов на grpcb.in:9001 (требует TLS, но если бы был plaintext сервер)\n# grpcurl -plaintext grpc.server.address:port list\n\n# Пример с Google Cloud DNS API (требует TLS и аутентификации для реальных вызовов, но list может работать)\n# grpcurl dns.google:443 list\n# (Выведет, например, "grpc.reflection.v1alpha.ServerReflection" если рефлексия включена)\n\n# Используем тестовый сервер grpcb.in (TLS по умолчанию)\n# grpcb.in использует порт 9000 для plaintext и 9001 для TLS\ngrpcurl grpcb.in:9001 list\n# Выведет список сервисов, например, grpc.testing.TestService, grpc.health.v1.Health\n``` | **Ошибка:** `Failed to list services: server does not support the reflection API.`<br>**Решение:** Сервер не поддерживает рефлексию. Необходимо использовать `-proto` с путем к proto-файлу, описывающему сервис.<br>**Ошибка:** `Failed to dial target host "..." connection refused`.<br>**Решение:** Сервер недоступен по указанному адресу/порту, или фаервол блокирует соединение. Проверьте адрес и сетевые настройки.<br>**Ошибка:** `transport: authentication handshake failed: x509: certificate signed by unknown authority`.<br>**Решение:** Сервер использует самоподписанный сертификат. Используйте `-insecure` (не рекомендуется для продакшена) или предоставьте корректный корневой сертификат через `-cacert`. | Запрос на получение списка сервисов. Минимальная нагрузка.                                                                                                                                                                                   | Взаимодействует с gRPC-сервером, используя протокол рефлексии (если доступен) или информацию из proto-файлов.                                                                                                                                         |
| `grpcurl [SERVER_ADDRESS] list [SERVICE_NAME]` | Получение списка методов для указанного сервиса.                                                                                       | `[SERVICE_NAME]`: Полное имя сервиса (например, `package.ServiceName`).                                                                                                                                                                                                | ```bash\n# Список методов для сервиса grpc.testing.TestService на grpcb.in:9001\ngrpcurl grpcb.in:9001 list grpc.testing.TestService\n# Выведет, например: EmptyCall, UnaryCall\n\n# Список методов для сервиса Health Check\ngrpcurl grpcb.in:9001 list grpc.health.v1.Health\n# Выведет: Check, Watch\n```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | **Ошибка:** `Failed to list methods for service "...": Service not found.`<br>**Решение:** Имя сервиса указано неверно или сервис не существует. Проверьте список сервисов с помощью `grpcurl ... list`.<br>**Ошибка:** Аналогичные ошибки соединения или сертификата, как в `list` сервисов.                                                               | Запрос на получение списка методов. Минимальная нагрузка.                                                                                                                                                                                 | Аналогично `list` сервисов, но для конкретного сервиса.                                                                                                                                                                                                |
| `grpcurl [SERVER_ADDRESS] describe [SYMBOL]` | Получение описания (схемы) для сервиса, метода, сообщения или другого символа из proto-определений.                                     | `[SYMBOL]`: Полное имя символа (например, `package.ServiceName`, `package.ServiceName.MethodName`, `package.MessageType`).                                                                                                                                     | ```bash\n# Описание сервиса grpc.testing.TestService\ngrpcurl grpcb.in:9001 describe grpc.testing.TestService\n\n# Описание метода UnaryCall в сервисе TestService\ngrpcurl grpcb.in:9001 describe grpc.testing.TestService.UnaryCall\n\n# Описание типа сообщения (запрос для UnaryCall)\ngrpcurl grpcb.in:9001 describe grpc.testing.SimpleRequest\n# Выведет поля сообщения, например: response_type, response_size, payload, etc.\n```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | **Ошибка:** `Failed to resolve symbol "..."`.<br>**Решение:** Символ не найден. Проверьте правильность имени и наличие его в определениях (через рефлексию или proto-файлы).<br>**Ошибка:** Аналогичные ошибки соединения или сертификата.                                                                                                 | Запрос на получение метаданных. Минимальная нагрузка.                                                                                                                                                                                         | Позволяет понять структуру запросов и ответов для методов.                                                                                                                                                                                            |
| `grpcurl -d 'json_data' [SERVER_ADDRESS] [SERVICE_NAME]/[METHOD_NAME]` | Вызов unary RPC-метода (один запрос - один ответ). Данные запроса передаются в формате JSON.                                                  | `-d '{"field_name": "value", ...}'`: Данные запроса в JSON-формате. Структура JSON должна соответствовать типу сообщения запроса, определенному в proto.<br>`-d @`: Читать JSON данные из stdin.<br>`-H "metadata-key: metadata-value"`: Отправка метаданных (заголовков gRPC). | ```bash\n# Вызов метода EmptyCall (не требует данных)\ngrpcurl -plaintext grpcb.in:9000 grpc.testing.TestService/EmptyCall\n\n# Вызов метода UnaryCall с данными (пример для grpc.testing.SimpleRequest)\n# Сначала посмотрим структуру SimpleRequest:\n# grpcurl grpcb.in:9001 describe grpc.testing.SimpleRequest\n# grpc.testing.SimpleRequest is a message:\n# message SimpleRequest {\n#   // Desired payload type in the response from the server.\n#   // If RESPONSE_TYPE_UNSPECIFIED, server will pick an arbitrary type.\n#   .grpc.testing.PayloadType response_type = 1;\n#   // Desired payload size in the response from the server.\n#   // If 0, server will pick an arbitrary size.\n#   int32 response_size = 2;\n#   // Optional input payload sent along with the request.\n#   .grpc.testing.Payload payload = 3;\n#   // Whether SimpleResponse should include username.\n#   bool fill_username = 4;\n#   // Whether SimpleResponse should include OAuth scope.\n#   bool fill_oauth_scope = 5;\n# }\n\n# Вызов UnaryCall\ngrpcurl -d '{\n  "response_size": 10,\n  "payload": {\n    "body": "dGVzdAo=" # "test" в base64 \n  }\n}' \\\n  grpcb.in:9001 \\\n  grpc.testing.TestService/UnaryCall\n\n# Вызов Health Check (стандартный gRPC сервис)\n# Тип запроса: grpc.health.v1.HealthCheckRequest (содержит поле "service")\ngrpcurl -d '{"service": "grpc.testing.TestService"}' \\\n  grpcb.in:9001 \\\n  grpc.health.v1.Health/Check\n# Ожидаемый ответ: {"status": "SERVING"}\n``` | **Ошибка:** `ERROR: Code: InvalidArgument Message: <сообщение об ошибке>`<br>**Решение:** Некорректные данные в JSON для `-d`. Проверьте типы полей и структуру сообщения с помощью `describe`.<br>**Ошибка:** `ERROR: Code: Unimplemented Message: Method not found...`<br>**Решение:** Неправильное имя метода или сервиса.<br>**Ошибка:** `ERROR: Code: Unavailable Message: ...`<br>**Решение:** Проблемы с сетью или сервер недоступен/перегружен. | Выполняет операцию на сервере. Может изменять данные или выполнять вычисления.                                                                                                                                                                        | Взаимодействует с конкретным RPC-методом на сервере. Требует JSON-представления Protobuf-сообщения.                                                                                                                                                   |
| **Важно запомнить** | \- gRPC использует HTTP/2 и Protobuf.<br>\- `grpcurl` требует либо серверной рефлексии, либо `.proto` файлов.<br>\- Данные для запросов (`-d`) передаются в JSON-формате, который `grpcurl` преобразует в Protobuf.<br>\- По умолчанию используется TLS; для HTTP используйте `-plaintext`, для самоподписанных сертификатов `-insecure`. |                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                               |
| **Типичные ошибки (общие)** | \- Проблемы с SSL/TLS сертификатами (используйте `-insecure` для тестов или `-cacert`).<br>\- Серверная рефлексия отключена, и не предоставлены `.proto` файлы.<br>\- Неправильный формат JSON для данных запроса (`-d`).<br>\- Сетевые проблемы: фаервол, неправильный адрес/порт. |                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                               |
| **Потоковые RPC (Streaming)** | `grpcurl` поддерживает клиентский, серверный и двунаправленный стриминг. Данные для потока запросов передаются как последовательность JSON-сообщений через stdin.                                 | `-d @`: Читать JSON-сообщения из stdin, разделенные переводом строки.                                                                                                                                                                                                | ```bash\n# Пример для гипотетического EchoStream сервиса, который возвращает каждое сообщение\n# (Сервис должен поддерживать клиентский или двунаправленный стриминг)\n# printf '{"message": "hello"}\\n{"message": "world"}\\n' \\\n# | grpcurl -plaintext -d @ localhost:50051 my.ProtoService/EchoStream\n\n# Для grpcb.in StreamingOutputCall (серверный стриминг):\n# Запрос grpc.testing.StreamingOutputCallRequest\n# grpcurl grpcb.in:9001 describe grpc.testing.StreamingOutputCallRequest\n# message StreamingOutputCallRequest {\n#   ... // параметры для ответа\n#   repeated .grpc.testing.ResponseParameters response_parameters = 1;\n#   ...\n# }\n# grpcurl -d '{\n#   "response_parameters": [\n#     { "size": 10, "interval_us": 0 },\n#     { "size": 20, "interval_us": 10000 }\n#   ]\n# }' grpcb.in:9001 grpc.testing.TestService/StreamingOutputCall\n# (Выведет несколько JSON ответов)\n``` | **Ошибка:** Метод не поддерживает стриминг или не тот тип стриминга.<br>**Решение:** Проверьте определение метода в `.proto` файле (ключевые слова `stream`).<br>**Ошибка:** Неправильный формат JSON-сообщений в потоке.<br>**Решение:** Каждое JSON-сообщение в stdin должно быть на новой строке и соответствовать типу сообщения запроса. | Потоковые RPC позволяют обрабатывать большие объемы данных или поддерживать длительные соединения.                                                                                                                                               | Для клиентского стриминга `grpcurl` отправляет последовательность сообщений. Для серверного стриминга `grpcurl` получает и выводит последовательность сообщений.                                                                                     |

## Общий справочник команд и конфигураций

Этот раздел предназначен для быстрого доступа к основным командам и параметрам конфигурации, упомянутым в руководстве. Он не заменяет подробные таблицы выше, а скорее служит как краткая шпаргалка.

```bash
# --- REST API с curl и jq ---

# Простой GET запрос
# URL: Адрес ресурса
curl [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1)

# GET запрос с выводом заголовков ответа
# -i: Включить заголовки в вывод
curl -i [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1)

# POST запрос с JSON данными
# -X POST: Указать метод POST
# -H "Content-Type: application/json": Указать тип контента
# -d '{"key": "value"}': Тело запроса в формате JSON
curl -X POST -H "Content-Type: application/json" -d '{"title": "foo", "body": "bar", "userId": 1}' [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)

# Отправка данных из файла (например, file.json)
# -d @file.json: Тело запроса из файла
# echo '{"title": "from file"}' > file.json
# curl -X POST -H "Content-Type: application/json" -d @file.json [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)

# Использование Basic Auth
# -u "username:password": Учетные данные
curl -u "testuser:testpassword" [https://httpbin.org/basic-auth/testuser/testpassword](https://httpbin.org/basic-auth/testuser/testpassword)

# Отправка кастомного заголовка (например, API ключ)
# -H "X-API-Key: yourkey": Кастомный заголовок
# curl -H "X-API-Key: MY_API_KEY" [https://api.example.com/data](https://api.example.com/data)

# Сохранение вывода в файл
# -o outputfile.json: Имя файла для сохранения
curl -o post.json [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1)

# Использование jq для форматирования JSON ответа
# | jq '.': Передать вывод curl на jq для форматирования
curl -s [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1) | jq '.'

# Использование jq для извлечения конкретного поля
# | jq '.fieldName': Извлечь значение поля fieldName
curl -s [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1) | jq '.title'

# Загрузка файла (multipart/form-data)
# -F "fieldname=@filepath": Поле формы с файлом
# touch my_file.txt
# curl -X POST -F "fileUpload=@my_file.txt" [https://httpbin.org/post](https://httpbin.org/post)

# Следовать редиректам
# -L: Следовать HTTP редиректам
curl -L [http://httpbin.org/redirect/2](http://httpbin.org/redirect/2)

# Тихий режим (без прогресс-бара)
# -s: Silent mode
curl -s [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1) > /dev/null

# Показать ошибки, даже в тихом режиме
# -S: Show error
curl -sS [https://nonexistentdomain.invalid/](https://nonexistentdomain.invalid/)

# Подробный вывод для отладки
# -v: Verbose output
curl -v [https://jsonplaceholder.typicode.com/posts/1](https://jsonplaceholder.typicode.com/posts/1)

# --- SOAP API с curl и xmlstarlet ---

# Подготовка XML файла для SOAP запроса (например, soap_request.xml)
# <?xml version="1.0" encoding="utf-8"?>
# <soap:Envelope xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)" xmlns:xsd="[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)" xmlns:soap="[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)">
#   <soap:Body>
#     <Add xmlns="[http://tempuri.org/](http://tempuri.org/)">
#       <intA>25</intA>
#       <intB>15</intB>
#     </Add>
#   </soap:Body>
# </soap:Envelope>

# Отправка SOAP запроса
# -H "Content-Type: text/xml;charset=UTF-8": Тип контента для SOAP 1.1
# -H "SOAPAction: \"action_url\"": SOAPAction для SOAP 1.1
# -d @soap_request.xml: XML тело запроса из файла
# ENDPOINT_URL: URL SOAP сервиса
# curl -X POST \
#      -H "Content-Type: text/xml;charset=UTF-8" \
#      -H "SOAPAction: \"[http://tempuri.org/Add](http://tempuri.org/Add)\"" \
#      -d @soap_request.xml \
#      [http://www.dneonline.com/calculator.asmx](http://www.dneonline.com/calculator.asmx)

# Форматирование XML ответа с xmlstarlet
# | xmlstarlet fo: Передать вывод на xmlstarlet для форматирования
# (предыдущий curl) ... | xmlstarlet fo

# Извлечение данных из XML ответа с xmlstarlet (XPath)
# -N prefix="namespace_uri": Регистрация неймспейса
# -t -v "//xpath_expression": Шаблон для вывода значения
# (предыдущий curl) ... -o soap_response.xml
# xmlstarlet sel -N s="[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)" -N tns="[http://tempuri.org/](http://tempuri.org/)" \
#             -t -v "//s:Body/tns:AddResponse/tns:AddResult" soap_response.xml

# Получение WSDL файла
# WSDL_URL: URL WSDL файла (обычно ?wsdl на конце endpoint)
# curl [http://www.dneonline.com/calculator.asmx?WSDL](http://www.dneonline.com/calculator.asmx?WSDL) -o calculator.wsdl
# xmlstarlet fo calculator.wsdl # Для просмотра

# --- GraphQL API с curl и jq ---

# GraphQL запрос (получить id и title поста с id=1)
# GRAPHQL_QUERY='{ post(id: 1) { id title } }'
# JSON_PAYLOAD=<span class="math-inline">\(printf '\{ "query"\: "%s" \}' "</span>(echo $GRAPHQL_QUERY | sed 's/"/\\"/g' | tr -d '\\n')")
# ENDPOINT_URL: URL GraphQL сервиса (например, [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api))
# curl -s -X POST \
#      -H "Content-Type: application/json" \
#      -d "$JSON_PAYLOAD" \
#      [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) | jq '.'

# GraphQL запрос с переменными
# QUERY='query GetPost($postId: ID!) { post(id: <span class="math-inline">postId\) \{ id title user \{ name \} \} \}'
\# VARIABLES\='\{ "postId"\: 3 \}'
\# JSON\_PAYLOAD\_VARS\=</span>(jq -n --arg query "$QUERY" --argjson vars "$VARIABLES" '{query: $query, variables: $vars}')
# curl -s -X POST \
#      -H "Content-Type: application/json" \
#      -d "<span class="math-inline">JSON\_PAYLOAD\_VARS" \\
\#      \[https\://graphqlzero\.almansi\.me/api\]\(https\://graphqlzero\.almansi\.me/api\) \| jq '\.'
\# GraphQL интроспективный запрос \(получить все типы \- сокращенный\)
\# INTRO\_QUERY\='\{ \_\_schema \{ types \{ name kind \} \} \}'
\# JSON\_PAYLOAD\_INTRO\=</span>(printf '{ "query": "%s" }' "$(echo $INTRO_QUERY | sed 's/"/\\"/g' | tr -d '\\n')")
# curl -s -X POST \
#      -H "Content-Type: application/json" \
#      -d "$JSON_PAYLOAD_INTRO" \
#      [https://graphqlzero.almansi.me/api](https://graphqlzero.almansi.me/api) | jq '.'

# --- gRPC API с grpcurl ---

# SERVER_ADDRESS: host:port gRPC сервера (например, grpcb.in:9001)

# Листинг сервисов (требует TLS для grpcb.in:9001, или -plaintext для нешифрованных)
# grpcurl grpcb.in:9001 list

# Листинг методов для сервиса
# SERVICE_NAME: полное имя сервиса (например, grpc.testing.TestService)
# grpcurl grpcb.in:9001 list grpc.testing.TestService

# Описание символа (сервис, метод, сообщение)
# SYMBOL_NAME: полное имя символа (например, grpc.testing.SimpleRequest)
# grpcurl grpcb.in:9001 describe grpc.testing.SimpleRequest

# Вызов unary RPC метода (без данных для EmptyCall)
# grpcurl -plaintext grpcb.in:9000 grpc.testing.TestService/EmptyCall

# Вызов unary RPC метода с JSON данными
# -d '{"json_key": "value"}': JSON данные для запроса
# grpcurl -d '{"service": "grpc.testing.TestService"}' \
#   grpcb.in:9001 \
#   grpc.health.v1.Health/Check

# Вызов unary RPC с JSON данными из stdin
# echo '{"service": "grpc.testing.TestService"}' | grpcurl -d @ grpcb.in:9001 grpc.health.v1.Health/Check

# Использование proto-файла (если рефлексия отключена)
# -proto path/to/your.proto: Путь к proto файлу
# -import-path /path/to/imports: Путь к директории с импортируемыми proto
# grpcurl -proto myservice.proto -import-path ./protos -d '{"field": "val"}' localhost:8080 mypackage.MyService/MyMethod

# Использование нешифрованного соединения
# -plaintext: Использовать HTTP вместо HTTPS/TLS
# grpcurl -plaintext localhost:8080 list

# Игнорировать небезопасные SSL сертификаты (для тестов)
# -insecure: Не проверять SSL сертификат сервера
# grpcurl -insecure selfsigned.server:443 list

# Отправка метаданных (заголовков gRPC)
# -H "metadata-key: value": Отправить метаданные
# grpcurl -H "client-id: my-client" -d '{}' grpcb.in:9001 grpc.testing.TestService/EmptyCall

# --- Общие конфигурации Bash (не команды API, а полезные приемы) ---

# Создание алиаса для часто используемой команды (добавить в ~/.bashrc или ~/.zshrc)
# alias назвать_кратко='длинная команда с параметрами'
# Пример:
# alias restget='curl -s -H "Accept: application/json"'
# alias prettyjson='jq "."'

# Использование переменных окружения для хранения токенов/ключей
# export MY_API_TOKEN="your_secret_token"
# curl -H "Authorization: Bearer $MY_API_TOKEN" [https://api.example.com/secure-data](https://api.example.com/secure-data)

# Создание файла .netrc для curl Basic Auth (безопаснее, чем в командной строке)
# Файл: ~/.netrc (или указанный через --netrc-file)
# Содержимое:
# machine myapiserver.example.com
# login myuser
# password mysecretpassword
# Права доступа: chmod 600 ~/.netrc
# Использование: curl --netrc [https://myapiserver.example.com/data](https://myapiserver.example.com/data)
