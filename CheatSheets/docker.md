# Архитектура и основные компоненты Docker

 | Компонент | Описание |
 |-|-|
 | **Docker Engine** | Основной компонент Docker, который включает в себя Docker Daemon, REST API и CLI. Docker Engine отвечает за создание и управление контейнерами. |
 | **Docker Daemon** | Серверный процесс, который управляет контейнерами, образами, сетями и хранилищами. Docker Daemon взаимодействует с Docker API для управления ресурсами. |
 | **Docker CLI** | Интерфейс командной строки для взаимодействия с Docker Daemon. Docker CLI используется для выполнения команд, таких как создание, запуск и управление контейнерами. |
 | **Dockerfile** | Текстовый файл, содержащий последовательность команд для сборки образа Docker. Dockerfile используется для автоматизации процесса создания образов. |
 | **Docker Hub** | Облачный сервис для хранения и распространения образов Docker. Docker Hub используется для хранения публичных и приватных образов, а также для их распространения. |
 | **Docker Compose** | Инструмент для определения и запуска многоконтейнерных Docker-приложений. Docker Compose использует YAML-файлы для определения конфигурации приложений. |
 | **Docker Swarm** | Встроенный оркестратор для управления кластером Docker-контейнеров. Docker Swarm используется для создания и управления кластерами контейнеров. |
 | **Docker Network** | Виртуальная сеть, которая позволяет контейнерам взаимодействовать друг с другом. Docker Network используется для изоляции и управления сетевым трафиком между контейнерами. |
 | **Docker Volume** | Механизм для хранения данных, которые могут быть использованы контейнерами. Томы обеспечивают постоянное хранилище для данных, которые должны сохраняться между перезапусками контейнеров. |
 | **Docker Registry** | Сервис для хранения и распространения образов Docker. Реестр используется для хранения публичных и приватных образов, а также для их распространения. |
 
 # Основные термины Docker

 | Термин | Описание |
 |-|-|
 | **Docker** (Докер) | Платформа для разработки, доставки и эксплуатации контейнеризованных приложений. Docker позволяет упаковывать приложения и их зависимости в контейнеры, которые можно запускать на любом сервере. |
 | **Image** (Образ) | Неизменяемый шаблон, который содержит все необходимые зависимости для запуска контейнера. Образы используются для создания контейнеров. |
 | **Container** (Контейнер) | Легковесный и изолированный процесс, который запускается на основе образа. Контейнеры обеспечивают изоляцию приложений и их зависимостей. |
 | **Layer** (Слой) | Часть образа Docker, которая представляет собой изменение в файловой системе. Слои используются для создания образов и обеспечения их эффективного хранения и распространения. |
 | **Tag** (Тег) | Метка, которая используется для идентификации версии образа. Теги позволяют управлять различными версиями одного и того же образа. |
 | **Repository** (Репозиторий) | Коллекция образов Docker, которые имеют одно и то же имя, но могут иметь разные теги. Репозиторий используется для хранения и управления образами. |
 | **Dockerfile** (Докерфайл) | Текстовый файл, содержащий последовательность команд для сборки образа Docker. Dockerfile используется для автоматизации процесса создания образов. |

# Операции в Docker

 | Операция | Описание | Для чего нужна | В каких компонентах используется | Как это делается |
 |-|-|-|-|-|
 | **docker build** | Создает образ Docker на основе Dockerfile. | Создание образов для контейнеров. | Docker CLI, Docker Daemon | `docker build -t my-image .` |
 | **docker run** | Создает и запускает контейнер на основе образа. | Запуск контейнеров из образов. | Docker CLI, Docker Daemon | `docker run -d -name my-container my-image` |
 | **docker push** | Отправляет образ в реестр Docker. | Распространение образов в реестре. | Docker CLI, Docker Daemon | `docker push my-image` |
 | **docker pull** | Получает образ из реестра Docker. | Загрузка образов из реестра. | Docker CLI, Docker Daemon | `docker pull my-image` |
 | **docker exec** | Выполняет команду внутри запущенного контейнера. | Диагностика и управление контейнерами. | Docker CLI, Docker Daemon | `docker exec -it my-container /bin/bash` |
 | **docker logs** | Показывает логи контейнера. | Мониторинг и диагностика контейнеров. | Docker CLI, Docker Daemon | `docker logs my-container` |
 | **docker inspect** | Получает подробную информацию о контейнере или образе. | Диагностика и управление контейнерами и образами. | Docker CLI, Docker Daemon | `docker inspect my-container` |
 | **docker stop** | Останавливает запущенный контейнер. | Управление жизненным циклом контейнеров. | Docker CLI, Docker Daemon | `docker stop my-container` |
 | **docker remove** | Удаляет контейнер или образ. | Управление ресурсами и освобождение места. | Docker CLI, Docker Daemon | `docker rm my-container` |
 | **docker prune** | Удаляет все остановленные контейнеры, неиспользуемые сети, образы и тома. | Освобождение места и управление ресурсами. | Docker CLI, Docker Daemon | `docker system prune` |
 | **docker compose up** | Запускает и создает контейнеры, определенные в Docker Compose файле. | Запуск многоконтейнерных приложений. | Docker Compose, Docker CLI, Docker Daemon | `docker-compose up` |
 | **docker compose down** | Останавливает и удаляет контейнеры, определенные в Docker Compose файле. | Остановка и удаление многоконтейнерных приложений. | Docker Compose, Docker CLI, Docker Daemon | `docker-compose down` |
 | **docker network create** | Создает виртуальную сеть для контейнеров. | Изоляция и управление сетевым трафиком между контейнерами. | Docker CLI, Docker Daemon | `docker network create my-network` |
 | **docker volume create** | Создает том для хранения данных. | Постоянное хранилище данных для контейнеров. | Docker CLI, Docker Daemon | `docker volume create my-volume` |
 | **docker swarm init** | Инициализирует Docker Swarm кластер. | Создание и управление кластером контейнеров. | Docker CLI, Docker Daemon | `docker swarm init` |
 | **docker swarm join** | Присоединяет узел к Docker Swarm кластеру. | Расширение кластера контейнеров. | Docker CLI, Docker Daemon | `docker swarm join -token <token> <manager-ip>:<manager-port>` |
 | **docker service create** | Создает сервис в Docker Swarm кластере. | Управление сервисами в кластере контейнеров. | Docker CLI, Docker Daemon | `docker service create -name my-service -replicas 3 my-image` |

# Пример docker файла

```dockerfile
# Используем базовый образ (FROM)
# FROM указывает, какой образ будет использоваться как основа.
# Образы скачиваются с Docker Hub по умолчанию, но можно указать кастомный репозиторий.
# Пример 1: Официальный образ Python с Docker Hub
FROM python:3.9
# Пример 2: Кастомный образ из приватного репозитория
FROM my-private-registry.com/custom-image:latest
# Пример 3: Указание платформы (например, ARM или x86_64)
FROM --platform=linux/amd64 python:3.9

# Устанавливаем метаданные для образа (LABEL)
# LABEL позволяет добавить метаданные к образу.
# Форматирование: ключ=значение. Можно использовать несколько строк.
# Пример 1: Одна строка метаданных
LABEL maintainer="your-email@example.com"
# Пример 2: Несколько строк метаданных
LABEL version="1.0" description="Example Dockerfile" build_date="2023-10-01"
# Цвет: Метки не поддерживают цвет, так как это просто текстовые метаданные.

# Устанавливаем рабочую директорию внутри контейнера (WORKDIR)
# WORKDIR задает рабочую директорию для всех последующих инструкций.
# Зачем нужна рабочая директория:
# 1. Упрощает управление путями внутри контейнера.
# 2. Предотвращает ошибки при работе с относительными путями.
# Пример 1: Создание директории `/app` и установка её как рабочей
WORKDIR /app
# Пример 2: Переключение на вложенную директорию
WORKDIR /app/src

# Копируем файлы из локальной системы в контейнер (COPY)
# COPY копирует файлы или директории из хостовой системы в контейнер.
# Первый аргумент — путь на хосте, второй — путь в контейнере.
# Пример 1: Копирование одного файла
COPY requirements.txt /app/
# Пример 2: Копирование всей директории
COPY src/ /app/src/
# Пример 3: Копирование нескольких файлов
COPY file1.txt file2.txt /app/

# Запускаем команду внутри контейнера (RUN)
# RUN выполняет команду во время сборки образа.
# Пути указываются относительно WORKDIR, если не указан абсолютный путь.
# Пример 1: Установка зависимостей
RUN pip install --no-cache-dir -r requirements.txt
# Пример 2: Создание директории и изменение прав доступа
RUN mkdir /logs && chmod 755 /logs
# Пример 3: Использование абсолютных путей
RUN cp /source/file.txt /destination/file.txt

# Добавляем файлы в контейнер (ADD)
# ADD похож на COPY, но имеет дополнительные возможности:
# 1. Распаковка архивов.
# 2. Скачивание файлов по URL.
# Пример 1: Распаковка архива
ADD example.tar.gz /app/
# Пример 2: Скачивание файла по URL
ADD https://example.com/file.txt /app/file.txt
# Пример 3: Копирование локального файла
ADD local-file.txt /app/local-file.txt

# Публикуем порт контейнера (EXPOSE)
# EXPOSE информирует Docker о том, что контейнер будет слушать указанный порт.
# Чтобы порт действительно слушался, нужно настроить приложение внутри контейнера.
# Пример 1: Открытие порта 8000
EXPOSE 8000
# Пример 2: Указание протокола (TCP или UDP)
EXPOSE 8000/tcp
# Внутри контейнера: Приложение должно быть настроено на прослушивание указанного порта.

# Создаем том (VOLUME)
# VOLUME создает точку монтирования для данных, которые должны сохраняться вне контейнера.
# Пути указываются относительно контейнера.
# На хостовой машине Docker автоматически создает директорию для тома.
# Пример 1: Создание тома `/data`
VOLUME /data
# Пример 2: Указание нескольких томов
VOLUME ["/data", "/logs"]
# Где находятся данные на хосте: Docker создает директорию в `/var/lib/docker/volumes/`.

# Определяем временную точку остановки (STOPSIGNAL)
# STOPSIGNAL определяет сигнал, который будет отправлен контейнеру при его остановке.
# На хостовой машине сигнал отправляется через `docker stop`.
# Пример 1: Использование стандартного сигнала SIGTERM
STOPSIGNAL SIGTERM
# Пример 2: Использование другого сигнала (например, SIGKILL)
STOPSIGNAL SIGKILL

# Импортируем другой Dockerfile (ONBUILD)
# ONBUILD определяет команды, которые будут выполнены при использовании этого образа как базового.
# Дочерний образ — это образ, который использует текущий образ как базовый.
# Пример 1: Команда, которая выполнится в дочернем образе
ONBUILD COPY . /app
# Пример 2: Установка зависимостей в дочернем образе
ONBUILD RUN pip install --no-cache-dir -r requirements.txt

# Определяем аргументы сборки (ARG)
# ARG позволяет передавать параметры во время сборки образа.
# Аргументы бывают:
# 1. Простые переменные (например, BUILD_VERSION).
# 2. Переменные с значениями по умолчанию.
# Пример 1: Определение аргумента без значения
ARG BUILD_VERSION
# Пример 2: Определение аргумента со значением по умолчанию
ARG APP_ENV=production
# Передача аргументов: `docker build --build-arg BUILD_VERSION=1.0 .`

# Пример использования HEALTHCHECK
# HEALTHCHECK проверяет работоспособность контейнера.
# Команда выполняется внутри контейнера.
# Пример 1: Проверка HTTP-сервера
HEALTHCHECK --interval=30s --timeout=10s \
  CMD curl -f http://localhost:8000/health || exit 1
# Пример 2: Проверка TCP-соединения
HEALTHCHECK --interval=30s --timeout=5s \
  CMD nc -z localhost 8000 || exit 1
# Интервал, таймаут и код выхода настраиваются через флаги.

# Пример использования SHELL
# SHELL изменяет оболочку по умолчанию для выполнения команд.
# Оболочка должна содержаться внутри контейнера.
# Пример 1: Изменение оболочки на bash
SHELL ["/bin/bash", "-c"]
# Пример 2: Возврат к шеллу по умолчанию
SHELL ["/bin/sh", "-c"]
```
