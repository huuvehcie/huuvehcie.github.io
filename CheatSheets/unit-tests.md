# Методика создания UNIT-тестов для вопросов проведения сертификации ПО во ФСТЭК и инспекционного контроля

## 1. Введение

Настоящий документ представляет собой техническую методику создания UNIT-тестов, ориентированную на верификацию корректности реализации программного обеспечения (ПО) в части, имеющей отношение к вопросам, возникающим в процессе проведения сертификации ПО во ФСТЭК России и последующего инспекционного контроля. Документ предназначен для инженеров-разработчиков и инженеров по тестированию, ответственных за обеспечение соответствия ПО требованиям безопасности информации.

Целью документа является формализация процесса разработки низкоуровневых автоматизированных тестов, позволяющих на ранних этапах жизненного цикла разработки выявлять дефекты и несоответствия, критичные с точки зрения требований безопасности информации и специфических "вопросов", которые могут быть подняты органом по сертификации или контролирующими организациями. Методика обеспечивает систематизированный подход к созданию верифицируемых и воспроизводимых доказательств корректной работы отдельных компонентов ПО в контексте применимых требований.

## 2. Контекст: Сертификация ПО во ФСТЭК и Инспекционный Контроль

Сертификация ПО во ФСТЭК России является процедурой подтверждения соответствия программного обеспечения требованиям стандартов, руководящих документов и технических условий по безопасности информации. В процессе сертификации оценивается не только функциональность, но и защищенность ПО, отсутствие недекларированных возможностей, корректность реализации механизмов защиты информации.

"Вопросы проведения сертификации" и "вопросы инспекционного контроля" представляют собой набор конкретных проверок, тестов, анализов и требований, выдвигаемых органом по сертификации или ФСТЭК России к ПО. Эти вопросы могут касаться:
* Корректности реализации функций безопасности (аутентификация, авторизация, контроль целостности, аудит событий безопасности, криптографические преобразования).
* Правильности обработки конфиденциальной информации.
* Соответствия внутренней архитектуры и структуры кода заявленным свойствам безопасности.
* Отсутствия известных уязвимостей в используемых компонентах.
* Корректности обработки исключительных ситуаций, влияющих на безопасность.
* Соответствия поведения ПО требованиям доверия (например, требованиям к исходным текстам, процедурам разработки, контролю версий).

Инспекционный контроль, в свою очередь, является периодической проверкой сертифицированного ПО с целью подтверждения сохранения его характеристик безопасности после внесения изменений или в процессе эксплуатации. Вопросы инспекционного контроля часто фокусируются на изменениях, внесенных в ПО, и их влиянии на безопасность.

## 3. Назначение UNIT-тестирования в Контексте ФСТЭК

UNIT-тестирование — это процесс автоматизированной проверки наименьших изолируемых частей (единиц, модулей) исходного кода ПО на предмет их корректного функционирования. В контексте сертификации ФСТЭК и инспекционного контроля, UNIT-тестирование приобретает дополнительное значение как инструмент для:

* **Раннего выявления дефектов безопасности:** Обнаружение ошибок в реализации функций безопасности или обработке данных на самом низком уровне, до интеграции с другими компонентами.
* **Верификации реализации специфических требований безопасности:** Проверка корректности работы отдельных алгоритмов, функций или фрагментов кода, напрямую связанных с выполнением требований нормативных документов ФСТЭК или технических заданий на защиту информации.
* **Предоставления объективных доказательств:** Автоматизированные UNIT-тесты служат воспроизводимым доказательством того, что конкретная единица кода ведет себя в соответствии с ожидаемым поведением, в том числе в сценариях, критичных для безопасности.
* **Снижения рисков в процессе инспекционного контроля:** Наличие актуального набора UNIT-тестов, покрывающего критичные для безопасности компоненты, упрощает доказательство отсутствия негативного влияния внесенных изменений на функции безопасности.
* **Улучшения качества кода:** UNIT-тестирование способствует созданию более модульного, слабо связанного и легко поддерживаемого кода, что снижает вероятность внесения ошибок при модификации.

UNIT-тесты в данном контексте не заменяют другие виды тестирования (интеграционное, системное, тестирование безопасности, анализ уязвимостей), но являются фундаментом для построения системы доказательств соответствия ПО требованиям безопасности на низком уровне детализации.

## 4. Основные Принципы UNIT-тестирования для Задач Сертификации

При разработке UNIT-тестов для ПО, проходящего сертификацию или инспекционный контроль во ФСТЭК, необходимо строго придерживаться следующих принципов:

* **Изоляция:** Каждая единица кода (класс, функция, метод) должна тестироваться изолированно от зависимостей. Использование заглушек (stubs), имитаторов (mocks) и фикстур (fixtures) является обязательным для обеспечения повторяемости результатов теста и исключения влияния внешних факторов или состояния других компонентов. Цель — проверить только логику тестируемого блока.
* **Автоматизация:** Все UNIT-тесты должны быть полностью автоматизированы и запускаться без ручного вмешательства. Это обеспечивает возможность частых запусков (например, при каждом изменении кода) и интеграцию в процессы непрерывной интеграции/непрерывной поставки (CI/CD).
* **Повторяемость (Воспроизводимость):** Результат выполнения одного и того же UNIT-теста при неизменном исходном коде и тестовом окружении всегда должен быть одинаковым. Недетерминированные тесты недопустимы. Зависимость от времени, порядка выполнения тестов или внешних изменяемых ресурсов (файловая система, сеть, база данных) должна быть исключена или управляема.
* **Независимость:** Каждый UNIT-тест должен быть независим от других UNIT-тестов. Порядок выполнения тестов не должен влиять на их результат. Состояние, созданное одним тестом, не должно влиять на последующие тесты.
* **Быстрота выполнения:** UNIT-тесты должны выполняться максимально быстро. Время выполнения полного набора UNIT-тестов должно измеряться секундами или минутами, чтобы не тормозить процесс разработки и частые запуски в CI/CD.
* **Релевантность к требованиям безопасности:** Приоритет при написании UNIT-тестов должен отдаваться проверке тех аспектов кода, которые напрямую связаны с требованиями безопасности, функциями защиты, обработкой конфиденциальных данных и потенциальными "вопросами" со стороны органа по сертификации или ФСТЭК.
* **Трассируемость:** Должна быть обеспечена четкая связь между UNIT-тестом, тестируемой единицей кода и соответствующим требованием безопасности или "вопросом" сертификации/контроля. Эта связь облегчает демонстрацию покрытия требований тестами и анализ результатов аудиторам.
* **Читаемость и поддерживаемость:** Код UNIT-тестов должен быть чистым, понятным и хорошо документированным. Тесты должны легко читаться инженерами, не знакомыми с тестируемым кодом, чтобы обеспечить их актуальность и поддерживаемость на протяжении всего жизненного цикла ПО.
* **Полное покрытие (насколько практически возможно):** Стремление к максимальному покрытию кода UNIT-тестами, особенно критически важных для безопасности модулей. Покрытие должно оцениваться не только по строкам кода, но и по ветвлениям, условиям, путям выполнения.

## 5. Методология Создания UNIT-тестов для Вопросов Сертификации

Процесс создания UNIT-тестов, ориентированных на специфику сертификации ФСТЭК, включает следующие этапы:

### 5.1. Этап 1: Анализ Требований и Формализация "Вопросов"

Этот этап является критически важным и специфичным для данного контекста. Необходимо преобразовать формальные требования безопасности и потенциальные неформализованные "вопросы" аудиторов в конкретные, проверяемые технические утверждения.

#### 5.1.1. Идентификация Применимых Требований Безопасности

Анализируются документы, определяющие требования к ПО:
* Нормативные документы ФСТЭК России (например, требования к уровням доверия, профили защиты).
* Техническое задание на создание системы защиты информации или техническое задание на ПО.
* Эксплуатационная документация на ПО, описывающая функции безопасности.
* Технические условия (ТУ) на ПО.
* Иные применимые стандарты или политики безопасности.

Из этих документов извлекаются конкретные, верифицируемые требования к поведению ПО или его компонентов, связанные с безопасностью.

#### 5.1.2. Декомпозиция Требований до Уровня Модулей/Функций

Каждое идентифицированное требование безопасности декомпозируется до уровня конкретных модулей, классов или функций исходного кода, которые реализуют данное требование или влияют на его выполнение. Устанавливается трассируемость: какое требование реализуется/обеспечивается каким компонентом кода.

#### 5.1.3. Формализация "Вопросов" Сертификации/Контроля

Анализируется опыт предыдущих сертификаций, типовые методики испытаний органов по сертификации, возможные векторы атак и риски безопасности, характерные для данного типа ПО. Формулируются конкретные сценарии проверки или "вопросы", которые могут быть заданы в процессе сертификации или инспекционного контроля. Эти "вопросы" преобразуются в проверяемые технические утверждения о поведении ПО или его компонентов.

Примеры "вопросов", формализуемых для UNIT-тестирования:
* Корректность применения мандатного атрибута при доступе к объекту на уровне функции ядра безопасности.
* Правильность генерации уникального идентификатора сессии при входе пользователя.
* Стойкость функции хеширования пароля к коллизиям при использовании стандартных входных данных.
* Блокировка учетной записи после N неуспешных попыток аутентификации в соответствующем модуле.
* Корректность обработки ошибок при доступе к защищаемому ресурсу с недостаточными привилегиями.
* Отсутствие возможности обхода проверки целостности для конфигурационного файла в соответствующем парсере.

#### 5.1.4. Создание Матрицы Трассируемости

Разрабатывается матрица трассируемости, связывающая требования безопасности (из нормативных документов, ТЗ и ТУ), формализованные "вопросы" сертификации/контроля, и конкретные единицы кода (модули, функции), которые их реализуют. Эта матрица будет основой для определения приоритетов тестирования и демонстрации покрытия требований.

| Идентификатор Требования (Документ) | Описание Требования Безопасности | Формализованный "Вопрос" Сертификации/Контроля | Идентифицированная Единица Кода (Модуль/Функция) | Описание Связи/Реализации |
|---|---|---|---|---|
| РД.СЗИ.ТР.2012 п.4.1 | Обеспечение аутентификации пользователей. | Как система проверяет учетные данные пользователя при входе? | `AuthManager.authenticate(username, password)` | Метод `authenticate` выполняет основную проверку учетных данных. |
| ТУ.ПО.Глава 3.2 | Контроль целостности исполняемых файлов. | Как ПО проверяет целостность своих компонентов при запуске? | `IntegrityChecker.checkFileSignature(filePath, expectedSignature)` | Метод `checkFileSignature` выполняет проверку подписи файла. |
| "Вопрос" Аудитора 1.1 | Устойчивость к подбору пароля. | Как функция хеширования обрабатывает пустые или слишком короткие пароли? | `PasswordHasher.hashPassword(password, salt)` | Метод `hashPassword` должен возвращать ошибку или использовать специфичный алгоритм для таких случаев. |

### 5.2. Этап 2: Проектирование UNIT-тестов

На основе результатов анализа и матрицы трассируемости разрабатываются детальные планы UNIT-тестов.

#### 5.2.1. Определение Тестируемых Единиц

Для каждой записи в матрице трассируемости, связанной с кодом, определяется конкретная тестируемая единица (Unit Under Test, UUT) — это может быть отдельный метод, функция или небольшой класс.

#### 5.2.2. Определение Тестовых Сценариев

Для каждой UUT и связанного с ней требования/вопроса разрабатываются тестовые сценарии. Сценарий описывает последовательность действий, необходимых для проверки конкретного аспекта поведения UUT. Сценарии должны охватывать:
* **Позитивные сценарии:** Проверка корректного выполнения функции при валидных входных данных и условиях, соответствующих требованиям безопасности.
* **Негативные сценарии:** Проверка поведения UUT при некорректных, граничных, заведомо опасных или неожидаемых входных данных и условиях (например, некорректные учетные данные, попытка доступа без прав, превышение лимитов, специальные символы в полях ввода, имитация сбоев зависимостей). Особое внимание уделяется сценариям, имитирующим попытки нарушения безопасности.
* **Сценарии обработки исключений:** Проверка корректной реакции UUT на ошибки или исключительные ситуации, возникающие во время выполнения, включая ошибки, связанные с безопасностью (например, неверный формат ключа шифрования, попытка десериализации недоверенных данных).

#### 5.2.3. Определение Входных Данных и Ожидаемых Результатов

Для каждого тестового сценария определяются:
* **Предусловия (Arrange):** Состояние системы или UUT до начала выполнения теста. Включает настройку зависимостей, инициализацию объектов, подготовку тестовых данных (например, создание тестового пользователя, настройка имитатора базы данных).
* **Входные данные (Act):** Конкретные значения параметров или последовательность вызовов, применяемых к UUT.
* **Ожидаемые результаты (Assert):** Точные ожидаемые выходные данные, возвращаемые значения, изменения состояния UUT или его зависимостей, сгенерированные исключения или события. Ожидаемый результат должен быть строго определен на основе требований безопасности и спецификации поведения UUT.

Пример для формализованного "вопроса": "Как функция хеширования пароля обрабатывает пустые или слишком короткие пароли?"
* **UUT:** Метод `PasswordHasher.hashPassword(password, salt)`.
* **Сценарий:** Передача пустой строки в качестве пароля.
* **Входные данные:** `password=""`, `salt="some_salt"`.
* **Ожидаемый результат:** Должно быть сгенерировано исключение типа `InvalidPasswordFormatException` с определенным сообщением или возвращен специфический код ошибки, согласно спецификации реализации безопасности.

#### 5.2.4. Определение Необходимых Имитаторов, Заглушек и Фейков

Для изоляции UUT определяются зависимости, которые необходимо заменить на тестовые двойники:
* **Заглушка (Stub):** Предоставляет заранее определенные ответы на вызовы во время теста, не содержат никакой логики, кроме возврата зафиксированных значений. Используются для управления поведением зависимостей, необходимых для выполнения UUT.
* **Имитатор (Mock):** Позволяет верифицировать, что UUT правильно взаимодействует со своими зависимостями, проверяя, были ли вызваны определенные методы зависимостей с ожидаемыми параметрами и сколько раз. Используются для проверки взаимодействия, а не только возвращаемых значений.
* **Фейк (Fake):** Упрощенная реализация зависимости с рабочей логикой (например, in-memory база данных вместо реальной). Используются, когда заглушки или имитаторы недостаточны, но не требуется полная функциональность реальной зависимости.

Выбор типа тестового двойника зависит от того, какой аспект взаимодействия UUT с зависимостью тестируется: возвращаемое значение, факт вызова метода, параметры вызова.

### 5.3. Этап 3: Реализация UNIT-тестов

На этом этапе происходит непосредственное написание кода UNIT-тестов с использованием выбранного фреймворка.

#### 5.3.1. Выбор Фреймворка для UNIT-тестирования

Выбирается подходящий фреймворк для UNIT-тестирования, соответствующий языку программирования ПО. Примеры:
* Java: JUnit, TestNG
* C#: NUnit, xUnit.net, MSTest
* Python: unittest, pytest, nose
* C++: Google Test, Catch2, Boost.Test
* JavaScript: Jest, Mocha, Jasmine

Выбор фреймворка основывается на его возможностях, поддержке в среде разработки, наличии инструментов для работы с тестовыми двойниками, генерации отчетов и интеграции с CI/CD.

#### 5.3.2. Написание Кода Тестов

Код каждого UNIT-теста пишется в соответствии с разработанным тестовым сценарием, используя синтаксис и возможности выбранного фреймворка. Каждый тест должен соответствовать структуре Arrange-Act-Assert (AAA) или Given-When-Then (GWT):
* **Arrange (Given):** Подготовка тестового окружения, создание UUT, настройка тестовых двойников, подготовка входных данных.
* **Act (When):** Вызов тестируемого метода или функции UUT с подготовленными входными данными.
* **Assert (Then):** Проверка ожидаемого результата с использованием утверждений (assertions), предоставляемых фреймворком. Проверяется возвращаемое значение, состояние UUT, взаимодействие с имитаторами, выброшенные исключения.

#### 5.3.3. Использование Утверждений (Assertions)

Утверждения являются ядром UNIT-теста. Они сравнивают фактический результат выполнения UUT с ожидаемым результатом. Примеры утверждений:
* Равно ли фактическое значение ожидаемому (`assertEqual`, `assertEquals`).
* Истинно ли условие (`assertTrue`).
* Ложно ли условие (`assertFalse`).
* Равен ли объект null (`assertNull`).
* Не равен ли объект null (`assertNotNull`).
* Было ли выброшено ожидаемое исключение (`assertThrows`).
* Соответствует ли строка регулярному выражению.
* Содержатся ли определенные элементы в коллекции.

При тестировании безопасности утверждения должны быть максимально точными и проверять конкретные свойства:
* Корректность применения криптографического преобразования.
* Строгое соответствие формату данных после sanitization или validation.
* Факт отказа в доступе при нехватке прав.
* Корректный код ошибки или сообщение при неудачной операции безопасности.
* Отсутствие конфиденциальных данных в логах, если это запрещено.

#### 5.3.4. Реализация Тестовых Двойников

Создаются заглушки, имитаторы и фейки для изоляции UUT. Используются специализированные библиотеки для мокирования (например, Mockito, Moq, unittest.mock).

| Элемент | Техническое Описание | Назначение в UNIT-тесте | Применимость в Контексте ФСТЭК | Влияние на Результат Теста | Последствия Игнорирования |
|---|---|---|---|---|---|
| **Заглушка (Stub)** | Объекты, предоставляющие предопределенные ответы на вызовы методов в ходе теста. | Управление поведением зависимостей для создания специфических тестовых сценариев. | Имитация ответов от внешних систем (СУБД, сетевые сервисы), криптографических модулей, системных вызовов, которые могут иметь специфику, важную для требований безопасности. | Обеспечивает, что UUT получает ожидаемые входные данные или результаты операций от зависимостей, позволяя проверить его логику в конкретных условиях. | Тест становится зависимым от реальных зависимостей, что делает его неизолированным, медленным, ненадежным (флуктуации внешних систем) и сложным в воспроизведении специфических ошибочных или граничных сценариев, критичных для безопасности. |
| **Имитатор (Mock)** | Объекты, на которые устанавливаются ожидания вызовов методов и их параметров. После выполнения UUT проверяется, были ли ожидания удовлетворены. | Верификация факта и корректности взаимодействия UUT с зависимостями. | Проверка вызова методов аудита событий безопасности, функций логирования, обращения к функциям разграничения доступа, вызовов методов очистки конфиденциальных данных. | Подтверждает, что UUT правильно вызывает необходимые функции безопасности или служебные методы зависимостей с правильными аргументами и в нужном порядке. | Невозможно верифицировать, что UUT инициирует требуемые действия безопасности (например, логирование неудачной попытки входа). Тесты будут проходить, даже если критически важные вызовы к зависимостям отсутствуют или некорректны. |
| **Фейк (Fake)** | Упрощенная рабочая реализация зависимости (например, in-memory база данных). | Предоставление функциональности зависимости в упрощенном виде для более реалистичного взаимодействия. | Имитация упрощенной файловой системы для тестирования контроля доступа к файлам, in-memory реализация хранилища учетных записей для тестов аутентификации/авторизации. | Позволяет тестировать UUT с зависимостями, которые имеют минимальную рабочую логику, приближенную к реальной, без необходимости развертывания полной реальной зависимости. | Приводит к необходимости использования реальной зависимости, что делает тест медленным, зависимым от внешнего состояния и может требовать сложной настройки тестового окружения (например, развертывание СУБД), что затрудняет автоматизацию и воспроизводимость. |

#### 5.3.5. Управление Тестовыми Данными

Тестовые данные для UNIT-тестов должны быть строго определены и управляемы.
* **Генерация данных:** Использование библиотек или собственной логики для генерации реалистичных, граничных и некорректных данных (например, валидные и невалидные пароли, корректные и некорректные цифровые подписи, данные разного размера, данные с инъекциями).
* **Хранение данных:** Тестовые данные должны храниться рядом с тестами, предпочтительно в коде тестов или в легко доступных ресурсах (JSON, XML, CSV файлы), интегрированных в систему сборки. Использование внешних баз данных или файловых ресурсов, требующих сложной настройки, должно быть минимизировано.
* **Очистка данных:** После выполнения теста состояние, созданное тестом (например, изменения в in-memory фейковой базе данных), должно быть очищено, чтобы не влиять на другие тесты. Используются механизмы фикстур фреймворка (setUp/tearDown, @BeforeEach/@AfterEach).

#### 5.3.6. Обработка Чувствительных Данных в Тестах

При тестировании компонентов, работающих с конфиденциальной информацией (пароли, ключи, персональные данные), необходимо строго соблюдать правила безопасности:
* Не использовать реальные конфиденциальные данные в тестах.
* Генерировать тестовые данные, имитирующие реальные по структуре и свойствам, но не имеющие реальной ценности.
* Не хранить чувствительные тестовые данные в открытом виде в репозитории исходного кода. Использовать безопасные механизмы для их генерации или получения в тестовом окружении.
* Убедиться, что трассировка и логирование тестов не содержат чувствительных данных.

### 5.4. Этап 4: Выполнение UNIT-тестов

Автоматизированное выполнение разработанных UNIT-тестов.

#### 5.4.1. Интеграция в Процесс Сборки

UNIT-тесты должны быть интегрированы в процесс автоматизированной сборки ПО (например, с использованием Maven, Gradle, MSBuild, CMake). Запуск UNIT-тестов должен выполняться автоматически при каждой сборке или при каждом коммите в систему контроля версий (VCS).

#### 5.4.2. Настройка Тестового Окружения

Тесты должны выполняться в контролируемом и повторяемом тестовом окружении. Это может быть выделенный сервер сборки, контейнер виртуализации (Docker) или виртуальная машина. Окружение должно содержать все необходимые зависимости, но при этом быть максимально изолированным от внешних систем, кроме тех, которые имитируются тестовыми двойниками.

#### 5.4.3. Регулярный Запуск Тестов

UNIT-тесты должны запускаться часто:
* При каждом коммите разработчиком (локально или на CI сервере).
* При каждом слиянии веток в VCS.
* Регулярно по расписанию (например, nightly builds).

Частый запуск тестов позволяет быстро выявлять регрессионные дефекты, в том числе связанные с безопасностью, внесенные последними изменениями в код.

### 5.5. Этап 5: Анализ Результатов и Отчетность

Результаты выполнения UNIT-тестов должны быть проанализированы, а выявленные дефекты — зафиксированы и устранены.

#### 5.5.1. Интерпретация Результатов

Результат каждого UNIT-теста — "успех" (Passed) или "неудача" (Failed).
* **Успех:** Ожидаемое поведение UUT подтверждено.
* **Неудача:** Фактическое поведение UUT отличается от ожидаемого. Необходимо проанализировать причину неудачи: ошибка в тестируемом коде, ошибка в коде теста, проблема с тестовыми данными, некорректная настройка тестового окружения.

#### 5.5.2. Анализ Неудачных Тестов

Причины неудач должны быть оперативно расследованы. Инструменты фреймворков предоставляют информацию о месте неудачи (строка кода теста и тестируемого модуля), трассировку стека, значения переменных. При необходимости используется пошаговая отладка теста и тестируемого кода.

#### 5.5.3. Фиксация Дефектов

Выявленные ошибки в тестируемом коде, приведшие к неудаче теста, должны быть зафиксированы в системе отслеживания дефектов (например, Jira, Redmine). Дефектам присваивается приоритет в зависимости от их критичности, особенно если они связаны с реализацией требований безопасности.

#### 5.5.4. Генерация Отчетов

Фреймворки UNIT-тестирования генерируют отчеты о выполнении тестов в различных форматах (JUnit XML, HTML). Отчеты должны содержать:
* Общее количество выполненных тестов.
* Количество успешных и неуспешных тестов.
* Список всех тестов, включая информацию о неудачных тестах (название теста, сообщение об ошибке, трассировка стека).
* Время выполнения тестов.

При использовании инструментов покрытия кода (Code Coverage) отчеты также должны включать метрики покрытия по строкам, ветвлениям, функциям.

#### 5.5.5. Связь Отчетов с Требованиями/Вопросами

С использованием матрицы трассируемости результаты UNIT-тестов связываются с соответствующими требованиями безопасности и формализованными "вопросами" сертификации/контроля. В отчеты может быть добавлена информация о покрытии требований тестами.

## 6. Технические Аспекты Реализации

### 6.1. Изоляция и Управление Зависимостями

Обеспечение строгой изоляции является краеугольным камнем UNIT-тестирования, особенно для компонентов безопасности. Зависимости, которые могут сделать тест непредсказуемым, медленным или требующим сложной настройки, должны быть заменены на тестовые двойники.

Примеры зависимостей, требующих имитации:
* Базы данных
* Файловая система
* Сетевые вызовы (HTTP, сокеты)
* Системное время
* Генераторы случайных чисел (для повторяемости)
* Взаимодействие с операционной системой (системные вызовы)
* Внешние библиотеки (особенно те, которые имеют побочные эффекты или требуют инициализации)
* Компоненты, работающие с аппаратным обеспечением (криптографические акселераторы, токены)

Выбор типа тестового двойника (stub, mock, fake) зависит от того, что необходимо проверить: возвращаемое значение (stub), взаимодействие (mock) или упрощенную функциональность (fake).

### 6.2. Тестирование Функций Безопасности на Уровне Модулей

UNIT-тесты особенно эффективны для проверки корректности реализации следующих функций безопасности на низком уровне:

* **Аутентификация:**
 * Проверка логики верификации учетных данных (пароль, сертификат, токен) при корректных и некорректных входных данных.
 * Тестирование обработки граничных случаев (пустые логин/пароль, недопустимые символы).
 * Проверка логики блокировки учетной записи после N неудачных попыток (если эта логика реализована в тестируемом модуле).
* **Авторизация/Разграничение Доступа:**
 * Проверка логики принятия решений о доступе к ресурсу на основе прав пользователя/роли/атрибутов.
 * Тестирование сценариев доступа с достаточными и недостаточными привилегиями.
 * Проверка корректности применения мандатных или дискреционных политик на уровне функции.
* **Контроль Целостности:**
 * Тестирование функций вычисления и проверки хеш-сумм, электронных подписей для различных типов данных.
 * Проверка обработки измененных или некорректных данных, подписей.
* **Криптографические Преобразования:**
 * UNIT-тесты могут проверять корректность вызова функций криптографических библиотек с правильными параметрами (ключи, векторы инициализации, режимы работы).
 * Тестирование шифрования/расшифрования небольших блоков данных.
 * Проверка генерации и верификации имитовставки.
 * Проверка генерации криптографически стойких случайных чисел (хотя полноценная криптографическая стойкость требует других методов анализа).
* **Аудит Событий Безопасности:**
 * Использование имитаторов для верификации того, что UUT генерирует ожидаемые события аудита в соответствующих сценариях (успешный/неудачный вход, попытка доступа к запрещенному ресурсу, изменение прав).
 * Проверка корректности передаваемых данных события аудита (идентификатор пользователя, время, тип события, результат операции).
* **Санитизация и Валидация Входных Данных:**
 * Тестирование функций очистки (sanitization) и проверки (validation) входных данных на наличие опасных конструкций (SQL-инъекции, XSS-скрипты, внедрение команд ОС).
 * Проверка обработки данных, содержащих специальные символы, некорректный формат, слишком длинные строки.
* **Обработка Конфиденциальной Информации:**
 * Тестирование функций, работающих с конфиденциальными данными (например, зануление памяти после использования, корректное удаление временных файлов, передача данных по защищенным каналам — верификация вызова соответствующих функций нижнего уровня).

### 6.3. Тестирование Конфигурации, Влияющей на Безопасность

Многие аспекты безопасности ПО зависят от его конфигурации. UNIT-тесты могут проверять:
* Корректность парсинга конфигурационных файлов, содержащих параметры безопасности (например, пути к ключевым файлам, настройки аудита, таймауты сессий).
* Правильность применения конфигурационных параметров логикой UUT.
* Поведение UUT при отсутствии или некорректных значениях критически важных параметров безопасности.

Использование фикстур для имитации различных конфигурационных сценариев является ключевым для данного типа тестов.

## 7. Инструменты и Фреймворки

Выбор инструментов для UNIT-тестирования определяется языком программирования и особенностями проекта. Ниже приведены категории инструментов и их роль:

| Категория Инструмента | Техническое Описание | Роль в Методике | Примеры (зависят от языка) | Ограничения/Риски |
|---|---|---|---|---|
| **Фреймворки UNIT-тестирования** | Библиотеки, предоставляющие структуры данных, синтаксис и исполнительную среду для написания и запуска UNIT-тестов (классы для организации тестов, методы утверждений, аннотации/атрибуты для управления жизненным циклом тестов). | Ядро процесса тестирования. Обеспечивают структуру для организации тестового кода, механизмы для определения тестовых случаев, выполнения тестов и проверки результатов с использованием утверждений. | JUnit, TestNG (Java); NUnit, xUnit.net (C#); pytest, unittest (Python); Google Test (C++); Jest, Mocha (JS). | Требуют изучения синтаксиса и особенностей конкретного фреймворка. Могут иметь ограничения в поддержке специфичных сценариев или языковых конструкций. |
| **Библиотеки для Имитации (Mocking)** | Библиотеки, облегчающие создание тестовых двойников (заглушек, имитаторов, фейков) путем динамической генерации классов или перехвата вызовов методов. | Позволяют изолировать тестируемую единицу от ее зависимостей, упрощают создание контролируемых тестовых сценариев и верификацию взаимодействий. | Mockito, PowerMock (Java); Moq, NSubstitute (C#); unittest.mock (Python); Google Mock (C++); Sinon.JS, Jest Mocks (JS). | Некорректное использование может привести к созданию тестов, проверяющих взаимодействие с имитатором, а не реальную логику UUT. Мокирование статических методов, приватных полей может быть сложным или требовать специальных инструментов. |
| **Инструменты Покрытия Кода (Code Coverage)** | Программы, анализирующие выполнение UNIT-тестов и определяющие, какие строки, ветвления, функции исходного кода были выполнены в процессе тестирования. | Предоставляют метрики для оценки полноты набора UNIT-тестов. Помогают выявлять непроверенные участки кода, особенно критичные для безопасности. | JaCoCo (Java); OpenCover, Coverlet (C#); Coverage.py (Python); gcov, lcov (C++); Istanbul (JS). | Высокий процент покрытия не гарантирует отсутствие дефектов или покрытие всех сценариев безопасности. Покрытие по строкам недостаточно, необходимо анализировать покрытие по ветвлениям и условиям. |
| **Системы Непрерывной Интеграции (CI)** | Серверные приложения, автоматизирующие процесс сборки, тестирования и развертывания кода при каждом изменении в системе контроля версий. | Обеспечивают автоматический и регулярный запуск UNIT-тестов. Быстро предоставляют обратную связь разработчикам о появлении дефектов, включая связанные с безопасностью, после внесения изменений. | Jenkins, GitLab CI, GitHub Actions, TeamCity, Azure DevOps. | Требуют настройки интеграции с репозиторием кода, фреймворками тестирования и инструментами отчетности. Некорректная настройка может привести к ложноположительным или ложноотрицательным результатам. |

## 8. Типовые Ошибки и Пути их Предотвращения

| Типовая Ошибка | Описание Ошибки | Последствия в Контексте ФСТЭК | Пути Предотвращения |
|---|---|---|---|
| **Недостаточная Изоляция** | UNIT-тест зависит от реальных зависимостей (база данных, файловая система, сеть) или состояния других тестов. | Тесты становятся ненадежными, результаты могут флуктуировать. Невозможно воспроизвести специфические сценарии (например, ошибки сети, отказ доступа к ресурсу), критичные для проверки механизмов безопасности. Тесты выполняются медленно, что затрудняет их частый запуск. | Обязательное использование тестовых двойников (заглушек, имитаторов) для всех внешних зависимостей. Применение фикстур для сброса состояния перед каждым тестом. |
| **Неполное Покрытие Сценариев Безопасности** | UNIT-тесты написаны только для "счастливого пути" выполнения кода, игнорируются негативные, граничные и ошибочные сценарии, критичные с точки зрения безопасности (например, некорректные входные данные, недостаточные привилегии). | Критически важные дефекты безопасности могут остаться необнаруженными на ранних этапах разработки. Аудиторы в процессе сертификации или контроля могут выявить необнаруженные уязвимости. | Тщательный анализ требований безопасности и формализованных "вопросов". Целенаправленное проектирование тестовых сценариев для негативных, граничных и ошибочных условий, связанных с безопасностью. Использование техник тестирования черного ящика (анализ эквивалентных классов, анализ граничных значений) при проектировании тестов. |
| **Слишком Крупные "Единицы" для Тестирования** | Тестируются слишком большие блоки кода (несколько классов, модулей), что затрудняет изоляцию и определение источника ошибки. | При неудаче теста сложно локализовать дефект до конкретной функции или строки кода. Тесты становятся ближе к интеграционным, теряя преимущества UNIT-тестирования (быстрота, точность локализации). | Строгое соблюдение принципа UNIT-тестирования: тестировать минимальные изолируемые блоки кода (отдельные методы, функции, небольшие классы). Декомпозиция комплексной логики на более мелкие, тестируемые единицы. |
| **Отсутствие Связи Тестов с Требованиями/Вопросами** | UNIT-тесты создаются без явной привязки к конкретным требованиям безопасности или потенциальным "вопросам" сертификации. | Невозможно продемонстрировать полноту покрытия требований тестами. Сложно аргументировать аудиторам, почему именно эти тесты были написаны и как они подтверждают безопасность ПО. | Ведение и актуализация матрицы трассируемости (требования -> код -> тесты). Использование аннотаций/комментариев в коде тестов для указания связи с требованиями (например, `@Requirement("РД.СЗИ.ТР.2012 п.4.1")`, `@FSTECQuestion("Аутентификация: пустой пароль")`). |
| **Тесты Зависят от Окружения или Внешних Факторов** | Тесты зависят от системного времени, порядка выполнения, наличия сетевого подключения, специфических настроек ОС. | Тесты становятся невоспроизводимыми и ненадежными ("флуктуирующие тесты"). Результаты могут отличаться при запуске на разных машинах или в разное время. | Использование имитаторов для зависимостей, предоставляющих системное время или случайные числа. Управление порядком выполнения тестов (если это возможно и необходимо, хотя лучше избегать зависимости от порядка). Замена сетевых вызовов и файловых операций на тестовые двойники. |
| **Недостаточно Детальные Утверждения** | Утверждения проверяют только факт успешного выполнения, но не проверяют корректность возвращаемых данных, изменение состояния или взаимодействие с зависимостями в полном объеме, требуемом спецификацией безопасности. | Тест может проходить, даже если функция выполнена некорректно с точки зрения безопасности (например, зашифрованы неверные данные, некорректно сформирован аудит). | Использование полных и точных утверждений, проверяющих все аспекты ожидаемого поведения: возвращаемое значение, состояние объекта, параметры вызовов к имитаторам, выброшенные исключения, содержимое коллекций. Утверждения должны базироваться на формальных спецификациях. |
| **Сложность Тестового Кода** | Код UNIT-тестов сложен, содержит дублирование, трудночитаем и поддерживаем. | Тесты становятся хрупкими, их сложно изменять при рефакторинге кода. Увеличивается вероятность ошибок в самих тестах. Затрудняется верификация корректности тестов. | Применение принципов чистого кода к тестовому коду. Рефакторинг тестового кода. Использование общих фикстур и вспомогательных методов для устранения дублирования. Тестовый код должен быть проще тестируемого. |

## 9. Верификация UNIT-тестов и Документирование

### 9.1. Верификация Корректности UNIT-тестов

Сами UNIT-тесты могут содержать ошибки (например, некорректные утверждения, неправильная настройка имитаторов), что может привести к ложноположительным (тест проходит, хотя в коде есть дефект) или ложноотрицательным (тест не проходит, хотя код корректен) результатам. Для верификации тестов применяются следующие подходы:

* **Анализ Покрытия Кода:** Высокий процент покрытия кода, особенно по ветвлениям и условиям, косвенно свидетельствует о том, что большинство путей выполнения кода проверено тестами. Низкое покрытие указывает на пробелы, которые могут быть источником ошибок в тестах или тестируемом коде.
* **Мутационное Тестирование (Mutation Testing):** Инструменты мутационного тестирования вносят небольшие, синтаксически корректные изменения (мутации) в исходный код ПО (например, заменяют оператор `>`, на `<`, изменяют константу, удаляют вызов метода). Затем запускаются UNIT-тесты. Если UNIT-тесты корректны и покрывают измененный код, большинство мутаций должны привести к падению одного или нескольких тестов ("мутация убита"). Если мутация не убита, это может свидетельствовать о недостатке в UNIT-тестах (тесты не проверяют измененную логику) или ошибке в самой мутации.
* **Code Review Тестового Кода:** Проведение анализа (ревью) кода UNIT-тестов другими инженерами для выявления логических ошибок, некорректных утверждений, проблем с изоляцией или читаемостью.
* **Парное Программирование при Написании Тестов:** Написание тестов в парах способствует немедленному обсуждению и выявлению потенциальных ошибок в логике теста или проверяемых утверждениях.

### 9.2. Документирование Процесса и Результатов UNIT-тестирования

Документация по UNIT-тестированию является важной частью доказательной базы для аудиторов ФСТЭК. Должны быть документированы:

* **Методика Тестирования:** Настоящий документ является основой для описания подхода к UNIT-тестированию.
* **Матрица Трассируемости:** Документ, связывающий требования безопасности, формализованные "вопросы" и UNIT-тесты. Демонстрирует покрытие требований тестами.
* **Планы UNIT-тестов:** Описание разработанных тестовых сценариев, входных данных, ожидаемых результатов для критически важных модулей, если это требует дополнительной детализации сверх кода теста.
* **Код UNIT-тестов:** Исходный код самих тестов, являющийся основным и наиболее точным описанием проверок. Код должен быть снабжен комментариями, объясняющими неочевидные моменты, особенно связанные со спецификой проверок безопасности.
* **Отчеты о Выполнении Тестов:** Автоматически сгенерированные отчеты о каждом запуске набора UNIT-тестов, содержащие результаты (успех/неудача), информацию о покрытии кода.
* **Информация о Тестовом Окружении:** Описание тестового окружения, в котором выполняются тесты, включая версии используемых инструментов (фреймворк, библиотеки мокирования), конфигурацию среды выполнения.
* **Процедуры Выполнения Тестов:** Описание процесса запуска UNIT-тестов (например, команды сборки и тестирования), интегрированного в CI/CD.
* **Результаты Анализа Дефектов:** Фиксация выявленных в результате UNIT-тестирования дефектов, их связь с требованиями безопасности, статус устранения.

Вся документация должна быть актуальной, точной и доступной для аудита.

## 10. Заключение

UNIT-тестирование, систематически применяемое и сфокусированное на вопросах безопасности и требованиях регуляторов, является мощным инструментом обеспечения качества и подтверждения соответствия программного обеспечения в процессе сертификации ФСТЭК и инспекционного контроля. Данная методика предоставляет структурированный инженерный подход к созданию эффективных, воспроизводимых и верифицируемых UNIT-тестов, позволяя на ранних этапах разработки выявлять и устранять дефекты, критичные для безопасности информации. Строгое следование описанным принципам и этапам, а также должное документирование процесса и результатов тестирования, способствует построению надежной доказательной базы для успешного прохождения процедур оценки соответствия.
