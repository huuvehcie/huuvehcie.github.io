# Методика создания UNIT-тестов для вопросов проведения сертификации ПО во ФСТЭК и инспекционного контроля

## 1. Введение

Этот документ объясняет, как писать UNIT-тесты для компьютерных программ. Эти тесты помогают убедиться, что программа работает правильно, особенно в тех частях, которые важны для получения специального разрешения ФСТЭК России или при последующих проверках.

Мы подготовили эту методику для инженеров — людей, которые пишут программы или проверяют их работу. Она поможет создать автоматические тесты для проверки отдельных кусочков программы. Такие тесты нужны, чтобы найти ошибки и убедиться, что программа соответствует требованиям безопасности. Это особенно важно, когда программу проверяют для сертификации или во время инспекционного контроля.

Наша цель — дать понятные шаги для написания тестов, которые можно повторить и которые покажут, что отдельные части программы работают так, как ожидается, особенно в ситуациях, связанных с безопасностью информации.

## 2. Глоссарий Терминов

Здесь мы объясним специальные слова, которые используются в этом документе:

* **UNIT-тест (Юнит-тест):** Автоматический тест, который проверяет самую маленькую, отдельно работающую часть программы (например, одну функцию или один метод в классе). Цель — убедиться, что этот маленький кусочек кода работает правильно сам по себе, независимо от других частей программы.
* **Программное Обеспечение (ПО):** Набор компьютерных программ и связанных с ними данных.
* **ФСТЭК России:** Федеральная служба по техническому и экспортному контролю. Это государственный орган в России, который занимается защитой информации и контролем за экспортом. Он выдает специальные разрешения (сертификаты) на использование программ и оборудования, если они соответствуют требованиям безопасности.
* **Сертификация ПО во ФСТЭК:** Процедура, когда специальная лаборатория, аккредитованная ФСТЭК, проверяет программу на соответствие требованиям безопасности. Если программа проходит проверку, ФСТЭК выдает сертификат, который разрешает использовать эту программу в информационных системах с определенными требованиями к защите.
* **Инспекционный Контроль:** Периодические проверки, которые ФСТЭК или аккредитованная лаборатория проводят уже после выдачи сертификата. Цель — убедиться, что сертифицированная программа продолжает соответствовать требованиям безопасности, особенно если в нее вносились изменения.
* **Вопросы проведения сертификации/инспекционного контроля:** Конкретные проверки, задания или требования к программе, которые используют эксперты ФСТЭК или лаборатории во время сертификации или контроля. Эти вопросы могут касаться работы функций безопасности, обработки данных, структуры кода и других аспектов, важных для безопасности.
* **Требования безопасности информации:** Правила и условия, которым должна соответствовать программа, чтобы считаться безопасной. Эти требования описаны в специальных документах ФСТЭК, государственных стандартах или технических заданиях. Они могут касаться, например, того, как программа должна защищать данные пользователей, как она должна проверять, кто имеет право доступа к информации, как она должна регистрировать важные события.
* **Функции безопасности:** Части программы, специально созданные для обеспечения безопасности. Это могут быть функции для входа пользователей (аутентификация), проверки их прав (авторизация), шифрования данных, контроля целостности файлов, регистрации событий (аудит).
* **Недекларированные возможности:** Скрытые, не описанные в документации функции программы, которые могут быть использованы злоумышленниками для нарушения безопасности. В процессе сертификации проверяется их отсутствие.
* **Трассируемость:** Возможность установить связь между разными элементами проекта. Например, связь между конкретным требованием безопасности, частью кода, которая его реализует, и UNIT-тестом, который эту часть кода проверяет. Это важно для доказательства, что все требования учтены и проверены.
* **Тестовый сценарий:** Описание последовательности действий и условий, которые нужно выполнить для проверки конкретного аспекта работы программы. Включает входные данные, ожидаемые действия программы и ожидаемый результат.
* **Тестовые двойники:** Объекты, которые используются в UNIT-тестах вместо реальных зависимостей (других частей программы, баз данных, сетевых сервисов). Они нужны, чтобы тестировать только один конкретный кусочек кода в изоляции. Существуют разные типы тестовых двойников:
 * **Заглушка (Stub):** Простой тестовый двойник, который просто возвращает заранее заданные значения в ответ на вызовы. Используется, чтобы тестируемый код получил нужные ему "входные данные" от своих зависимостей.
 * **Имитатор (Mock):** Более сложный тестовый двойник. На него заранее "настраиваются" ожидания — какие его методы должны быть вызваны тестируемым кодом и с какими параметрами. После выполнения тестируемого кода имитатор проверяет, были ли эти ожидания выполнены. Используется для проверки того, как тестируемый код взаимодействует с другими частями.
 * **Фейк (Fake):** Упрощенная, но работающая версия реальной зависимости (например, простая база данных в памяти вместо настоящей базы данных). Используется, когда нужна минимальная рабочая логика зависимости.
* **Утверждение (Assertion):** Проверка в UNIT-тесте, которая сравнивает фактический результат работы кода с ожидаемым результатом. Если они совпадают, утверждение считается истинным, и тест продолжается или завершается успешно. Если нет — утверждение ложно, и тест падает.
* **Фикстура (Fixture):** Код, который подготавливает тестовое окружение перед выполнением теста (например, создает нужные объекты, настраивает тестовые двойники) и очищает его после выполнения теста. Обеспечивает одинаковые стартовые условия для каждого теста.
* **UUT (Unit Under Test):** Сокращение от "Unit Under Test" — единица под тестированием. Это конкретная часть кода (функция, метод, класс), которую проверяет данный UNIT-тест.
* **Arrange-Act-Assert (AAA):** Популярная структура написания UNIT-тестов, состоящая из трех шагов: Arrange (Подготовка) — настройка всего необходимого для теста; Act (Действие) — выполнение тестируемого кода; Assert (Проверка) — проверка результата с помощью утверждений.
* **Given-When-Then (GWT):** Другая структура для тестов, похожая на AAA, часто используется в поведении-ориентированном тестировании. Given (Дано) — описание начального состояния; When (Когда) — описание действия; Then (Тогда) — описание ожидаемого результата.
* **CI/CD (Continuous Integration / Continuous Delivery):** Подходы в разработке программ, которые включают автоматическую сборку, тестирование и развертывание кода каждый раз, когда разработчики вносят изменения. UNIT-тесты являются важной частью этого процесса.
* **Покрытие кода (Code Coverage):** Метрика, показывающая, какая часть исходного кода программы была выполнена во время запуска тестов. Измеряется в процентах по строкам кода, ветвлениям (условиям if/else), функциям.
* **Мутационное тестирование (Mutation Testing):** Способ проверки качества самих UNIT-тестов. Специальная программа вносит небольшие изменения (мутации) в исходный код программы. Затем запускаются UNIT-тесты. Если хороший UNIT-тест есть для этого участка кода, он должен "сломаться" из-за мутации (тест "убивает" мутацию). Если тест не ломается, возможно, он не проверяет этот аспект кода.

## 3. Контекст: Сертификация ПО во ФСТЭК и Инспекционный Контроль

Сертификация во ФСТЭК — это как экзамен для вашей программы, где проверяют, насколько она безопасна. ФСТЭК или специальные лаборатории смотрят не только, работает ли программа по инструкции, но и защищает ли она информацию, нет ли в ней скрытых опасных функций (недекларированных возможностей) и правильно ли реализованы все механизмы защиты.

"Вопросы" на таком экзамене и при последующих проверках (инспекционном контроле) — это конкретные задания или вещи, которые эксперты будут проверять в вашей программе. Например:
* Правильно ли программа определяет, кто пользователь, когда он входит в систему (аутентификация).
* Правильно ли она решает, к каким данным или функциям пользователь имеет доступ (авторизация).
* Как программа работает с важными данными — шифрует ли их, проверяет ли, что их никто не изменил (контроль целостности).
* Регистрирует ли программа важные события, например, попытки входа с неправильным паролем (аудит безопасности).
* Нет ли в программе простых способов обойти защиту.

Инспекционный контроль — это повторные проверки уже после того, как программа получила сертификат. Они смотрят, не появились ли проблемы с безопасностью после того, как вы внесли в программу изменения. Вопросы контроля часто связаны с этими изменениями.

## 4. Зачем Нужны UNIT-тесты в Контексте ФСТЭК

UNIT-тесты — это не просто стандартная практика хорошей разработки. В ситуации с сертификацией ФСТЭК они становятся очень важным инструментом:

* **Найти проблемы рано:** Они помогают найти ошибки в самых маленьких частях программы, которые связаны с безопасностью. Это лучше, чем искать их позже, когда все части собраны вместе.
* **Проверить конкретные требования:** UNIT-тесты позволяют точно проверить, правильно ли реализованы отдельные правила безопасности или функции защиты, которые требуются документами ФСТЭК или техническим заданием.
* **Показать, что программа работает:** Автоматические UNIT-тесты дают понятное и repeatable доказательство того, что конкретный кусочек кода делает то, что должен, даже в сложных или потенциально опасных ситуациях, которые могут проверить аудиторы ФСТЭК.
* **Упростить проверки:** Если у вас есть хороший набор UNIT-тестов для важных частей программы, это поможет легче пройти инспекционный контроль. Вы можете показать, что даже после изменений эти критичные функции безопасности продолжают работать правильно.
* **Сделать код лучше:** Написание UNIT-тестов часто заставляет разработчиков писать более аккуратный код, который легче менять и в котором меньше вероятность появления ошибок.

UNIT-тесты не могут проверить *все* аспекты безопасности (например, они не найдут проблемы, связанные с тем, как разные части программы взаимодействуют, или проблемы в настройке всей системы), но они дают надежную основу и проверяют правильность работы отдельных важных компонентов.

## 5. Как Создавать UNIT-тесты для Вопросов Сертификации: Пошаговая Методика

Создание UNIT-тестов, полезных для сертификации ФСТЭК, включает несколько шагов. Важно пройти их все последовательно.

### 5.1. Шаг 1: Понять Требования и Превратить "Вопросы" в Задачи для Тестов

Этот шаг самый специфичный для сертификации ФСТЭК. Нужно взять формальные требования безопасности и то, что могут спросить аудиторы, и превратить это в конкретные, проверяемые задания для тестов.

#### 5.1.1. Найти Правила Безопасности, Которые Касаются Вашей Программы

Прочитайте все документы, которые говорят о безопасности вашей программы:
* Документы ФСТЭК (например, о том, насколько "доверенной" должна быть программа).
* Техническое задание — там может быть раздел про защиту информации.
* Описание того, как программа работает с точки зрения пользователя, особенно про функции безопасности.
* Технические условия на программу.
* Другие важные стандарты или правила.

Из этих документов нужно выписать все конкретные требования к тому, как программа должна себя вести, что она должна делать или не делать, связанное с безопасностью. Например, требование "Система должна требовать сложный пароль".

#### 5.1.2. Определить, Какой Код Выполняет Эти Правила

Для каждого найденного требования безопасности нужно понять, какая именно часть программы (какой модуль, класс, функция) отвечает за выполнение этого требования. Установите связь: вот это требование, а вот этот код его реализует.

#### 5.1.3. Сформулировать "Вопросы" Аудиторов Как Проверки Кода

Подумайте, что будут проверять эксперты во время сертификации или контроля, основываясь на требованиях безопасности и типовых проверках. Превратите эти возможные "вопросы" в конкретные технические проверки для вашего кода.

Например, если требование: "Система должна блокировать пользователя после нескольких неудачных попыток входа", возможный "вопрос" аудитора: "Что произойдет, если пользователь 5 раз подряд введет неверный пароль?". Этот "вопрос" можно превратить в задачу для UNIT-теста: "Проверить, что функция, отвечающая за проверку пароля, после 5 неверных попыток вызывает другую функцию, которая блокирует учетную запись".

Другие примеры "вопросов", которые становятся задачами для тестов:
* Как функция обработки пользовательского ввода реагирует на ввод специальных символов, которые могут быть использованы для атаки (например, `<script>`).
* Правильно ли функция шифрования использует предоставленный ключ.
* Вызывает ли функция входа в систему функцию регистрации событий безопасности при неудачной попытке входа.
* Как модуль управления доступом реагирует, если пользователь пытается получить доступ к данным, на которые у него нет прав.

#### 5.1.4. Сделать Таблицу Связей

Создайте таблицу, которая связывает требования безопасности, формализованные "вопросы" и конкретные части вашего кода, которые вы будете тестировать. Это как карта, которая показывает, какой тест что проверяет и какое правило безопасности при этом затрагивается.

| Что Требуется (Документ) | Описание Правила Безопасности | Что Могут Спросить Аудиторы (Формализовано) | Какая Часть Кода за Это Отвечает | Примечание (Как Код Связан с Правилом) |
| :--- | :--- | :--- | :--- | :--- |
| РД ФСТЭК, Требование 3.1 | Проверка подлинности пользователя при входе. | Как система проверяет логин и пароль? | Модуль `UserAuthentication`, метод `checkPassword`. | Этот метод содержит основную логику сравнения введенного пароля с сохраненным. |
| ТЗ на систему, Раздел 4.5 | Запись всех неудачных попыток входа. | Фиксируются ли неудачные попытки в журнале? | Модуль `SecurityLogger`, метод `logEvent`. | Метод `checkPassword` должен вызвать `logEvent` при ошибке. |
| Возможный Вопрос Сертификации | Устойчивость к перебору паролей. | Что происходит, если пароль пустой или очень короткий? | Модуль `PasswordValidator`, метод `validateFormat`. | Этот метод должен отклонить такие пароли перед проверкой. |

Эта таблица поможет не пропустить ничего важного и покажет проверяющим, что вы серьезно подошли к тестированию безопасности.

### 5.2. Шаг 2: Спланировать, Какие Именно Тесты Нужно Написать

Теперь, зная, что нужно проверить (из Шага 1), спланируйте, как вы это сделаете с помощью UNIT-тестов.

#### 5.2.1. Выбрать, Какие Кусочки Кода Будем Тестировать

Для каждой строчки в вашей таблице связей, которая указывает на код, определите конкретный "юнит под тестированием" (UUT) — это может быть один метод в классе или одна функция.

#### 5.2.2. Придумать Сценарии для Проверки

Для каждого UUT и связанного с ним правила или "вопроса" придумайте тестовые сценарии. Сценарий — это мини-история о том, как вы будете использовать UUT, чтобы проверить конкретную ситуацию. Сценарии должны включать:
* **Что должно работать (позитивные сценарии):** Проверки того, что UUT правильно выполняет свою функцию при нормальных условиях (например, проверка пароля проходит для правильного пароля).
* **Что не должно работать или как должна обрабатываться ошибка (негативные сценарии):** Проверки, что UUT правильно реагирует на неправильные или опасные входные данные или ситуации (например, проверка пароля проваливается для неправильного пароля; функция обработки ввода удаляет опасные символы). Особое внимание уделите сценариям, имитирующим попытки обойти защиту.
* **Как обрабатываются непредвиденные ситуации (сценарии исключений):** Проверки того, как UUT ведет себя, если что-то идет не так, например, получает данные в неправильном формате или не может получить доступ к нужному ресурсу.

#### 5.2.3. Определить, Что Дать на Вход и Что Ожидать на Выходе

Для каждого тестового сценария точно опишите:
* **Подготовка (Arrange):** Что должно быть готово до начала теста? Какие объекты созданы, какие зависимости настроены?
* **Входные данные (Act):** Какие конкретные значения или действия вы передадите тестируемому коду?
* **Ожидаемый результат (Assert):** Что должно произойти после выполнения кода? Какое значение должна вернуть функция? Должно ли измениться состояние объекта? Должна ли программа вызвать другую функцию (которая, возможно, имитируется)? Должна ли возникнуть ошибка определенного типа? Ожидаемый результат должен быть четко связан с правилом безопасности, которое вы проверяете.

*Пример для "вопроса": "Как функция проверки пароля обрабатывает пустую строку?"*
* **UUT:** Метод `validatePassword`.
* **Сценарий:** Передать в метод пустую строку вместо пароля.
* **Подготовка:** Создать объект, содержащий метод `validatePassword`. Возможно, настроить имитатор, если метод `validatePassword` обращается к другой службе для каких-то проверок.
* **Входные данные:** Метод `validatePassword` вызывается со значением `" "` (пустая строка).
* **Ожидаемый результат:** Метод `validatePassword` должен вернуть специальное значение, обозначающее ошибку (например, `false`), или выбросить исключение, говорящее о некорректном формате пароля. Это соответствует правилу безопасности, требующему сложный или хотя бы не пустой пароль.

#### 5.2.4. Решить, Какие Зависимости Нужна "Подменить"

Чтобы ваш тест проверял только UUT и ничего больше, нужно заменить все, от чего зависит UUT (другие классы, доступ к файлам, базе данных, сети) на "тестовые двойники" (заглушки, имитаторы). Решите, какие зависимости нужно подменить и какой тип двойника использовать, исходя из того, что вы проверяете: нужно ли просто получить данные от зависимости (заглушка) или проверить, что UUT правильно вызывает методы зависимости (имитатор).

### 5.3. Шаг 3: Написать Сам Код UNIT-тестов

Теперь можно писать собственно код тестов, используя выбранный инструмент (фреймворк).

#### 5.3.1. Выбрать Инструмент для Написания Тестов

Выберите программу или набор библиотек (фреймворк) для написания UNIT-тестов на том языке, на котором написана ваша программа. Есть много разных фреймворков для разных языков (JUnit для Java, NUnit для C#, pytest для Python и другие). Выберите тот, который удобен, хорошо документирован и позволяет легко создавать тестовые двойники.

#### 5.3.2. Написать Код для Каждого Сценария

Пишите код для каждого тестового сценария, используя синтаксис выбранного фреймворка. Каждый тест обычно строится по схеме "Подготовка - Действие - Проверка" (Arrange-Act-Assert):
* **Подготовка (Arrange):** Пишете код, который настраивает все необходимое для теста (создает объекты, настраивает тестовые двойники с нужным поведением).
* **Действие (Act):** Пишете код, который вызывает тестируемый метод или функцию UUT с входными данными из сценария.
* **Проверка (Assert):** Пишете код с использованием специальных функций фреймворка (утверждений), который проверяет, что результат выполнения UUT совпадает с ожидаемым результатом из сценария. Например, `assertEqual(фактический_результат, ожидаемый_результат)`.

При проверке безопасности, утверждения должны быть очень точными. Например, не просто "метод отработал", а "метод вернул значение `false`, означающее отказ в доступе", или "было выброшено исключение `AccessDeniedException`", или "имитатор журнала безопасности был вызван с сообщением 'Неудачная попытка входа пользователя X'".

#### 5.3.3. Использовать Утверждения для Проверки Результата

Утверждения — это то, что делает тест тестом. Они сравнивают, что получилось на самом деле, с тем, что вы ожидали. Фреймворки предоставляют много типов утверждений: проверить равенство чисел или объектов, проверить, что условие истинно или ложно, проверить, что объект равен "ничему" (null) или наоборот не равен ему, проверить, что код выбросил ожидаемую ошибку.

Для тестов безопасности: используйте утверждения, чтобы точно проверить, что произошло с данными (зашифровались ли правильно, очистились ли от опасных символов), какие решения были приняты (доступ разрешен/запрещен), какие события зарегистрированы.

#### 5.3.4. Написать Код для "Подмены" Зависимостей

Используйте возможности выбранного фреймворка или специальные библиотеки для мокирования, чтобы создать тестовые двойники (заглушки, имитаторы) и "скормить" их вашему UUT вместо реальных зависимостей. Например, если ваш UUT обращается к базе данных, создайте имитатор базы данных, который просто возвращает нужные тестовые данные, когда UUT его "спрашивает", или проверяет, что UUT пытался записать в базу данных нужное событие аудита.

#### 5.3.5. Подготовить Тестовые Данные

Вам нужны специальные данные для ваших тестов.
* **Создание данных:** Придумайте или сгенерируйте данные, которые будут использоваться в тестах. Это должны быть данные, которые имитируют реальные (валидные пароли, невалидные логины, данные разного размера), а также специальные "опасные" данные для негативных сценариев (строки с возможными SQL-инъекциями, очень длинные строки).
* **Хранение данных:** Храните эти тестовые данные рядом с кодом тестов, чтобы их было легко найти.
* **Удаление данных:** После каждого теста убедитесь, что все, что создал тест (например, запись в имитаторе базы данных), удалено или сброшено, чтобы следующий тест начинался с чистого листа. Используйте для этого специальные функции фреймворка (фикстуры).

#### 5.3.6. Аккуратно Обращаться с Важными Данными

Если вы тестируете код, который работает с конфиденциальной информацией (пароли, ключи шифрования), никогда не используйте реальные данные в тестах. Создавайте тестовые данные, которые выглядят как настоящие, но не содержат реальной секретной информации. Убедитесь, что тестовые данные не попадают в отчеты или логи тестов.

### 5.4. Шаг 4: Запустить Тесты Автоматически

UNIT-тесты должны выполняться сами, без вашего участия, и очень часто.

#### 5.4.1. Настроить Автоматический Запуск при Каждом Изменении

Настройте систему сборки вашего проекта так, чтобы UNIT-тесты запускались автоматически каждый раз, когда кто-то из команды вносит изменения в код и отправляет их в общее хранилище (систему контроля версий). Это часть процесса, который называется Непрерывная Интеграция (CI).

#### 5.4.2. Подготовить Среду для Запуска

Тесты должны запускаться в специальном, контролируемом месте — тестовом окружении. Это может быть специальный сервер или виртуальная машина. Важно, чтобы это окружение было одинаковым каждый раз и было максимально изолировано, чтобы внешние факторы не влияли на результаты тестов.

#### 5.4.3. Запускать Тесты Очень Часто

Чем чаще запускаются тесты, тем быстрее вы узнаете, если последние изменения "сломали" что-то, особенно связанное с безопасностью. Запускайте тесты при каждом сохранении кода, при каждой сборке, и регулярно по расписанию (например, каждую ночь).

### 5.5. Шаг 5: Проверить Результаты и Рассказать о Них

После запуска тестов нужно понять, что произошло, и зафиксировать все проблемы.

#### 5.5.1. Понять, Что Значит Результат Теста

Каждый UNIT-тест либо "прошел" (Passed), либо "не прошел" (Failed).
* **Прошел:** Код работает точно так, как вы ожидали.
* **Не прошел:** Что-то пошло не так. Результат работы кода отличается от ожидаемого. Нужно выяснить, почему.

#### 5.5.2. Разобраться, Почему Тест Не Прошел

Если тест не прошел, нужно найти причину. Это может быть настоящая ошибка в коде программы, которую вы тестируете, или ошибка в самом тесте (вы неправильно написали проверку или ожидали неверный результат), или проблема в настройке тестового окружения. Инструменты для тестирования обычно показывают, в каком месте кода произошла ошибка и что именно не совпало.

#### 5.5.3. Записать Найденные Ошибки

Если тест показал ошибку в коде программы, нужно записать эту ошибку в систему, где вы отслеживаете все проблемы в проекте (например, Jira). Укажите, насколько важна эта ошибка, особенно если она касается безопасности, и кто должен ее исправить.

#### 5.5.4. Создать Отчеты о Тестировании

Ваш фреймворк для тестирования может создавать отчеты. Эти отчеты показывают, сколько тестов было всего, сколько из них прошли, сколько не прошли, и дают подробности о каждом неудачном тесте (его название, сообщение об ошибке). Если вы используете инструменты для измерения покрытия кода, эти отчеты также покажут, какая часть вашего кода была проверена тестами.

#### 5.5.5. Связать Отчеты с Правилами и "Вопросами"

Используйте вашу таблицу связей (матрицу трассируемости) и отчеты о тестах, чтобы показать:
* Какие правила безопасности и "вопросы" сертификации покрыты UNIT-тестами.
* Какие тесты соответствуют каким требованиям.
* Что результаты тестов подтверждают выполнение конкретных требований.

Эта информация будет важна для документов, которые вы предоставляете на сертификацию или инспекционный контроль.

## 6. Важные Технические Детали

### 6.1. Как Сделать Тесты Независимыми и Управлять Тем, От Чего Они Зависят

Самое важное в UNIT-тестах — чтобы каждый тест работал полностью сам по себе. Это значит, что результат теста не должен зависеть от того, запускались ли другие тесты до него, или от того, в каком состоянии находится база данных или интернет-соединение.

Для этого мы "подменяем" все, от чего зависит тестируемый код, на специальные тестовые объекты (заглушки, имитаторы, фейки).

Представьте, что ваш код, который вы тестируете (UUT), при работе обращается к базе данных, отправляет письмо по сети или получает текущее время от операционной системы. В UNIT-тесте мы не должны использовать реальную базу данных, сеть или системное время, потому что:
* Реальная база данных может быть недоступна или содержать разные данные в разное время.
* Отправка писем по сети медленная и требует подключения.
* Системное время постоянно меняется.

Вместо этого мы создаем "поддельные" объекты:
* Вместо реальной базы данных — имитатор, который просто "помнит" данные в памяти на время теста или просто проверяет, что код пытался записать в него что-то важное (например, событие аудита).
* Вместо отправщика писем — имитатор, который не отправляет письма, а просто запоминает, что метод отправки был вызван с нужным адресом и текстом (проверяем, что UUT *попытался* отправить письмо).
* Вместо системного времени — заглушка, которая всегда возвращает одно и то же, заранее заданное время, чтобы результат теста не менялся.

Выбор заглушки или имитатора зависит от того, что вам нужно проверить. Если просто нужны данные от зависимости — используйте заглушку. Если нужно убедиться, что UUT вызвал определенный метод зависимости (например, метод записи в журнал безопасности) — используйте имитатор и настройте на него ожидание такого вызова.

### 6.2. Как Тестировать Функции Безопасности на Уровне Кода

UNIT-тесты очень хорошо подходят для проверки правильности работы отдельных, небольших кусочков кода, которые выполняют важные функции безопасности. Например:

* **Вход в систему (Аутентификация):** Можно проверить, что функция, сравнивающая введенный пароль с сохраненным, работает правильно: возвращает "успех" только для верного пароля, "ошибку" для неверного, и правильно обрабатывает пустые или очень длинные пароли.
* **Проверка прав (Авторизация):** Можно протестировать функцию, которая решает, разрешить ли пользователю доступ к данным. Передайте ей разные комбинации пользователя, ресурса и нужного действия, и проверьте, что она возвращает правильный ответ ("разрешено" или "запрещено") согласно правилам безопасности.
* **Проверка, не изменялись ли данные (Контроль целостности):** Можно проверить функцию, которая вычисляет хеш-сумму файла или проверяет цифровую подпись. Дайте ей правильные и измененные данные, правильные и неверные подписи, и проверьте, что функция выдает ожидаемый результат (например, "целостность нарушена").
* **Шифрование и Расшифрование:** Можно проверить, что функция шифрования правильно вызывает криптографические библиотеки с нужными ключами и параметрами. Зашифруйте небольшой блок тестовых данных, затем расшифруйте его и проверьте, что получили исходные данные.
* **Запись Событий Безопасности (Аудит):** Используйте имитаторы, чтобы проверить, что после важных событий (например, неудачная попытка входа), ваш код правильно вызывает функцию записи в журнал и передает ей всю нужную информацию (кто пытался войти, когда, почему не получилось).

### 6.3. Как Тестировать Настройки, Которые Влияют на Безопасность

Часто поведение программы в плане безопасности зависит от того, как она настроена (например, какое время блокировки учетной записи, какой длины должен быть пароль). UNIT-тесты могут проверить:
* Правильно ли ваш код читает настройки из файла или другого источника.
* Правильно ли код использует эти настройки в своей логике (например, функция проверки пароля действительно требует пароль не короче длины, указанной в настройках).
* Как код ведет себя, если какие-то важные настройки безопасности отсутствуют или имеют неправильные значения.

Используйте фикстуры или имитаторы, чтобы "подсовывать" тестируемому коду разные наборы настроек и проверять его поведение для каждой из них.

## 7. Инструменты для UNIT-тестирования

Существуют разные программы и библиотеки, которые помогают писать и запускать UNIT-тесты.

| Что это за Инструмент | Чем Он Помогает в Тестировании | Примеры (для разных языков) | Что Нужно Учитывать |
| :--- | :--- | :--- | :---- |
| **Фреймворк для тестов** | Это основа, на которой вы пишете тесты. Дает структуру, способы писать проверки (утверждения), запускать тесты. | JUnit (Java), NUnit (C#), pytest (Python) | Нужно научиться им пользоваться. У каждого свои особенности. |
| **Библиотека для имитации (Mocking)** | Помогает легко создавать "поддельные" объекты (имитаторы, заглушки) для изоляции кода. | Mockito (Java), Moq (C#), unittest.mock (Python) | Важно правильно их использовать, чтобы проверять взаимодействие, а не просто факт вызова. Не всегда легко имитировать все подряд. |
| **Инструмент для покрытия кода** | Показывает, сколько строк или частей вашего кода было выполнено во время тестов. Это помогает найти места, которые вообще не проверялись. | JaCoCo (Java), Coverlet (C#), Coverage.py (Python) | Высокий процент покрытия не означает, что все проверено хорошо или что нет ошибок безопасности. Это просто показатель, сколько кода было "затронуто" тестами. |
| **Система Автоматической Сборки (CI)** | Программа, которая сама запускает сборку вашего проекта и тесты каждый раз, когда вы меняете код. | Jenkins, GitLab CI, GitHub Actions | Нужно правильно настроить связь между этой системой, вашим кодом и вашими тестами. Если что-то настроено не так, результаты могут быть неверными. |

## 8. Частые Ошибки и Как Их Избежать

| Ошибка при Написании Тестов | Что Это Такое | Чем Это Плохо для Сертификации ФСТЭК | Как Этого Избежать |
| :--- | :--- | :----- | :----- |
| **Тесты Зависят Друг от Друга или от Внешнего** | Тест не может работать сам по себе, ему нужна база данных, интернет или результат предыдущего теста. | Тесты часто будут давать сбой без реальной ошибки в коде. Вы не сможете точно проверить, как код работает в конкретных условиях (например, при ошибке подключения), важных для безопасности. Проверки занимают много времени. | Всегда "подменяйте" внешние зависимости (базу данных, сеть, файлы) на тестовые двойники (заглушки, имитаторы). Используйте фикстуры для подготовки чистого состояния перед каждым тестом. |
| **Не Проверены Ситуации с Ошибками или Атаками** | Тесты проверяют только "идеальную" работу кода, но не проверяют, что будет при неправильных данных, ошибках или попытках "сломать" программу (например, ввод опасных символов). | Важные уязвимости и ошибки в обработке опасных ситуаций останутся незамеченными. Именно такие вещи часто проверяют аудиторы ФСТЭК. | Специально придумывайте тестовые сценарии для неправильных, граничных и опасных входных данных. Думайте, как злоумышленник мог бы попытаться использовать функцию. |
| **Тестируется Слишком Много Кода Сразу** | Один тест проверяет не маленькую функцию, а большой кусок программы, включающий несколько классов или модулей. | Если тест не пройдет, очень сложно быстро найти, в каком именно месте большого куска кода ошибка. Поиск и исправление займут много времени. | Стремитесь тестировать самые маленькие, отдельно работающие части кода (отдельный метод, функция). Если часть кода большая, попробуйте разбить ее на более мелкие, тестируемые части. |
| **Нет Связи Между Тестом и Требованием** | Вы пишете тесты, но не понимаете, какое конкретное правило безопасности или "вопрос" аудитора этот тест проверяет. | Вам будет трудно показать аудиторам, что все требования безопасности действительно проверены. Вы не сможете легко доказать, что ваши тесты подтверждают соответствие. | Всегда ведите таблицу (матрицу трассируемости), которая связывает требования, вопросы и конкретные тесты. Добавляйте в код теста комментарии или специальные метки, указывающие на соответствующее требование. |
| **Тесты Слишком Сложные** | Код самих тестов трудно понять, он запутанный или содержит много повторяющихся частей. | Тесты становится сложно поддерживать. При изменении кода программы тесты тоже нужно менять, и в сложных тестах легко допустить ошибку. | Пишите код тестов максимально просто и понятно. Используйте вспомогательные функции и фикстуры, чтобы избежать повторений. Код теста должен быть проще кода, который он тестирует. |

## 9. Как Убедиться, Что Тесты Правильные, и Как Всё Записать

Важно не только написать тесты, но и убедиться, что сами тесты работают правильно и проверяют то, что нужно. А еще — правильно оформить всю информацию для проверяющих.

### 9.1. Проверка Самих Тестов

Как проверить, что ваши UNIT-тесты хорошие и надежные?

* **Смотреть Покрытие Кода:** Используйте инструменты, которые показывают, какая часть кода была выполнена при запуске тестов. Если есть участки кода, которые тесты никогда не затрагивают (особенно в важных для безопасности функциях), это может означать, что тестов недостаточно или они неправильно написаны.
* **Мутационное Тестирование:** Это более сложный способ. Специальная программа слегка меняет ваш исходный код (например, меняет знак ">" на "<"). Затем запускаются ваши UNIT-тесты. Если ваш тест хороший, он должен "заметить" это изменение и "сломаться" (это называется "убить мутацию"). Если тест не сломался, возможно, он не проверяет этот аспект кода.
* **Проверка Кода Тестов Другими Инженерами:** Пусть другие люди из вашей команды посмотрят код ваших тестов. Они могут заметить ошибки в логике теста, неправильные проверки или проблемы с изоляцией.
* **Написание Тестов Вместе (Парное Программирование):** Когда два инженера вместе пишут тест, они могут сразу обсудить, как лучше его написать и что именно нужно проверить.

### 9.2. Как Всё Задокументировать для Проверяющих

Для аудита ФСТЭК нужно не только провести тесты, но и показать, как вы это делали и какие получили результаты.

* **Описание Методики:** Этот документ — это описание того, как вы подходите к написанию тестов.
* **Таблица Связей:** Ваша "карта", которая показывает, какие требования безопасности связаны с какими частями кода и какими тестами это проверяется.
* **Описание Сценариев Тестов:** Для самых важных частей программы можно сделать подробное описание того, что делает каждый тест, какие данные использует и что ожидает получить.
* **Сам Код Тестов:** Исходный код UNIT-тестов — это самый точный документ о том, что именно проверяется. Добавляйте комментарии, чтобы объяснить сложные моменты, особенно связанные с проверками безопасности.
* **Отчеты о Запусках Тестов:** Отчеты, которые автоматически создает ваш фреймворк. Они показывают, сколько тестов прошло, сколько не прошло, и дают детали по ошибкам. Отчеты о покрытии кода тоже важны.
* **Описание Места, Где Запускаются Тесты:** Краткое описание тестового окружения (например, какая версия фреймворка используется, на какой операционной системе запускаются тесты).
* **Описание Процесса Запуска:** Как именно запускаются ваши тесты (например, какая команда используется в системе CI).
* **Информация о Найденных Ошибках:** Записи об ошибках, которые вы нашли с помощью тестов, и информация о том, как они были исправлены.

Все эти документы должны быть актуальными и понятными для тех, кто будет проверять вашу программу.

## 10. Заключение

UNIT-тесты — это не просто хорошая практика, а важный инструмент, когда ваша программа должна пройти проверку на безопасность для ФСТЭК. Следуя этой методике, вы сможете создавать тесты, которые точно проверяют важные части программы, связанные с безопасностью, и предоставляют надежные доказательства того, что программа работает правильно. Это поможет найти проблемы на ранних этапах, убедиться в соответствии требованиям и успешно пройти сертификацию и инспекционный контроль.
