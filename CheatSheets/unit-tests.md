# методика создания unit-тестов для вопросов проведения сертификации по во фстэк и инспекционного контроля

## 1. введение

Этот документ объясняет, как писать UNIT-тесты для компьютерных программ. Эти тесты помогают убедиться, что программа работает правильно, особенно в тех частях, которые важны для получения специального разрешения ФСТЭК России или при последующих проверках.

Мы подготовили эту методику для инженеров — людей, которые пишут программы или проверяют их работу. Она поможет создать автоматические тесты для проверки отдельных кусочков программы. Такие тесты нужны, чтобы найти ошибки и убедиться, что программа соответствует требованиям безопасности. Это особенно важно, когда программу проверяют для сертификации или во время инспекционного контроля.

Наша цель — дать понятные шаги для написания верифицируемых и воспроизводимых тестов, которые покажут, что отдельные части программы работают так, как ожидается, особенно в ситуациях, связанных с безопасностью информации.

## 2. глоссарий терминов

В этом разделе собраны и объяснены специальные слова и понятия, которые используются в данном документе. Понимание этих терминов необходимо для правильного применения описанной методики.

| термин                                        | определение                                                                                                                                                                                                                                                                                                                                                        |
| :-------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| UNIT-тест (Юнит-тест)                         | Самый базовый вид автоматического теста. Он проверяет самую маленькую, отдельно работающую часть программы (например, одну функцию, один метод класса или небольшой класс). Цель — убедиться, что этот конкретный, изолированный кусочек кода выполняет свою задачу правильно при различных входных данных и условиях.                                                    |
| Программное Обеспечение (ПО)                  | Полный набор инструкций (программ), которые говорят компьютеру, что делать, а также связанных с ними данных.                                                                                                                                                                                                                                                      |
| ФСТЭК России                                  | Федеральная служба по техническому и экспортному контролю. Государственный орган Российской Федерации, отвечающий, в частности, за регулирование в области защиты информации, выдачу сертификатов соответствия на средства защиты информации и информационные технологии.                                                                                          |
| Сертификация ПО во ФСТЭК                      | Процедура подтверждения соответствия программного обеспечения установленным требованиям безопасности информации, выполняемая органом по сертификации, аккредитованным ФСТЭК России. Результатом успешного прохождения процедуры является выдача сертификата соответствия, разрешающего использование ПО в информационных системах с определенным классом защищенности. |
| Инспекционный Контроль                        | Плановая или внеплановая проверка сертифицированного программного обеспечения, проводимая ФСТЭК России или аккредитованным органом по сертификации после выдачи сертификата. Цель — убедиться, что ПО продолжает соответствовать требованиям безопасности после внесения изменений или в процессе эксплуатации.                                                    |
| Вопросы проведения сертификации/инспекционного контроля | Конкретные пункты программы оценки соответствия, требования, тесты или проверки, выполняемые экспертами (аудиторами) органа по сертификации или ФСТЭК России в ходе сертификационных испытаний или инспекционного контроля. Они детализируют, какие аспекты безопасности ПО подлежат проверке.                                                                   |
| Требования безопасности информации              | Правила, стандарты, условия и спецификации, которым должно соответствовать программное обеспечение для обеспечения защиты информации от угроз (несанкционированный доступ, изменение, уничтожение, блокирование и др.). Они могут быть установлены законодательством, нормативными документами ФСТЭК, государственными стандартами, техническими заданиями.           |
| Функции безопасности                          | Части программного кода или модули ПО, реализующие конкретные механизмы защиты информации. К ним относятся, например, функции аутентификации пользователя, авторизации (проверки прав доступа), контроля целостности данных, шифрования, регистрации событий аудита.                                                                                             |
| Недекларированные возможности                 | Функциональные возможности программного обеспечения, не описанные в документации, которые могут быть использованы для получения несанкционированного доступа к информации, изменения или уничтожения информации, а также для воздействия на функционирование программного обеспечения или информационной системы в целом. Проверяется их отсутствие.               |
| Трассируемость                                | Возможность установить и проследить логическую связь между различными элементами проекта разработки (например, между требованием безопасности, соответствующим фрагментом исходного кода и UNIT-тестом, который этот фрагмент проверяет). Обеспечивает прозрачность и полноту проверки требований.                                                              |
| Тестовый сценарий                             | Подробное описание шагов, условий и ожидаемого результата, необходимых для выполнения конкретной проверки функциональности или свойства программного обеспечения. Используется как план для написания автоматического теста.                                                                                                                                  |
| Тестовые двойники                             | Объекты или компоненты, созданные специально для тестирования, которые заменяют реальные зависимости тестируемого кода (другие модули, базы данных, сетевые сервисы, файловая система). Используются для изоляции UNIT-тестируемого кода и управления его окружением. Основные типы: Заглушка, Имитатор, Фейк.                                                  |
| Заглушка (Stub)                               | Простейший вид тестового двойника. Используется для подмены зависимости, когда тестируемому коду нужен только определенный заранее заданный ответ от этой зависимости. Заглушка просто возвращает фиктивное значение и не содержит сложной логики или проверок.                                                                                                 |
| Имитатор (Mock)                               | Тестовый двойник, который не только возвращает заранее заданные значения, но и позволяет проверить, что тестируемый код правильно взаимодействует с этой зависимостью — вызывает определенные методы с нужными параметрами и в правильном порядке. Используется для проверки *взаимодействия*, а не только *результата*.                                     |
| Фейк (Fake)                                   | Тестовый двойник, который имеет упрощенную, но рабочую реализацию логики реальной зависимости (например, базу данных, которая работает только в памяти). Используется, когда заглушки или имитаторы недостаточны, но полная реальная зависимость избыточна или сложна для использования в тесте.                                                              |
| Утверждение (Assertion)                       | Оператор или вызов функции в коде теста, который проверяет истинность определенного условия — сравнивает фактический результат выполнения тестируемого кода с ожидаемым результатом. Если условие истинно, утверждение проходит. Если ложно, утверждение проваливается, и тест помечается как неудачный.                                                        |
| Фикстура (Fixture)                            | Код или данные, которые подготавливают тестовое окружение для выполнения одного или нескольких тестов (например, создают необходимые объекты, загружают тестовые данные, настраивают имитаторы) и очищают его после выполнения тестов. Гарантируют, что каждый тест выполняется в одинаковых, предсказуемых условиях.                                         |
| UUT (Unit Under Test)                         | Единица (часть) программного обеспечения, которая непосредственно проверяется конкретным UNIT-тестом.                                                                                                                                                                                                                                                   |
| Arrange-Act-Assert (AAA)                      | Популярный шаблон организации кода UNIT-теста, разделяющий его на три логических части: Arrange (Подготовка окружения), Act (Выполнение тестируемого кода), Assert (Проверка результата с помощью утверждений).                                                                                                                                       |
| Given-When-Then (GWT)                         | Альтернативный шаблон для организации UNIT-тестов, часто используемый в поведении-ориентированном тестировании. Структурирует тест в виде "Дано" (исходное состояние), "Когда" (происходит действие), "Тогда" (ожидаемый результат).                                                                                                                        |
| CI/CD (Continuous Integration / Continuous Delivery) | Набор практик в разработке ПО, направленных на частую и автоматическую интеграцию изменений кода, выполнение автоматизированных тестов (CI) и, при успешном прохождении тестов, автоматизированную подготовку к выпуску или выпуск новой версии ПО (CD).                                                                                                 |
| Покрытие кода (Code Coverage)                 | Метрика, показывающая, какая часть исходного кода программы была выполнена (пройдена) во время выполнения определенного набора тестов. Помогает оценить, насколько полно тесты затрагивают различные части кода. Измеряется в процентах (по строкам, ветвлениям, функциям).                                                                                 |
| Мутационное тестирование (Mutation Testing)   | Техника для оценки качества самих тестов. Специальные инструменты вносят небольшие автоматические изменения (мутации) в исходный код программы, имитируя типовые ошибки. Затем запускаются тесты. Если тест разработан правильно и проверяет измененный участок кода, он должен провалиться ("убить" мутацию). Если тест не падает, возможно, он неэффективен. |

## 3. контекст: сертификация по во фстэк и инспекционный контроль

Сертификация ПО во ФСТЭК — это процесс, когда вашу программу проверяют на соответствие требованиям безопасности, чтобы подтвердить, что она может использоваться, например, для работы с конфиденциальной информацией. Это как пройти строгий технический осмотр. Эксперты смотрят, насколько хорошо программа защищает данные, нет ли в ней "дыр" для злоумышленников и соответствует ли она правилам, установленным ФСТЭК.

"Вопросы" во время сертификации и последующих проверок (инспекционного контроля) — это конкретные задания или проверки, которые эксперты проводят, чтобы убедиться в безопасности. Они могут касаться самых разных аспектов работы программы.

В следующей таблице приведены примеры типовых областей и связанных с ними "вопросов", которые могут возникнуть в процессе сертификации или контроля.

| область проверки безопасности            | пример "вопроса" сертификации/контроля                                                                                                                                                                                                                            |
| :--------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| аутентификация пользователя              | как программа проверяет подлинность пользователя при входе? какие требования к сложности пароля применяются? что происходит при вводе неверных учетных данных?                                                                                                         |
| авторизация и разграничение доступа      | правильно ли программа определяет, к каким данным или функциям имеет доступ конкретный пользователь? что происходит, если пользователь пытается получить доступ к запрещенному ресурсу?                                                                               |
| контроль целостности                     | как программа убеждается, что важные файлы или данные не были изменены без разрешения? проверяется ли целостность исполняемых файлов самой программы при запуске?                                                                                                   |
| обработка конфиденциальных данных        | как программа защищает чувствительные данные (например, пароли, персональные данные) во время их обработки и хранения? правильно ли выполняется шифрование или обезличивание?                                                                                       |
| регистрация и аудит событий безопасности | какие действия пользователя или системные события регистрируются программой? содержат ли записи аудита всю необходимую информацию (кто, что, когда, результат)?                                                                                                      |
| обработка ошибок и исключений            | как программа реагирует на ошибки, которые могут повлиять на безопасность (например, сбой при записи в журнал аудита)? не раскрывает ли программа слишком много информации об ошибках, которая может быть использована злоумышленником?                               |
| проверка ввода пользовательских данных   | как программа обрабатывает данные, которые вводит пользователь? проверяются ли данные на наличие опасных символов или команд, которые могут привести к атакам (например, SQL-инъекции, XSS)?                                                                         |

Инспекционный контроль — это проверка того, что программа остается безопасной после того, как вы ее обновили или внесли изменения. "Вопросы" тут часто связаны с тем, как эти изменения повлияли на функции безопасности.

## 4. назначение unit-тестирования в контексте фстэк

UNIT-тестирование — это мощный технический инструмент, который помогает удостовериться, что самые маленькие части вашей программы работают правильно. В контексте сертификации ФСТЭК и инспекционного контроля UNIT-тесты играют особую роль. Они не просто помогают найти ошибки; они создают основу доказательств того, что программа соответствует требованиям безопасности на уровне ее отдельных компонентов.

UNIT-тесты помогают:

* **найти ошибки безопасности очень рано:** Обнаружить проблемы в коде, который отвечает за безопасность (например, ошибка в функции проверки пароля или неправильная обработка прав доступа), еще до того, как этот код будет собран с другими частями программы. Это значительно дешевле и быстрее, чем искать ошибки в готовой программе.
* **убедиться, что конкретные требования выполнены:** Проверить, что отдельные функции или алгоритмы программы работают именно так, как требуют правила безопасности ФСТЭК или техническое задание. Например, удостовериться, что функция шифрования вызывает криптографическую библиотеку с правильными параметрами.
* **получить надежные доказательства:** Автоматизированные UNIT-тесты можно запускать снова и снова, и они всегда дадут одинаковый результат (если код не менялся). Успешные тесты являются объективным доказательством того, что проверенный кусок кода ведет себя правильно в различных сценариях, в том числе важных для безопасности.
* **снизить риски при проверках:** Если у вас есть большой набор UNIT-тестов, покрывающих критичные для безопасности части программы, вы можете показать аудиторам, что регулярно проверяете эти части, и что последние изменения не нарушили их работу. Это упрощает прохождение инспекционного контроля.
* **сделать код более качественным:** Процесс написания UNIT-тестов часто подталкивает разработчиков создавать код, который легче тестировать. Такой код обычно более четко разделен на части, проще для понимания и поддержки, что само по себе снижает вероятность появления ошибок.

UNIT-тесты не заменяют другие виды проверок (тестирование всей программы в целом, поиск уязвимостей), но они создают прочную базу. Они подтверждают правильность работы базовых строительных блоков программы.

При разработке UNIT-тестов для целей сертификации и контроля ФСТЭК важно следовать основным принципам, чтобы тесты были эффективными и их результаты были надежными:

* **изоляция:** Каждый тест должен проверять только один маленький кусок кода и не зависеть от других частей программы или внешних условий.
* **автоматизация:** Тесты должны запускаться автоматически, без участия человека.
* **повторяемость:** Один и тот же тест, запущенный несколько раз при тех же условиях, всегда должен давать один и тот же результат.
* **независимость:** Результат одного теста не должен влиять на результат другого теста.
* **быстрота:** Тесты должны выполняться очень быстро, чтобы их можно было запускать часто.
* **связь с безопасностью:** В первую очередь нужно тестировать те части кода, которые напрямую связаны с функциями безопасности и требованиями ФСТЭК.
* **трассируемость:** Должна быть четкая связь между тестом, кодом, который он проверяет, и правилом безопасности, для которого этот тест написан.
* **читаемость:** Код тестов должен быть понятным другим инженерам.

## 5. методология создания unit-тестов для вопросов сертификации

Процесс создания UNIT-тестов, полезных для сертификации ФСТЭК, состоит из нескольких последовательных шагов.

### 5.1. шаг 1: анализ требований и превращение "вопросов" в задачи для тестов

Этот шаг самый важный и требует внимательного изучения документов и понимания, что именно будут проверять аудиторы.

#### 5.1.1. поиск правил безопасности, которые касаются вашей программы

На этом этапе вы изучаете все документы, где описаны требования к безопасности вашей программы. Цель — найти конкретные, измеримые требования, которые можно проверить.

Следующая таблица показывает, какие типы документов могут содержать такую информацию и на что в них нужно обращать внимание.

| тип документа                                  | что искать в этих документах                                                                                                                                                                                                                                                           |
| :--------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| нормативные документы фстэк россии             | общие требования к уровням доверия по, требования к системам защиты информации. ищите конкретные пункты, описывающие функции безопасности (например, требования к механизмам аутентификации, контроля доступа, аудита).                                                                     |
| техническое задание на создание сиcтемы защиты информации | раздел, описывающий функции и механизмы защиты информации, которые должны быть реализованы в программе. ищите детали о том, как именно должны работать эти механизмы (например, алгоритм хеширования паролей, правила разграничения доступа).                                      |
| техническое задание на программное обеспечение | если отдельного тз на сиз нет, требования безопасности могут быть включены в общее тз на по. ищите разделы, касающиеся безопасности, защиты данных, обработки ошибок, требований к надежности и устойчивости.                                                                           |
| эксплуатационная документация на по          | описание функций безопасности с точки зрения пользователя или администратора. как настроить безопасность, как работают функции входа, управления пользователями, аудита. это помогает понять ожидаемое поведение системы.                                                                     |
| технические условия (ту) на по                 | документ, описывающий основные характеристики и требования к программе. раздел, связанный с требованиями безопасности или специальными требованиями.                                                                                                                                        |
| иные стандарты или политики безопасности       | внутренние политики компании, отраслевые стандарты (если применимы). могут содержать дополнительные требования к обработке данных, использованию криптографии, реагированию на инциденты.                                                                                               |

Из этих документов нужно "вытащить" конкретные формулировки, которые можно проверить. Например: "Пароль пользователя должен содержать не менее 8 символов, включая строчные и заглавные буквы, цифры и специальные символы".

#### 5.1.2. определение, какой код выполняет эти правила

После того как вы нашли конкретные требования безопасности, нужно понять, какие части вашего кода отвечают за их выполнение. Найдите модули, классы, функции или методы, которые реализуют каждое требование. Например, требование к сложности пароля, скорее всего, реализуется в функции, которая проверяет введенный пароль при его смене или установке.

#### 5.1.3. формализация "вопросов" сертификации/контроля

Подумайте, какие конкретные проверки или вопросы могут задать эксперты ФСТЭК или лаборатории, исходя из требований, которые вы нашли. Превратите эти возможные вопросы в четкие, проверяемые задания для ваших UNIT-тестов.

Следующая таблица показывает, как преобразовать типовые "вопросы" аудиторов в конкретные задачи для тестирования.

| исходный "вопрос" сертификации/контроля                                                                 | как превратить в задачу для unit-теста (пример)                                                                                                                                                                                                                          |
| :------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| как система проверяет учетные данные пользователя при входе?                                             | *Задача теста:* проверить, что метод `checkLoginPassword` возвращает `true` для правильной пары логин/пароль и `false` для неправильной. проверить граничные случаи: пустой логин, пустой пароль, очень длинные значения.                                                       |
| правильно ли программа определяет, к каким данным имеет доступ конкретный пользователь?                 | *Задача теста:* проверить, что метод `canAccessResource` возвращает `true` для пользователя с ролью "администратор" при попытке доступа к ресурсу "/settings" и `false` для пользователя с рольей "гость". Проверить разные комбинации ролей и ресурсов согласно правилам доступа. |
| как программа обрабатывает данные, которые вводит пользователь, на наличие опасных символов?           | *Задача теста:* проверить, что функция `sanitizeInput` удаляет или преобразует специальные символы (например, `<script>`, `--`, `'`) из входной строки. Проверить, что функция правильно обрабатывает обычный текст без опасных символов.                                |
| вызывают ли функции входа/выхода или изменения прав записи в журнал аудита?                             | *Задача теста:* используя имитатор для журнала аудита, проверить, что метод `processLogin` вызывает метод `logEvent` имитатора с типом события "успешный вход" и правильными параметрами (имя пользователя, время). Аналогично проверить неудачные входы и другие важные события. |
| как функция шифрования работает с разными ключами и данными?                                            | *Задача теста:* проверить, что метод `encryptData` успешно шифрует тестовые данные, используя валидный ключ. Проверить, что попытка расшифровать данные неверным ключом приводит к ошибке или возвращает некорректные данные.                                                |
| что происходит, если функция, работающая с файлами, пытается получить доступ к файлу без достаточных прав? | *Задача теста:* используя имитатор файловой системы, настроенный так, чтобы запретить доступ к определенному файлу, проверить, что метод `readFileContent` в этом случае выбрасывает ожидаемое исключение `PermissionDeniedException`.                                     |

Превращая "вопросы" в такие задачи, вы создаете четкий план для написания кода тестов.

#### 5.1.4. создание матрицы трассируемости

Очень полезно создать таблицу, которая показывает связи между требованиями безопасности (из документов), формализованными "вопросами" и конкретными частями вашего кода (модулями/функциями), которые реализуют эти требования. Затем вы добавите в эту таблицу информацию о UNIT-тестах, которые проверяют эти части кода.

Эта таблица (матрица трассируемости) служит картой, которая помогает убедиться, что вы ничего не пропустили, и позволяет легко показать проверяющим, какие тесты подтверждают выполнение каких требований безопасности.

| идентификатор требования (документ, пункт) | описание требования безопасности                                   | формализованный "вопрос" сертификации/контроля                                          | идентифицированная единица кода (модуль, функция) | идентификатор unit-теста(ов) (название класса/метода) | примечание (связь, реализация)                                                              |
| :----------------------------------------- | :----------------------------------------------------------------- | :-------------------------------------------------------------------------------------- | :------------------------------------------------ | :---------------------------------------------------- | :------------------------------------------------------------------------------------------ |
| рд фстэк, уровень доверия 4, п. x.y        | система должна выполнять строгую аутентификацию пользователей.     | как система проверяет учетные данные пользователя? какие методы аутентификации поддерживаются? | `AuthService`, методы `authenticate`, `verifyToken` | `AuthServiceTest.testAuthenticateValidCredentials`, `AuthServiceTest.testVerifyTokenExpired` | `authenticate` реализует проверку логина/пароля, `verifyToken` - проверку токенов сессии. |
| тз на сиз, раздел 3.2.1                    | все неуспешные попытки входа должны регистрироваться в журнале. | фиксируются ли неудачные попытки входа в журнале аудита?                                | `AuthService`, метод `authenticate`; `AuditLogger`, метод `logEvent` | `AuthServiceTest.testAuthenticateInvalidPasswordLogsAttempt`                                | `authenticate` вызывает `AuditLogger.logEvent` при неудаче.                                 |
| ту на по, требование 5.1                   | пароль должен соответствовать политике сложности.                  | как система проверяет сложность нового пароля?                                          | `PasswordPolicyChecker`, метод `checkComplexity`  | `PasswordPolicyCheckerTest.testCheckComplexityValid`, `PasswordPolicyCheckerTest.testCheckComplexityTooShort`, `PasswordPolicyCheckerTest.testCheckComplexityNoSpecialChars` | `checkComplexity` реализует логику проверки всех правил сложности пароля.                     |

### 5.2. шаг 2: спланировать, какие именно тесты нужно написать

На этом этапе вы подробно продумываете, как именно будете проверять каждый "юнит" кода, связанный с безопасностью, используя UNIT-тесты.

#### 5.2.1. определение тестируемых единиц

Для каждой строчки в вашей матрице трассируемости, где указана часть кода, вы определяете, какой именно "юнит" будет тестироваться. Это может быть один метод, одна функция или один небольшой класс. Важно выбрать минимально возможный, но осмысленный для проверки безопасности кусок кода.

#### 5.2.2. определение тестовых сценариев

Для каждой тестируемой единицы и связанного с ней требования безопасности или "вопроса" нужно придумать тестовые сценарии. Сценарий описывает конкретную ситуацию, которую вы хотите проверить. Думайте о разных способах, как можно использовать этот кусок кода, включая те, которые могут привести к ошибкам или проблемам безопасности.

Следующая таблица описывает основные типы тестовых сценариев, которые следует создавать.

| тип тестового сценария              | цель сценария и на что он должен быть направлен                                                                                                                                                                                                                                                                                                                         | пример (обобщенный)                                                                                                                                                                                            |
| :----------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| позитивные сценарии                  | проверка того, что тестируемый код правильно выполняет свою задачу в нормальных, ожидаемых условиях, когда все входные данные корректны, а зависимости ведут себя как положено. это подтверждает базовую работоспособность функции безопасности.                                                                                                                           | проверка того, что функция аутентификации успешно выполняет вход при вводе правильных логина и пароля. проверка того, что функция шифрования корректно шифрует данные валидным ключом.                            |
| негативные сценарии                  | проверка того, как тестируемый код реагирует на некорректные, неполные, граничные или заведомо "плохие" входные данные или условия. это критически важно для безопасности, так как часто именно некорректная обработка ошибок или неожиданных данных приводит к уязвимостям.                                                                                                | проверка того, что функция аутентификации отклоняет вход при неверном пароле, пустом логине, недопустимых символах в поле логина. проверка того, что функция санитизации правильно удаляет опасные символы из строки. |
| сценарии обработки исключений/ошибок | проверка того, как тестируемый код ведет себя при возникновении внутренних ошибок или исключительных ситуаций, которые могут возникнуть в реальной работе или при попытке атаки (например, нет доступа к файлу, ошибка при обращении к базе данных, неверный формат данных). нужно проверить, что ошибки обрабатываются безопасно и корректно.                                  | проверка того, что функция, читающая конфигурацию безопасности из файла, выбрасывает ожидаемое исключение, если файл не найден или имеет неверный формат. проверка того, что функция доступа к ресурсу выбрасывает ошибку "доступ запрещен", если у пользователя нет прав. |

Для каждого сценария нужно четко определить, что вы даете на вход и какой результат ожидаете получить.

#### 5.2.3. определение входных данных и ожидаемых результатов

Для каждого придуманного сценария точно опишите:
* **что нужно подготовить до теста (arrange):** Какие объекты должны существовать, как должны быть настроены тестовые двойники (заглушки/имитаторы), какие начальные данные нужны.
* **что вы делаете для проверки (act):** Какие конкретные значения вы передаете тестируемому коду, какую функцию вызываете.
* **что вы ожидаете получить в результате (assert):** Какое значение должна вернуть функция, как должно измениться состояние объектов, какие методы тестовых двойников должны быть вызваны, какие ошибки (исключения) должны возникнуть. Ожидаемый результат должен быть однозначно определен на основе правил безопасности и логики работы кода.

*Пример для сценария: "Проверка функции `checkPassword` при неверном пароле".*
* **arrange:** Создать объект `AuthService`. Настроить имитатор базы данных так, чтобы он возвращал хеш правильного пароля для тестового пользователя.
* **act:** Вызвать метод `authService.checkPassword("testUser", "НеверныйПароль")`.
* **assert:** Ожидается, что метод `checkPassword` вернет значение `false`. Ожидается, что имитатор журнала аудита был вызван методом `logEvent` с параметрами "неудачная попытка входа", "testUser", IP-адрес и время.

#### 5.2.4. определение необходимых имитаторов, заглушек и фейков

Решите, какие зависимости вашего тестируемого кода (другие модули, доступ к файлам, базе данных, сети) нужно заменить на тестовые двойники (заглушки, имитаторы или фейки), чтобы тест был изолированным и повторяемым. Определите, какой тип двойника лучше подходит для каждой зависимости, исходя из того, что вы проверяете (только возвращаемое значение, взаимодействие или упрощенную логику).

### 5.3. шаг 3: написание самого кода unit-тестов

На этом этапе вы пишете реальный код UNIT-тестов на выбранном языке программирования, используя фреймворк для тестирования.

#### 5.3.1. выбор фреймворка для unit-тестирования

Выберите подходящий набор инструментов (фреймворк) для написания и запуска UNIT-тестов. Выбор зависит от языка, на котором написана ваша программа.

| язык программирования | примеры популярных фреймворков для unit-тестирования |
| :-------------------- | :---------------------------------------------------- |
| java                  | junit, testng                                         |
| c#                    | nunit, xunit.net, mstest                              |
| python                | unittest, pytest, nose                                |
| c++                   | google test, catch2, boost.test                       |
| javascript            | jest, mocha, jasmine                                  |
| ...                   | ...                                                   |

Выбирайте фреймворк, который широко используется, хорошо документирован, поддерживает создание тестовых двойников и интегрируется с вашей системой сборки.

#### 5.3.2. написание кода тестов

Код каждого UNIT-теста должен соответствовать разработанному сценарию. Большинство тестов пишутся по простой структуре.

Следующая таблица описывает два популярных шаблона для структурирования кода UNIT-теста.

| шаблон              | описание шагов и их назначение                                                                                                                                                                                                                                                                                                                           |
| :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| arrange-act-assert (aaa) | **arrange (подготовка):** код, который создает все необходимые объекты, настраивает тестовое окружение, готовит тестовые данные и настраивает поведение тестовых двойников (заглушек, имитаторов). цель: привести все в нужное состояние для проверки. <br>**act (действие):** код, который вызывает тестируемый метод или функцию (uut) с подготовленными входными данными. цель: выполнить ту часть кода, которую мы проверяем. <br>**assert (проверка):** код, который использует утверждения для проверки, что фактический результат выполнения uut совпадает с ожидаемым результатом. цель: удостовериться, что uut повел себя правильно. |
| given-when-then (gwt) | **given (дано):** описание исходного состояния системы или uut перед началом теста. похоже на arrange. цель: установить контекст теста. <br>**when (когда):** описание действия, которое выполняется над uut. похоже на act. цель: инициировать проверяемое поведение. <br>**then (тогда):** описание ожидаемого результата или изменения состояния системы после выполнения действия. похоже на assert. цель: проверить, соответствует ли фактический результат ожиданиям.                                                  |

Используйте утверждения (описаны ниже) для проверки результатов в части Assert/Then.

#### 5.3.3. использование утверждений (assertions)

Утверждения — это специальные вызовы функций вашего фреймворка, которые проверяют, истинно ли какое-то условие. Если условие ложно, тест считается не прошедшим.

Следующая таблица приводит примеры типовых утверждений и объясняет, что они проверяют.

| тип утверждения (пример названия функции) | что проверяет это утверждение                                                                                                                                                                                                 | применимость в контексте безопасности                                                                                                                                                                                                                            |
| :---------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `assertEqual(ожидается, факт)`          | проверяет, равны ли два значения (числа, строки, объекты).                                                                                                                                                                    | проверка, что функция хеширования вернула ожидаемый хеш для известного входа. проверка, что функция санитизации вернула строку с правильно удаленными опасными символами. проверка, что функция вернула ожидаемый код ошибки при неверном входе.                  |
| `assertTrue(условие)`                   | проверяет, что условие является истинным.                                                                                                                                                                                     | проверка, что функция `canAccessResource` вернула `true`, когда у пользователя есть права. проверка, что функция `validatePassword` вернула `true` для сложного пароля.                                                                                           |
| `assertFalse(условие)`                  | проверяет, что условие является ложным.                                                                                                                                                                                       | проверка, что функция `canAccessResource` вернула `false`, когда у пользователя нет прав. проверка, что функция `validatePassword` вернула `false` для простого пароля.                                                                                             |
| `assertNull(объект)`                    | проверяет, что объект равен "ничему" (null).                                                                                                                                                                                  | проверка, что функция, которая должна удалить временные данные после использования, установила ссылку на объект данных в null.                                                                                                                                      |
| `assertNotNull(объект)`                 | проверяет, что объект не равен "ничему" (null).                                                                                                                                                                                | проверка, что функция аутентификации успешно создала объект сессии (не null) после успешного входа.                                                                                                                                                              |
| `assertThrows(тип_исключения, код_вызова)` | проверяет, что при выполнении определенного кода ожидается выброс исключения указанного типа.                                                                                                                                  | проверка, что попытка расшифровать данные неверным ключом приводит к выбрасыванию исключения `InvalidKeyException`. проверка, что попытка записи в файл без прав приводит к выбрасыванию исключения `PermissionDeniedException`.                                   |
| `assertContains(коллекция, элемент)`    | проверяет, что коллекция (список, набор) содержит определенный элемент.                                                                                                                                                        | проверка, что список зарегистрированных событий аудита, полученный от имитатора, содержит запись о неудачной попытке входа. проверка, что список разрешений для пользователя содержит конкретное разрешение "write".                                            |
| проверка вызова имитатора (mock assertion) | не стандартное утверждение фреймворка, а функция библиотеки мокирования. проверяет, был ли вызван определенный метод имитатора, сколько раз и с какими параметрами.                                                              | проверка, что имитатор журнала аудита был вызван методом `logEvent` один раз с параметрами "неудачный вход" и именем пользователя. проверка, что имитатор службы отправки писем был вызван методом `sendEmail` для уведомления администратора о событии безопасности. |

Выбирайте утверждения, которые наиболее точно проверяют ожидаемое поведение вашего кода в контексте безопасности.

#### 5.3.4. реализация тестовых двойников

Создайте заглушки, имитаторы и фейки для всех зависимостей, которые вы определили на этапе планирования. Используйте для этого возможности вашего фреймворка для тестирования или специальные библиотеки для мокирования. Настройте их поведение так, чтобы они либо возвращали нужные тестовые данные (заглушки, фейки), либо ожидали определенных вызовов от тестируемого кода (имитаторы).

#### 5.3.5. управление тестовыми данными

Тестовые данные, которые вы используете в UNIT-тестах, должны быть четко определены.
* **создание данных:** Используйте код или специальные инструменты для создания данных, которые выглядят как реальные, но не являются таковыми, и которые позволяют проверить все сценарии (например, разные типы паролей для проверки сложности, разные наборы прав доступа).
* **хранение данных:** Храните тестовые данные рядом с кодом тестов.
* **очистка данных:** После каждого теста убедитесь, что все данные или изменения состояния, которые создал тест, удалены, чтобы они не мешали другим тестам. Для этого используются фикстуры.

При работе с данными, которые в реальной системе являются конфиденциальными (пароли, ключи шифрования), **никогда не используйте реальные данные в тестах**. Создавайте специальные тестовые данные, которые имитируют формат и свойства реальных данных, но не имеют реальной ценности. Убедитесь, что эти тестовые данные не попадают в логи или отчеты тестов.

### 5.4. шаг 4: выполнение unit-тестов

UNIT-тесты должны запускаться автоматически и очень часто, чтобы быстро находить ошибки.

#### 5.4.1. интеграция в процесс сборки

Настройте систему сборки вашего проекта так, чтобы UNIT-тесты запускались каждый раз, когда вносятся изменения в код (например, при каждом коммите в систему контроля версий). Это обычно делается с помощью инструментов Непрерывной Интеграции (CI).

#### 5.4.2. настройка тестового окружения

Тесты должны выполняться в специальном месте — тестовом окружении. Это может быть отдельный сервер или виртуальная машина. Важно, чтобы это окружение было всегда одинаковым и содержало только то, что нужно для тестов, без влияния внешних систем.

#### 5.4.3. регулярный запуск тестов

Запускайте UNIT-тесты при каждом изменении кода. Это помогает сразу увидеть, "сломали" ли последние изменения какую-то функцию, в том числе связанную с безопасностью.

### 5.5. шаг 5: анализ результатов и отчетность

После выполнения тестов нужно посмотреть, что получилось, найти и исправить ошибки.

#### 5.5.1. интерпретация результатов

Каждый тест либо прошел (успех), либо не прошел (неудача). Если тест не прошел, это означает, что фактический результат работы кода отличается от того, что вы ожидали.

#### 5.5.2. анализ неудачных тестов

Если тест не прошел, нужно выяснить почему. Это может быть ошибка в коде, который вы тестируете, ошибка в самом тесте (например, неправильно настроен имитатор или ожидается неверный результат), или проблема с тестовыми данными или окружением. Инструменты для тестирования обычно показывают, в какой строке кода теста или тестируемого модуля произошла ошибка.

#### 5.5.3. фиксация дефектов

Найденные ошибки в коде, которые привели к неудаче теста, нужно записать в систему, где вы отслеживаете задачи и ошибки в проекте (например, Jira). Укажите, что это ошибка, найденная UNIT-тестом, и свяжите ее с соответствующим требованием безопасности (если возможно).

#### 5.5.4. генерация отчетов

Фреймворки UNIT-тестирования могут автоматически создавать отчеты о том, как прошли тесты.

Следующая таблица описывает информацию, которая должна содержаться в отчетах о UNIT-тестировании.

| тип информации в отчете | описание и назначение                                                                                                                                                              |
| :---------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| общее количество тестов | сколько всего unit-тестов было запущено.                                                                                                                                             |
| количество успешных тестов | сколько тестов завершилось успешно (все утверждения прошли).                                                                                                                         |
| количество неудачных тестов | сколько тестов не прошли (хотя бы одно утверждение провалилось).                                                                                                                     |
| список неудачных тестов | полный список тестов, которые не прошли, с указанием имени теста, сообщения об ошибке (что именно пошло не так) и трассировки стека (в какой строке кода произошла ошибка).             |
| время выполнения тестов | сколько времени занял запуск всего набора unit-тестов. важно для контроля скорости и возможности частых запусков.                                                                       |
| покрытие кода           | (если используются инструменты покрытия) метрики, показывающие процент покрытия исходного кода тестами (по строкам, ветвлениям, функциям). помогает оценить полноту тестирования.       |
| информация об окружении | (опционально) версия фреймворка, информация об операционной системе, среде выполнения. помогает воспроизвести условия запуска тестов при необходимости.                               |

Эти отчеты являются важной частью документации.

#### 5.5.5. связь отчетов с требованиями/вопросами

Используйте вашу таблицу связей и отчеты о тестах, чтобы показать, какие требования безопасности и "вопросы" аудиторов покрыты вашими UNIT-тестами, и что эти тесты прошли успешно. Это демонстрирует, что программа соответствует требованиям, которые будут проверяться.

## 6. важные технические детали

### 6.1. изоляция и управление зависимостями

Чтобы UNIT-тест проверял только один кусок кода, нужно убрать влияние всего остального, от чего этот кусок кода зависит (другие модули, внешние системы). Для этого используются тестовые двойники.

Следующая таблица приводит примеры зависимостей, которые часто нужно заменять тестовыми двойниками, и объясняет, почему это важно.

| тип зависимости тестируемого кода | почему эту зависимость нужно заменять тестовым двойником в unit-тесте                                                                                                                                                                                                                                                                                                                                                                                                     |
| :-------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| базы данных                       | реальная база данных требует установки, настройки, может работать медленно, ее состояние может меняться между запусками тестов, что делает тесты ненадежными. тестовый двойник (например, fake in-memory база или mock, проверяющий sql-запросы) обеспечивает быстрый и контролируемый доступ к данным или проверку взаимодействия с бд.                                                                                                                                  |
| файловая система                  | доступ к файлам может быть медленным, зависит от наличия файлов, прав доступа в операционной системе. тестовый двойник файловой системы (например, virtual in-memory fs) позволяет быстро создавать и читать файлы в памяти, имитировать ошибки доступа (например, "файл не найден", "доступ запрещен"), что важно для тестирования функций контроля доступа к файлам.                                                                                                    |
| сетевые вызовы (http, сокеты)     | зависят от доступности сети и удаленного сервиса, могут быть медленными, нестабильными. тестовый двойник (stub или mock) позволяет мгновенно вернуть нужный ответ от "удаленного" сервиса или проверить, что тестируемый код правильно отправил запрос. это критично для тестирования функций, взаимодействующих с внешними системами (например, сервисами аутентификации, серверами аудита по сети).                                                                  |
| системное время                   | время постоянно меняется. если логика кода зависит от времени, тест может давать разный результат при каждом запуске. тестовый двойник системного времени позволяет "заморозить" время или переместить его в будущее/прошлое, делая тесты повторяемыми.                                                                                                                                                                                                                 |
| генераторы случайных чисел        | если код использует случайные числа, результат может быть непредсказуемым. для повторяемости тестов нужно, чтобы генератор всегда выдавал одну и ту же последовательность "случайных" чисел. тестовый двойник позволяет контролировать последовательность, что важно, например, при тестировании функций генерации уникальных идентификаторов сессий или ключей (хотя криптографическая стойкость требует других проверок).                                              |
| взаимодействие с операционной системой | системные вызовы, работа с окружением зависят от ос и ее настроек. тестовый двойник позволяет имитировать поведение ос, например, возвращать определенные значения системных переменных окружения или имитировать успешное/неуспешное выполнение системных команд.                                                                                                                                                                                                     |
| внешние библиотеки                | некоторые библиотеки могут иметь сложные зависимости, требовать инициализации или иметь побочные эффекты. если вам нужно проверить только логику вашего кода, использующего такую библиотеку, ее можно заменить тестовым двойником, чтобы избежать сложностей.                                                                                                                                                                                                    |
| компоненты, работающие с оборудованием | например, модули, работающие с криптографическими токенами или аппаратными датчиками случайных чисел. их использование в unit-тестах невозможно или крайне затруднено. их заменяют имитаторами, которые имитируют ответы оборудования или проверяют правильность вызовов к нему.                                                                                                                                                                                     |

Выбор заглушки, имитатора или фейка зависит от того, что именно вы хотите проверить: только возвращаемое значение, взаимодействие с зависимостью или упрощенную рабочую логику.

### 6.2. тестирование функций безопасности на уровне модулей

UNIT-тесты отлично подходят для детальной проверки небольших кусков кода, которые отвечают за безопасность.

Следующая таблица приводит примеры функций безопасности и описывает, какие аспекты каждой из них можно проверить UNIT-тестами.

| функция безопасности                   | что unit-тест может проверить на уровне кода (примеры)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| :------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| аутентификация пользователя            | *проверка функции сравнения паролей:* правильно ли она сравнивает хеши паролей. *проверка функции валидации пароля:* соответствует ли пароль требованиям сложности (длина, наличие разных типов символов). *проверка логики обработки неудачных попыток:* увеличивается ли счетчик неудачных попыток при неверном пароле, блокируется ли учетная запись после заданного числа попыток (если эта логика в тестируемом модуле). *проверка обработки специальных символов в логине/пароле.* |
| авторизация/разграничение доступа      | *проверка функции проверки прав доступа:* правильно ли она определяет, имеет ли субъект (пользователь/роль) право на действие над объектом (ресурс) на основе заданных правил/политик. проверить сценарии с достаточными, недостаточными, отсутствующими правами. *проверка применения мандатных/дискреционных правил:* правильно ли код реализует конкретные правила доступа, описанные в документации фстэк или тз.                                                                                                                                                                                   |
| контроль целостности                   | *проверка функций вычисления/сравнения хешей:* правильно ли вычисляются хеши для разных данных (файлы, строки), совпадают ли они для идентичных данных, различаются ли для измененных. *проверка функций работы с электронной подписью:* правильно ли выполняется проверка подписи с использованием открытого ключа; проверка невалидных подписей, измененных данных.                                                                                                                                                                                                                                    |
| криптографические преобразования       | *проверка вызова криптографических функций:* правильно ли код вызывает функции из криптографических библиотек, используя верные параметры (ключи, векторы инициализации, режимы работы). *проверка шифрования/расшифрования:* зашифровать тестовые данные, затем расшифровать и проверить, что результат совпадает с исходными данными. проверить работу с разными блоками данных. *проверка генерации/верификации имитовставки (mac):* правильно ли вычисляется и проверяется mac для данных.                                                                                                 |
| аудит событий безопасности             | *проверка генерации событий:* используя имитатор журнала аудита, проверить, что тестируемый код вызывает функцию логирования при наступлении важных событий (успешный/неудачный вход, попытка доступа к запрещенному ресурсу, изменение настроек безопасности). *проверка содержимого событий:* проверить, что в событие аудита записывается вся необходимая информация (тип события, время, пользователь, результат, детали операции).                                                                                                                                                                 |
| санитизация и валидация входных данных | *проверка функции очистки (sanitization):* правильно ли функция удаляет или нейтрализует опасные символы или конструкции (например, html-теги, sql-операторы) из пользовательского ввода. *проверка функции проверки (validation):* правильно ли функция определяет, соответствуют ли входные данные ожидаемому формату или диапазону значений. проверить граничные значения, некорректные форматы.                                                                                                                                                                                          |
| обработка конфиденциальной информации  | *проверка зануления памяти:* если код работает напрямую с данными в памяти (например, ключами шифрования или паролями), проверить, что после использования память очищается (заполняется нулями). *проверка вызова функций безопасного удаления:* если код создает временные файлы или структуры с конфиденциальными данными, проверить, что вызываются функции для их безопасного удаления (например, многократная перезапись перед удалением, если это требуется политикой). |

### 6.3. тестирование конфигурации, влияющей на безопасность

Настройки программы часто определяют, как именно работают функции безопасности (например, какой таймаут сессии, какие алгоритмы шифрования использовать). UNIT-тесты могут помочь проверить, что код правильно использует эти настройки.

Используйте тестовые двойники или фикстуры, чтобы имитировать разные конфигурации (например, предоставить тестируемому коду "поддельные" настройки из памяти) и проверить, как код ведет себя при каждом варианте настроек безопасности. Например, протестировать функцию установления сессии, подавая разные значения таймаута сессии из имитированной конфигурации и проверяя, что сессия действительно завершается через заданное время.

## 7. инструменты и фреймворки

Для создания и запуска UNIT-тестов используются различные инструменты и наборы библиотек (фреймворки).

Следующая таблица описывает основные категории таких инструментов и их роль в процессе тестирования.

| категория инструмента                     | техническое описание и роль в методике                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| :---------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| фреймворки unit-тестирования              | это набор библиотек и инструментов, который предоставляет основу для написания и запуска unit-тестов. он определяет, как должны быть организованы тесты (например, в виде классов с методами, помеченными специальными метками), предоставляет функции для проверки результатов (утверждения — assert methods), управляет жизненным циклом теста (выполнение подготовительных действий перед тестом и завершающих после). является ядром всего процесса unit-тестирования.                                                                                                                                                                                                                                                                                                                                                                                                                            |
| библиотеки для имитации (mocking libraries) | это инструменты, которые облегчают создание тестовых двойников (заглушек, имитаторов). они позволяют "подменять" реальные объекты зависимостей на специальные тестовые объекты, которые вы можете настроить для возврата нужных значений или проверки вызовов. это позволяет изолировать тестируемый код от его зависимостей и полностью контролировать условия его работы.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| инструменты покрытия кода (code coverage) | это программы, которые анализируют, какая часть исходного кода вашей программы была реально выполнена (пройдена) во время запуска unit-тестов. они показывают процент покрытия по разным метрикам: количество пройденных строк кода, количество выполненных ветвлений (условий `if`/`else`), количество вызванных функций. эти инструменты помогают увидеть, какие части кода вообще не были затронуты тестами, и понять, где есть пробелы в тестировании. важно: высокий процент покрытия не гарантирует отсутствие ошибок, но низкий процент точно указывает на недостаток тестов.                                                                                                                                                                                                                                                                                                |
| системы непрерывной интеграции (ci)       | это серверные программы, которые автоматизируют процесс сборки вашего программного обеспечения, запуска unit-тестов и других автоматических проверок каждый раз, когда разработчики вносят изменения в код и загружают их в общее хранилище (систему контроля версий). ci-системы помогают быстро выявлять ошибки (включая ошибки, нарушающие тесты безопасности), которые могли быть внесены последними изменениями. они предоставляют централизованное место для запуска тестов и генерации отчетов.                                                                                                                                                                                                                                                                                                                                                                           |

Выбор конкретных инструментов зависит от языка программирования вашего проекта и принятых в команде практик.

## 8. типовые ошибки и пути их предотвращения

При написании UNIT-тестов, особенно для задач безопасности и сертификации, можно допустить ряд ошибок, которые снизят их эффективность или сделают результаты ненадежными.

В следующей таблице описаны некоторые из таких типовых ошибок и даны рекомендации, как их избежать.

| типовая ошибка                                     | описание ошибки и ее причина                                                                                                                                                                                                                                                                                                                         | последствия в контексте сертификации фстэк и безопасности                                                                                                                                                                                                                                                                                                                                                                                    | пути предотвращения этой ошибки                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| :------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **недостаточная изоляция тестов** | unit-тест зависит от внешних факторов или реальных зависимостей (например, реальная база данных, внешний сервис по сети, системное время, файлы на диске) или от порядка выполнения других тестов. это происходит, когда тестовые двойники не используются или используются неправильно.                                                                  | такие тесты часто нестабильны ("флуктуирующие"), их результаты могут меняться без видимых причин (например, из-за загрузки сети или изменения данных в базе). это затрудняет поиск настоящих ошибок. самое главное: невозможно проверить, как тестируемый код ведет себя при специфических, но важных для безопасности условиях (например, отказ доступа к файлу, очень долгий ответ от внешнего сервиса аутентификации), которые сложно или невозможно воспроизвести с реальными зависимостями. аудиторы могут усомниться в надежности таких тестов.                                                                                                                                                                                                                                        | **обязательно используйте тестовые двойники** (заглушки, имитаторы, фейки) для всех внешних зависимостей тестируемого кода. настройте их поведение, чтобы полностью контролировать условия теста. **используйте фикстуры** для сброса состояния тестового окружения перед каждым тестом, чтобы тесты были независимы друг от друга. **избегайте зависимости от системного времени или порядка выполнения тестов.** |
| **неполное покрытие сценариев безопасности** | написаны тесты только для "идеальных" ситуаций (правильные входные данные, все работает как должно), но проигнорированы негативные сценарии, граничные условия, некорректные или потенциально опасные входные данные, сценарии обработки ошибок, ситуации с недостаточными правами доступа.                                                               | критически важные дефекты безопасности могут остаться необнаруженными на низком уровне. ошибки в обработке некорректных или опасных данных, уязвимости, связанные с граничными условиями или неправильной обработкой ошибок, будут выявлены только на более поздних и дорогих этапах тестирования или, что хуже, аудиторами при сертификации/контроле.                                                                                                                                                                                                                                       | **проводите тщательный анализ требований безопасности и формализованных "вопросов"** для выявления всех потенциально опасных сценариев. **проектируйте тестовые сценарии целенаправленно** для негативных условий, граничных значений, ошибочных ситуаций, связанных именно с безопасностью (неверные учетные данные, попытка инъекции, отказ в доступе). **думайте как злоумышленник** при определении тестовых сценариев для функций безопасности. используйте техники тест-дизайна (классы эквивалентности, граничные значения) при планировании тестов безопасности.                                                                                                                                           |
| **тестирование слишком крупных "единиц" кода** | unit-тест проверяет не одну маленькую функцию или метод, а большой блок кода, состоящий из нескольких классов или даже модулей.                                                                                                                                                                                                                         | при неудаче теста очень трудно быстро понять, в каком конкретном месте большого блока кода находится ошибка. это замедляет исправление дефектов. тесты становятся больше похожи на интеграционные, теряя главное преимущество unit-тестов — быстроту выполнения и точную локализацию проблем.                                                                                                                                                                                                                                    | **строго придерживайтесь принципа unit-тестирования:** проверять минимальный изолируемый кусок кода (отдельный метод, функция, небольшой класс). если логика слишком сложная и распределена между несколькими классами, возможно, стоит пересмотреть структуру кода (провести рефакторинг), чтобы сделать его более модульным и легко тестируемым на низком уровне.                                                                                                                                                                  |
| **отсутствие четкой связи тестов с требованиями** | unit-тесты написаны, но нет понятной связи между каждым тестом и конкретным требованием безопасности, правилом из документации или "вопросом" сертификации, который этот тест проверяет.                                                                                                                                                                     | невозможно легко показать аудиторам фстэк, что все требования безопасности проверены тестами. трудно доказать полноту покрытия требований. сложно понять, почему был написан именно этот тест и какое правило безопасности он подтверждает. теряется ценность unit-тестов как доказательной базы для сертификации.                                                                                                                                                                                                                 | **обязательно ведите и поддерживайте в актуальном состоянии матрицу трассируемости,** связывающую требования безопасности, формализованные "вопросы", тестируемые единицы кода и unit-тесты. **используйте аннотации или комментарии в коде самих тестов,** указывающие на соответствующее требование или "вопрос" (например, `@Requirement("рд.сзи.тр.2012 п.4.1")`, `@FSTECQuestion("аутентификация: пустой пароль")`).                                                                                                |
| **тесты зависят от неконтролируемого окружения** | тесты полагаются на специфические настройки операционной системы, переменные окружения, или используют общие ресурсы (например, временные папки), которые могут быть изменены другими процессами или тестами.                                                                                                                                                  | тесты становятся невоспроизводимыми. они могут проходить на одной машине и падать на другой, или проходить при одном запуске и падать при следующем без изменений в коде. это делает результаты тестов ненадежными и затрудняет автоматизацию в ci-системах.                                                                                                                                                                                                                                    | **запускайте тесты в контролируемом, изолированном тестовом окружении** (например, в контейнере docker или виртуальной машине), где все зависимости и настройки стандартизированы. **избегайте использования общих или нестабильных ресурсов** в тестах. если нужно имитировать окружение, используйте тестовые двойники.                                                                                                                                                                                                                                |
| **недостаточно детальные или некорректные утверждения** | утверждения в тесте проверяют только факт выполнения метода без ошибок, но не проверяют точность возвращаемых значений, корректность изменения состояния объекта, правильность параметров вызова зависимостей (через имитаторы), или не проверяют обработку всех ожидаемых типов ошибок.                                                               | тест может пройти успешно, даже если тестируемый код выполнил операцию некорректно с точки зрения безопасности (например, вернул неправильно зашифрованные данные, неверно определил права доступа, записал в аудит неполную информацию, выбросил исключение неверного типа). дефект безопасности останется незамеченным тестом.                                                                                                                                                                                                                  | **пишите полные и точные утверждения,** которые проверяют все аспекты ожидаемого поведения uut: возвращаемое значение, конечное состояние объекта uut, все важные взаимодействия с имитаторами (какие методы были вызваны, сколько раз, с какими параметрами), тип и содержимое выброшенных исключений. **базируйте утверждения на точной спецификации поведения uut и требованиях безопасности.** |
| **сложность или низкое качество кода тестов** | код самих unit-тестов плохо написан: он сложен для понимания, содержит много повторений, не структурирован, плохо читается другими инженерами.                                                                                                                                                                                                            | такие тесты трудно поддерживать. при внесении изменений в тестируемый код (рефакторинг) приходится тратить много времени на изменение тестов, и при этом легко внести ошибки в сами тесты. это снижает доверие к тестам и их актуальность со временем.                                                                                                                                                                                                                                    | **применяйте принципы "чистого кода" (clean code) и к коду тестов.** **рефакторите тестовый код** так же, как и основной код. **используйте вспомогательные методы и фикстуры** для устранения дублирования кода в тестах. **код теста должен быть проще кода, который он тестирует.** |

## 9. верификация unit-тестов и документирование

Важно не только написать UNIT-тесты, но и убедиться, что сами тесты правильные (не содержат ошибок) и надежно проверяют нужные аспекты кода. А также нужно правильно оформить всю информацию о тестировании для проверяющих.

### 9.1. верификация корректности unit-тестов

Даже в коде тестов могут быть ошибки. Как проверить, что ваши тесты работают так, как нужно, и действительно выявляют дефекты, а не дают ложные результаты?

В следующей таблице описаны подходы к проверке качества самих UNIT-тестов.

| подход к верификации качества тестов | как это работает и почему это помогает                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :----------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| анализ покрытия кода                 | использование инструментов покрытия кода (code coverage tools) для определения, какие части исходного кода были выполнены во время запуска тестов. **почему помогает:** если какая-то часть кода, особенно связанная с безопасностью, вообще не была выполнена тестами, это явный признак пробела в тестировании. важно анализировать не только покрытие по строкам, но и покрытие по ветвлениям (условиям if/else) и функциям, чтобы убедиться, что проверены разные пути выполнения кода.                                                                                                                                |
| мутационное тестирование             | использование специальных инструментов, которые автоматически вносят маленькие, типовые ошибки (мутации) в исходный код программы (например, меняют логический оператор `&&` на `||`, заменяют константу, удаляют строку). затем запускаются unit-тесты. **почему помогает:** если unit-тест написан правильно и проверяет участок кода, где произошла мутация, он должен "сломаться" (тест "убивает" мутацию). если тест не падает, это может означать, что тест недостаточно хорошо проверяет этот участок кода, и его нужно улучшить, или что мутация эквивалентна исходному коду (редко).                                       |
| code review тестового кода           | процесс анализа кода unit-тестов другими инженерами из команды. **почему помогает:** другой человек может заметить логические ошибки в тесте, неправильно написанные утверждения, некорректную настройку тестовых двойников, проблемы с изоляцией или плохую читаемость кода теста. взгляд со стороны помогает выявить ошибки, которые мог пропустить автор теста.                                                                                                                                                                                                                                              |
| парное программирование при написании тестов | практика, когда два инженера работают за одним компьютером: один пишет код (драйвер), другой наблюдает, обдумывает и предлагает идеи (навигатор). **почему помогает:** при написании тестов в паре происходит немедленное обсуждение сценариев, входных данных, ожидаемых результатов и способов проверки (утверждений). это позволяет на лету выявлять и исправлять логические ошибки, уточнять понимание требований и повышать качество кода тестов сразу в процессе написания.                                                                                                                             |

### 9.2. документирование процесса и результатов unit-тестирования

Для целей сертификации и инспекционного контроля ФСТЭК важно не только проводить тесты, но и иметь возможность доказать, что тесты были проведены правильно, и показать их результаты. Документация — это часть этой доказательной базы.

В следующей таблице приведены основные типы документации, связанные с UNIT-тестированием в данном контексте.

| тип документации                          | что этот документ должен описывать и зачем он нужен                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :---------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| методика тестирования                     | документ (например, настоящий), описывающий общий подход вашей команды к написанию unit-тестов, принципы, этапы процесса, используемые инструменты, стратегии тестирования (например, как тестируются функции безопасности). **зачем нужен:** показывает аудиторам, что у вас есть формализованный, систематический процесс тестирования.                                                                                                                                                                                                                                                                                                       |
| матрица трассируемости                    | таблица (как описано в разделе 5.1.4), связывающая требования безопасности, формализованные "вопросы" сертификации/контроля, тестируемые единицы кода и unit-тесты. **зачем нужна:** демонстрирует полноту покрытия требований безопасности unit-тестами, помогает убедиться, что все важные аспекты безопасности проверены, и облегчает поиск тестов, относящихся к конкретному требованию или "вопросу".                                                                                                                                                                                                                            |
| планы unit-тестов (для критичных модулей) | более детальное описание тестовых сценариев (входные данные, действия, ожидаемые результаты) для наиболее критичных с точки зрения безопасности модулей, если эта информация не полностью очевидна из кода тестов. **зачем нужен:** предоставляет дополнительное описание проверок для аудиторов, особенно для сложных сценариев или сценариев, связанных с нормативными требованиями.                                                                                                                                                                                                                                                   |
| исходный код unit-тестов                  | сам код ваших unit-тестов. **зачем нужен:** это наиболее точное и актуальное описание всех выполняемых проверок. код должен быть чистым, понятным, с комментариями, объясняющими специфику проверок безопасности или использование тестовых двойников.                                                                                                                                                                                                                                                                                                                                                                    |
| отчеты о выполнении тестов                | автоматически сгенерированные отчеты после каждого запуска набора unit-тестов, содержащие информацию о количестве пройденных/неудачных тестов, деталях ошибок, покрытии кода. **зачем нужны:** являются объективным доказательством результатов тестирования. показывают, что тесты регулярно выполняются, и помогают отслеживать качество кода. могут быть представлены аудиторам в качестве подтверждения.                                                                                                                                                                                                                         |
| информация о тестовом окружении           | описание среды, в которой выполняются unit-тесты (операционная система, версии используемых фреймворков и библиотек, конфигурация). **зачем нужна:** обеспечивает воспроизводимость результатов тестирования и позволяет аудиторам понять условия, в которых проводились тесты.                                                                                                                                                                                                                                                                                                                                                  |
| процедуры выполнения тестов               | описание шагов или команд для запуска unit-тестов, например, в рамках системы ci/cd. **зачем нужна:** формализует процесс запуска тестов, показывает, что тесты являются частью автоматизированного процесса разработки.                                                                                                                                                                                                                                                                                                                                                                                                 |
| результаты анализа дефектов             | информация об ошибках, найденных с помощью unit-тестов, их описание, связь с требованиями безопасности, статус исправления. **зачем нужна:** демонстрирует, что процесс тестирования эффективен и позволяет выявлять и устранять дефекты, влияющие на безопасность.                                                                                                                                                                                                                                                                                                                                                              |

Вся документация должна быть актуальной, храниться в доступном месте и быть готовой для предоставления аудиторам.

## 10. заключение

UNIT-тестирование — это необходимый и очень эффективный инструмент в процессе разработки программного обеспечения, особенно когда речь идет о подтверждении его соответствия строгим требованиям безопасности, как в случае сертификации ФСТЭК и инспекционного контроля.

Применение описанной методики позволяет систематизировать подход к созданию UNIT-тестов, сделать их сфокусированными на проверке критически важных с точки зрения безопасности аспектов программы и обеспечить их надежность. Использование тестовых двойников, тщательное планирование сценариев (включая негативные и ошибочные), автоматизация выполнения и анализ результатов с привязкой к требованиям — все это создает прочную основу для выявления дефектов на ранних этапах и формирования убедительной доказательной базы для аудиторов.

Следуя этой методике, инженеры могут создавать высококачественные UNIT-тесты, которые не только улучшают стабильность и надежность программы в целом, но и играют ключевую роль в успешном прохождении процедур оценки соответствия по требованиям безопасности информации.
