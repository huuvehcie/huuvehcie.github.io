# Методика создания UNIT-тестов для вопросов проведения сертификации ПО во ФСТЭК и инспекционного контроля

## Содержание

* [1. Введение](#1-введение)
* [2. Глоссарий терминов](#2-глоссарий-терминов)
* [3. Контекст сертификация ПО во ФСТЭК и инспекционный контроль](#3-контекст-сертификация-по-во-фстэк-и-инспекционный-контроль)
* [4. Назначение UNIT-тестирования в контексте ФСТЭК](#4-назначение-unit-тестирования-в-контексте-фстэк)
* [5. Методология создания UNIT-тестов для вопросов сертификации](#5-методология-создания-unit-тестов-для-вопросов-сертификации)
    * [5.1. Шаг 1 Анализ требований и превращение вопросов в задачи для тестов](#51-шаг-1-анализ-требований-и-превращение-вопросов-в-задачи-для-тестов)
        * [5.1.1. Поиск правил безопасности которые касаются вашей программы](#511-поиск-правил-безопасности-которые-касаются-вашей-программы)
        * [5.1.2. Определение какой код выполняет эти правила](#512-определение-какой-код-выполняет-эти-правила)
        * [5.1.3. Формализация вопросов сертификацииконтроля](#513-формализация-вопросов-сертификацииконтроля)
        * [5.1.4. Создание матрицы трассируемости](#514-создание-матрицы-трассируемости)
    * [5.2. Шаг 2 Проектирование UNIT-тестов](#52-шаг-2-проектирование-unit-тестов)
        * [5.2.1. Определение тестируемых единиц](#521-определение-тестируемых-единиц)
        * [5.2.2. Определение тестовых сценариев](#522-определение-тестовых-сценариев)
        * [5.2.3. Определение входных данных и ожидаемых результатов](#523-определение-входных-данных-и-ожидаемых-результатов)
        * [5.2.4. Определение необходимых имитаторов заглушек и фейков](#524-определение-необходимых-имитаторов-заглушек-и-фейков)
    * [5.3. Шаг 3 Реализация UNIT-тестов](#53-шаг-3-реализация-unit-тестов)
        * [5.3.1. Выбор фреймворка для UNIT-тестирования](#531-выбор-фреймворка-для-unit-тестирования)
        * [5.3.2. Написание кода тестов](#532-написание-кода-тестов)
        * [5.3.3. Использование утверждений Assertions](#533-использование-утверждений-assertions)
        * [5.3.4. Реализация тестовых двойников](#534-реализация-тестовых-двойников)
        * [5.3.5. Управление тестовыми данными](#535-управление-тестовыми-данными)
        * [5.3.6. Обработка чувствительных данных в тестах](#536-обработка-чувствительных-данных-в-тестах)
    * [5.4. Этап 4 Выполнение UNIT-тестов](#54-этап-4-выполнение-unit-тестов)
        * [5.4.1. Интеграция в процесс сборки](#541-интеграция-в-процесс-сборки)
        * [5.4.2. Настройка тестового окружения](#542-настройка-тестового-окружения)
        * [5.4.3. Регулярный запуск тестов](#543-регулярный-запуск-тестов)
    * [5.5. Этап 5 Анализ результатов и отчетность](#55-этап-5-анализ-результатов-и-отчетность)
        * [5.5.1. Интерпретация результатов](#551-интерпретация-результатов)
        * [5.5.2. Анализ неудачных тестов](#552-анализ-неудачных-тестов)
        * [5.5.3. Фиксация дефектов](#553-фиксация-дефектов)
        * [5.5.4. Генерация отчетов](#554-генерация-отчетов)
        * [5.5.5. Связь отчетов с требованиямивопросами](#555-связь-отчетов-с-требованиямивопросами)
* [6. Важные технические детали](#6-важные-технические-детали)
    * [6.1. Изоляция и управление зависимостями](#61-изоляция-и-управление-зависимостями)
    * [6.2. Тестирование функций безопасности на уровне модулей](#62-тестирование-функций-безопасности-на-уровне-модулей)
    * [6.3. Тестирование конфигурации влияющей на безопасность](#63-тестирование-конфигурации-влияющей-на-безопасность)
* [7. Инструменты и фреймворки](#7-инструменты-и-фреймворки)
* [8. Типовые ошибки и пути их предотвращения](#8-типовые-ошибки-и-пути-их-предотвращения)
* [9. Верификация UNIT-тестов и документирование](#9-верификация-unit-тестов-и-документирование)
    * [9.1. Верификация корректности UNIT-тестов](#91-верификация-корректности-unit-тестов)
    * [9.2. Документирование процесса и результатов UNIT-тестирования](#92-документирование-процесса-и-результатов-unit-тестирования)
* [10. Заключение](#10-заключение)

## 1. Введение

Настоящий документ представляет собой техническую методику создания UNIT-тестов, ориентированную на верификацию корректности реализации программного обеспечения (ПО) в части, имеющей отношение к вопросам, возникающим в процессе проведения сертификации ПО во ФСТЭК России и последующего инспекционного контроля. Документ предназначен для инженеров-разработчиков и инженеров по тестированию, ответственных за обеспечение соответствия ПО требованиям безопасности информации.

Этот документ объясняет, как писать UNIT-тесты для компьютерных программ. Эти тесты помогают убедиться, что программа работает правильно, особенно в тех частях, которые важны для получения специального разрешения ФСТЭК России или при последующих проверках.

Целью документа является формализация процесса разработки низкоуровневых автоматизированных тестов, позволяющих на ранних этапах жизненного цикла разработки выявлять дефекты и несоответствия, критичные с точки зрения требований безопасности информации и специфических "вопросов", которые могут быть подняты органом по сертификации или контролирующими организациями. Методика обеспечивает систематизированный подход к созданию верифицируемых и воспроизводимых доказательств корректной работы отдельных компонентов ПО в контексте применимых требований. Мы подготовили эту методику для инженеров — людей, которые пишут программы или проверяют их работу. Она поможет создать автоматические тесты для проверки отдельных кусочков программы. Такие тесты нужны, чтобы найти ошибки и убедиться, что программа соответствует требованиям безопасности. Это особенно важно, когда программу проверяют для сертификации или во время инспекционного контроля.

Наша цель — дать понятные шаги для написания верифицируемых и воспроизводимых тестов, которые покажут, что отдельные части программы работают так, как ожидается, особенно в ситуациях, связанных с безопасностью информации.

## 2. Глоссарий терминов

В этом разделе собраны и объяснены специальные слова и понятия, которые используются в данном документе. Понимание этих терминов необходимо для правильного применения описанной методики.

| Термин | Определение |
| :--- | :--- |
| UNIT-тест (Юнит-тест) | Самый базовый вид автоматического теста. Он проверяет самую маленькую, отдельно работающую часть программы (например, одну функцию, один метод класса или небольшой класс). Цель — убедиться, что этот конкретный, изолированный кусочек кода выполняет свою задачу правильно при различных входных данных и условиях. |
| Программное Обеспечение (ПО) | Полный набор инструкций (программ), которые говорят компьютеру, что делать, а также связанных с ними данных. |
| ФСТЭК России | Федеральная служба по техническому и экспортному контролю. Государственный орган Российской Федерации, отвечающий, в частности, за регулирование в области защиты информации, выдачу сертификатов соответствия на средства защиты информации и информационные технологии. |
| Сертификация ПО во ФСТЭК | Процедура подтверждения соответствия программного обеспечения установленным требованиям безопасности информации, выполняемая органом по сертификации, аккредитованным ФСТЭК России. Результатом успешного прохождения процедуры является выдача сертификата соответствия, разрешающего использование ПО в информационных системах с определенным классом защищенности. |
| Инспекционный Контроль | Плановая или внеплановая проверка сертифицированного программного обеспечения, проводимая ФСТЭК России или аккредитованным органом по сертификации после выдачи сертификата. Цель — убедиться, что ПО продолжает соответствовать требованиям безопасности после внесения изменений или в процессе эксплуатации. |
| Вопросы проведения сертификации/инспекционного контроля | Конкретные пункты программы оценки соответствия, требования, тесты или проверки, выполняемые экспертами (аудиторами) органа по сертификации или ФСТЭК России в ходе сертификационных испытаний или инспекционного контроля. Они детализируют, какие аспекты безопасности ПО подлежат проверке. |
| Требования безопасности информации | Правила, стандарты, условия и спецификации, которым должно соответствовать программное обеспечение для обеспечения защиты информации от угроз (несанкционированный доступ, изменение, уничтожение, блокирование и др.). Они могут быть установлены законодательством, нормативными документами ФСТЭК, государственными стандартами, техническими заданиями. |
| Функции безопасности | Части программного кода или модули ПО, реализующие конкретные механизмы защиты информации. К ним относятся, например, функции аутентификации пользователя, авторизации (проверки прав доступа), контроля целостности данных, шифрования, регистрации событий аудита. |
| Недекларированные возможности | Функциональные возможности программного обеспечения, не описанные в документации, которые могут быть использованы для получения несанкционированного доступа к информации, изменения или уничтожения информации, а также для воздействия на функционирование программного обеспечения или информационной системы в целом. Проверяется их отсутствие. |
| Трассируемость | Возможность установить и проследить логическую связь между различными элементами проекта разработки (например, между требованием безопасности, соответствующим фрагментом исходного кода и UNIT-тестом, который этот фрагмент проверяет). Обеспечивает прозрачность и полноту проверки требований. |
| Тестовый сценарий | Подробное описание шагов, условий и ожидаемого результата, необходимых для выполнения конкретной проверки функциональности или свойства программного обеспечения. Используется как план для написания автоматического теста. |
| Тестовые двойники | Объекты или компоненты, созданные специально для тестирования, которые заменяют реальные зависимости тестируемого кода (другие модули, базы данных, сетевые сервисы, файловая система). Используются для изоляции UNIT-тестируемого кода и управления его окружением. Основные типы: Заглушка, Имитатор, Фейк. |
| Заглушка (Stub) | Простейший вид тестового двойника. Используется для подмены зависимости, когда тестируемому коду нужен только определенный заранее заданный ответ от этой зависимости. Заглушка просто возвращает фиктивное значение и не содержит сложной логики или проверок. |
| Имитатор (Mock) | Тестовый двойник, который не только возвращает заранее заданные значения, но и позволяет проверить, что тестируемый код правильно взаимодействует с этой зависимостью — вызывает определенные методы с нужными параметрами и в правильном порядке. Используется для проверки *взаимодействия*, а не только *результата*. |
| Фейк (Fake) | Тестовый двойник, который имеет упрощенную, но рабочую реализацию логики реальной зависимости (например, базу данных, которая работает только в памяти). Используется, когда заглушки или имитаторы недостаточны, но полная реальная зависимость избыточна или сложна для использования в тесте. |
| Утверждение (Assertion) | Оператор или вызов функции в коде теста, который проверяет истинность определенного условия — сравнивает фактический результат выполнения тестируемого кода с ожидаемым результатом. Если условие истинно, утверждение проходит. Если ложно, утверждение проваливается, и тест помечается как неудачный. |
| Фикстура (Fixture) | Код или данные, которые подготавливают тестовое окружение для выполнения одного или нескольких тестов (например, создают необходимые объекты, загружают тестовые данные, настраивают имитаторы) и очищают его после выполнения тестов. Гарантируют, что каждый тест выполняется в одинаковых, предсказуемых условиях. |
| UUT (Unit Under Test) | Единица (часть) программного обеспечения, которая непосредственно проверяется конкретным UNIT-тестом. |
| Arrange-Act-Assert (AAA) | Популярный шаблон организации кода UNIT-теста, разделяющий его на три логических части: Arrange (Подготовка окружения), Act (Выполнение тестируемого кода), Assert (Проверка результата с помощью утверждений). |
| Given-When-Then (GWT) | Альтернативный шаблон для организации UNIT-тестов, часто используемый в поведении-ориентированном тестировании. Структурирует тест в виде "Дано" (исходное состояние), "Когда" (происходит действие), "Тогда" (ожидаемый результат). |
| CI/CD (Continuous Integration / Continuous Delivery) | Набор практик в разработке ПО, направленных на частую и автоматическую интеграцию изменений кода, выполнение автоматизированных тестов (CI) и, при успешном прохождении тестов, автоматизированную подготовку к выпуску или выпуск новой версии ПО (CD). |
| Покрытие кода (Code Coverage) | Метрика, показывающая, какая часть исходного кода программы была выполнена (пройдена) во время выполнения определенного набора тестов. Помогает оценить, насколько полно тесты затрагивают различные части кода. Измеряется в процентах (по строкам, ветвлениям, функциям). |
| Мутационное тестирование (Mutation Testing) | Техника для оценки качества самих тестов. Специальные инструменты вносят небольшие автоматические изменения (мутации) в исходный код программы (например, меняют логический оператор `&&` на `||`, заменяют константу, удаляют строку). Затем запускаются тесты. Если тест разработан правильно и проверяет участок кода, где произошла мутация, он должен "сломаться" ("убить" мутацию). Если тест не падает, возможно, он неэффективен. |

## 3. Контекст: сертификация ПО во ФСТЭК и инспекционный контроль

Сертификация ПО во ФСТЭК России является процедурой подтверждения соответствия программного обеспечения требованиям стандартов, руководящих документов и технических условий по безопасности информации. В процессе сертификации оценивается не только функциональность, но и защищенность ПО, отсутствие недекларированных возможностей, корректность реализации механизмов защиты информации. Сертификация во ФСТЭК — это как экзамен для вашей программы, где проверяют, насколько она безопасна. ФСТЭК или специальные лаборатории смотрят не только, работает ли программа по инструкции, но и защищает ли она информацию, нет ли в ней скрытых опасных функций (недекларированных возможностей) и правильно ли реализованы все механизмы защиты.

"Вопросы проведения сертификации" и "вопросы инспекционного контроля" представляют собой набор конкретных проверок, тестов, анализов и требований, выдвигаемых органом по сертификации или ФСТЭК России к ПО. Эти вопросы могут касаться:
* Корректности реализации функций безопасности (аутентификация, авторизация, контроль целостности, аудит событий безопасности, криптографические преобразования).
* Правильности обработки конфиденциальной информации.
* Соответствия внутренней архитектуры и структуры кода заявленным свойствам безопасности.
* Отсутствия известных уязвимостей в используемых компонентах.
* Корректности обработки исключительных ситуаций, влияющих на безопасность.
* Соответствия поведения ПО требованиям доверия (например, требованиям к исходным текстам, процедурам разработки, контролю версий).

В следующей таблице приведены примеры типовых областей и связанных с ними "вопросов", которые могут возникнуть в процессе сертификации или контроля.

| Область проверки безопасности | Пример "вопроса" сертификации/контроля |
| :--- | :--- |
| Аутентификация пользователя | Как программа проверяет подлинность пользователя при входе? Какие требования к сложности пароля применяются? Что происходит при вводе неверных учетных данных? |
| Авторизация и разграничение доступа | Правильно ли программа определяет, к каким данным или функциям имеет доступ конкретный пользователь? Что происходит, если пользователь пытается получить доступ к запрещенному ресурсу? |
| Контроль целостности | Как программа убеждается, что важные файлы или данные не были изменены без разрешения? Проверяется ли целостность исполняемых файлов самой программы при запуске? |
| Обработка конфиденциальных данных | Как программа защищает чувствительные данные (например, пароли, персональные данные) во время их обработки и хранения? Правильно ли выполняется шифрование или обезличивание? |
| Регистрация и аудит событий безопасности | Какие действия пользователя или системные события регистрируются программой? Содержат ли записи аудита всю необходимую информацию (кто, что, когда, результат)? |
| Обработка ошибок и исключений | Как программа реагирует на ошибки, которые могут повлиять на безопасность (например, сбой при записи в журнал аудита)? Не раскрывает ли программа слишком много информации об ошибках, которая может быть использована злоумышленником? |
| Проверка ввода пользовательских данных | Как программа обрабатывает данные, которые вводит пользователь? Проверяются ли данные на наличие опасных символов или команд, которые могут привести к атакам (например, SQL-инъекции, XSS)? |

Инспекционный контроль, в свою очередь, является периодической проверкой сертифицированного ПО с целью подтверждения сохранения его характеристик безопасности после внесения изменений или в процессе эксплуатации. Вопросы инспекционного контроля часто фокусируются на изменениях, внесенных в ПО, и их влиянии на безопасность. Инспекционный контроль — это проверка того, что программа остается безопасной после того, как вы ее обновили или внесли изменения. "Вопросы" тут часто связаны с тем, как эти изменения повлияли на функции безопасности.

## 4. Назначение UNIT-тестирования в контексте ФСТЭК

UNIT-тестирование — это процесс автоматизированной проверки наименьших изолируемых частей (единиц, модулей) исходного кода ПО на предмет их корректного функционирования. В контексте сертификации ФСТЭК и инспекционного контроля, UNIT-тестирование приобретает дополнительное значение как инструмент для:

* **Раннего выявления дефектов безопасности:** Обнаружение ошибок в реализации функций безопасности или обработке данных на самом низком уровне, до интеграции с другими компонентами. UNIT-тесты помогают найти ошибки безопасности очень рано — обнаружить проблемы в коде, который отвечает за безопасность (например, ошибка в функции проверки пароля или неправильная обработка прав доступа), еще до того, как этот код будет собран с другими частями программы. Это значительно дешевле и быстрее, чем искать их позже, когда все части собраны вместе.
* **Верификации реализации специфических требований безопасности:** Проверка корректности работы отдельных алгоритмов, функций или фрагментов кода, напрямую связанных с выполнением требований нормативных документов ФСТЭК или технических заданий на защиту информации. UNIT-тесты позволяют точно проверить, правильно ли реализованы отдельные правила безопасности или функции защиты, которые требуются документами ФСТЭК или техническим заданием. Например, удостовериться, что функция шифрования вызывает криптографическую библиотеку с правильными параметрами.
* **Предоставления объективных доказательств:** Автоматизированные UNIT-тесты служат воспроизводимым доказательством того, что конкретная единица кода ведет себя в соответствии с ожидаемым поведением, в том числе в сценариях, критичных для безопасности. UNIT-тесты дают понятное и воспроизводимое доказательство того, что проверенный кусок кода ведет себя правильно в различных сценариях, в том числе важных для безопасности.
* **Снижения рисков в процессе инспекционного контроля:** Наличие актуального набора UNIT-тестов, покрывающего критичные для безопасности компоненты, упрощает доказательство отсутствия негативного влияния внесенных изменений на функции безопасности. Если у вас есть большой набор UNIT-тестов, покрывающих критичные для безопасности части программы, вы можете показать аудиторам, что регулярно проверяете эти части, и что последние изменения не нарушили их работу. Это упрощает прохождение инспекционного контроля.
* **Улучшения качества кода:** UNIT-тестирование способствует созданию более модульного, слабо связанного и легко поддерживаемого кода, что снижает вероятность внесения ошибок при модификации. Процесс написания UNIT-тестов часто подталкивает разработчиков создавать код, который легче тестировать. Такой код обычно более четко разделен на части, проще для понимания и поддержки, что само по себе снижает вероятность появления ошибок.

UNIT-тесты в данном контексте не заменяют другие виды тестирования (интеграционное, системное, тестирование безопасности, анализ уязвимостей), но являются фундаментом для построения системы доказательств соответствия ПО требованиям безопасности на низком уровне детализации. UNIT-тесты не могут проверить *все* аспекты безопасности (например, они не найдут проблемы, связанные с тем, как разные части программы взаимодействуют, или проблемы в настройке всей системы), но они дают надежную основу и проверяют правильность работы отдельных важных компонентов.

При разработке UNIT-тестов для ПО, проходящего сертификацию или инспекционный контроль во ФСТЭК, необходимо строго придерживаться следующих принципов. UNIT-тестирование — это не просто хорошая практика, а важный инструмент, когда ваша программа должна пройти проверку на безопасность для ФСТЭК. Следуя этим принципам, вы сможете создавать тесты, которые точно проверяют важные части программы, связанные с безопасностью, и предоставляют надежные доказательства того, что программа работает правильно.

* **Изоляция.** Каждая единица кода (класс, функция, метод) должна тестироваться изолированно от зависимостей. Использование заглушек (stubs), имитаторов (mocks) и фикстур (fixtures) является обязательным для обеспечения повторяемости результатов теста и исключения влияния внешних факторов или состояния других компонентов. Цель — проверить только логику тестируемого блока. Каждый тест должен проверять только один маленький кусок кода и не зависеть от других частей программы или внешних условий.
* **Автоматизация.** Все UNIT-тесты должны быть полностью автоматизированы и запускаться без ручного вмешательства. Это обеспечивает возможность частых запусков (например, при каждом изменении кода) и интеграцию в процессы непрерывной интеграции/непрерывной поставки (CI/CD). Тесты должны запускаться автоматически, без участия человека.
* **Повторяемость (Воспроизводимость).** Результат выполнения одного и того же UNIT-теста при неизменном исходном коде и тестовом окружении всегда должен быть одинаковым. Недетерминированные тесты недопустимы. Зависимость от времени, порядка выполнения тестов или внешних изменяемых ресурсов (файловая система, сеть, база данных) должна быть исключена или управляема. Один и тот же тест, запущенный несколько раз при тех же условиях, всегда должен давать один и тот же результат.
* **Независимость.** Каждый UNIT-тест должен быть независим от других UNIT-тестов. Порядок выполнения тестов не должен влиять на их результат. Состояние, созданное одним тестом, не должно влиять на последующие тесты. Результат одного теста не должен влиять на результат другого теста.
* **Быстрота выполнения.** UNIT-тесты должны выполняться максимально быстро. Время выполнения полного набора UNIT-тестов должно измеряться секундами или минутами, чтобы не тормозить процесс разработки и частые запуски в CI/CD. Тесты должны выполняться очень быстро, чтобы их можно было запускать часто.
* **Релевантность к требованиям безопасности.** Приоритет при написании UNIT-тестов должен отдаваться проверке тех аспектов кода, которые напрямую связаны с требованиями безопасности, функциями защиты, обработкой конфиденциальных данных и потенциальными "вопросами" со стороны органа по сертификации или ФСТЭК. В первую очередь нужно тестировать те части кода, которые напрямую связаны с функциями безопасности и требованиями ФСТЭК.
* **Трассируемость.** Должна быть обеспечена четкая связь между UNIT-тестом, тестируемой единицей кода и соответствующим требованием безопасности или "вопросом" сертификации/контроля. Эта связь облегчает демонстрацию покрытия требований тестами и анализ результатов аудиторам. Должна быть четкая связь между тестом, кодом, который он проверяет, и правилом безопасности, для которого этот тест написан.
* **Читаемость и поддерживаемость.** Код UNIT-тестов должен быть чистым, понятным и хорошо документированным. Тесты должны легко читаться инженерами, не знакомыми с тестируемым кодом, чтобы обеспечить их актуальность и поддерживаемость на протяжении всего жизненного цикла ПО. Код тестов должен быть понятным другим инженерам.
* **Полное покрытие (насколько практически возможно).** Стремление к максимальному покрытию кода UNIT-тестами, особенно критически важных для безопасности модулей. Покрытие должно оцениваться не только по строкам кода, но и по ветвлениям, условиям, путям выполнения.

## 5. Методология создания UNIT-тестов для вопросов сертификации

Процесс создания UNIT-тестов, ориентированных на специфику сертификации ФСТЭК, включает следующие этапы. Процесс создания UNIT-тестов, полезных для сертификации ФСТЭК, состоит из нескольких последовательных шагов.

### 5.1. Шаг 1: Анализ требований и превращение "вопросов" в задачи для тестов

Этот этап является критически важным и специфичным для данного контекста. Необходимо преобразовать формальные требования безопасности и потенциальные неформализованные "вопросы" аудиторов в конкретные, проверяемые технические утверждения. Этот шаг самый важный и требует внимательного изучения документов и понимания, что именно будут проверять аудиторы.

#### 5.1.1. Поиск правил безопасности, которые касаются вашей программы

На этом этапе вы изучаете все документы, где описаны требования к безопасности вашей программы. Цель — найти конкретные, измеримые требования, которые можно проверить. Анализируются документы, определяющие требования к ПО:
* Нормативные документы ФСТЭК России (например, требования к уровням доверия, профили защиты).
* Техническое задание на создание системы защиты информации или техническое задание на ПО.
* Эксплуатационная документация на ПО, описывающая функции безопасности.
* Технические условия (ТУ) на ПО.
* Иные применимые стандарты или политики безопасности.

Из этих документов извлекаются конкретные, верифицируемые требования к поведению ПО или его компонентов, связанные с безопасностью. Из этих документов нужно "вытащить" конкретные формулировки, которые можно проверить.

Следующая таблица показывает, какие типы документов могут содержать такую информацию и на что в них нужно обращать внимание.

| Тип документа | Что искать в этих документах |
| :--- | :--- |
| Нормативные документы ФСТЭК России | Общие требования к уровням доверия ПО, требования к системам защиты информации. Ищите конкретные пункты, описывающие функции безопасности (например, требования к механизмам аутентификации, контроля доступа, аудита). |
| Техническое задание на создание системы защиты информации | Раздел, описывающий функции и механизмы защиты информации, которые должны быть реализованы в программе. Ищите детали о том, как именно должны работать эти механизмы (например, алгоритм хеширования паролей, правила разграничения доступа). |
| Техническое задание на программное обеспечение | Если отдельного ТЗ на СЗИ нет, требования безопасности могут быть включены в общее ТЗ на ПО. Ищите разделы, касающиеся безопасности, защиты данных, обработки ошибок, требований к надежности и устойчивости. |
| Эксплуатационная документация на ПО | Описание функций безопасности с точки зрения пользователя или администратора. Как настроить безопасность, как работают функции входа, управления пользователями, аудита. Это помогает понять ожидаемое поведение системы. |
| Технические условия (ТУ) на ПО | Документ, описывающий основные характеристики и требования к программе. Раздел, связанный с требованиями безопасности или специальными требованиями. |
| Иные стандарты или политики безопасности | Внутренние политики компании, отраслевые стандарты (если применимы). Могут содержать дополнительные требования к обработке данных, использованию криптографии, реагированию на инциденты. |

Пример: Из документа РД.СЗИ.ТР.2012 можно выделить требование "Система должна вести журнал учета всех действий пользователей, связанных с доступом к защищаемой информации".

#### 5.1.2. Определение, какой код выполняет эти правила

После того как вы нашли конкретные требования безопасности, нужно понять, какие части вашего кода отвечают за их выполнение. Найдите модули, классы, функции или методы, которые реализуют каждое требование. Устанавливается трассируемость: какое требование реализуется/обеспечивается каким компонентом кода.

Например: Требование о ведении журнала учета действий, вероятно, реализуется в методах класса `AuditManager` или в функциях, которые обрабатывают операции доступа к данным и вызывают методы журналирования. Например, метод `DataAccessService.readConfidentialData` должен после успешного или неудачного чтения вызвать метод `AuditLogger.logEvent`.

#### 5.1.3. Формализация "вопросов" сертификации/контроля

Анализируется опыт предыдущих сертификаций, типовые методики испытаний органов по сертификации, возможные векторы атак и риски безопасности, характерные для данного типа ПО. Формулируются конкретные сценарии проверки или "вопросы", которые могут быть заданы в процессе сертификации или инспекционного контроля. Эти "вопросы" преобразуются в проверяемые технические утверждения о поведении ПО или его компонентов. Подумайте, какие конкретные проверки или вопросы могут задать эксперты ФСТЭК или лаборатории, исходя из требований, которые вы нашли. Превратите эти возможные вопросы в четкие, проверяемые задания для ваших UNIT-тестов.

Примеры "вопросов", формализуемых для UNIT-тестирования:
* Корректность применения мандатного атрибута при доступе к объекту на уровне функции ядра безопасности.
* Правильность генерации уникального идентификатора сессии при входе пользователя.
* Стойкость функции хеширования пароля к коллизиям при использовании стандартных входных данных.
* Блокировка учетной записи после N неуспешных попыток аутентификации в соответствующем модуле.
* Корректность обработки ошибок при доступе к защищаемому ресурсу с недостаточными привилегиями.
* Отсутствие возможности обхода проверки целостности для конфигурационного файла в соответствующем парсере.

Следующая таблица показывает, как преобразовать типовые "вопросы" аудиторов в конкретные задачи для тестирования.

| Исходный "вопрос" сертификации/контроля | Как превратить в задачу для UNIT-теста (пример) |
| :--- | :--- |
| Как система проверяет учетные данные пользователя при входе? | *Задача теста:* проверить, что метод `checkLoginPassword` возвращает `true` для правильной пары логин/пароль и `false` для неправильной. Проверить граничные случаи: пустой логин, пустой пароль, очень длинные значения. |
| Правильно ли программа определяет, к каким данным имеет доступ конкретный пользователь? | *Задача теста:* проверить, что метод `canAccessResource` возвращает `true` для пользователя с ролью "администратор" при попытке доступа к ресурсу "/settings" и `false` для пользователя с ролей "гость". Проверить разные комбинации ролей и ресурсов согласно правилам доступа. |
| Как программа обрабатывает данные, которые вводит пользователь, на наличие опасных символов? | *Задача теста:* проверить, что функция `sanitizeInput` удаляет или преобразует специальные символы (например, `<script>`, `--`, `'`) из входной строки. Проверить, что функция правильно обрабатывает обычный текст без опасных символов. |
| Вызывают ли функции входа/выхода или изменения прав записи в журнал аудита? | *Задача теста:* используя имитатор для журнала аудита, проверить, что метод `processLogin` вызывает метод `logEvent` имитатора с типом события "успешный вход" и правильными параметрами (имя пользователя, время). Аналогично проверить неудачные входы и другие важные события. |
| Как функция шифрования работает с разными ключами и данными? | *Задача теста:* проверить, что метод `encryptData` успешно шифрует тестовые данные, используя валидный ключ. Проверить, что попытка расшифровать данные неверным ключом приводит к ошибке или возвращает некорректные данные. |
| Что происходит, если функция, работающая с файлами, пытается получить доступ к файлу без достаточных прав? | *Задача теста:* используя имитатор файловой системы, настроенный так, чтобы запретить доступ к определенному файлу, проверить, что метод `readFileContent` в этом случае выбрасывает ожидаемое исключение `PermissionDeniedException`. |

Пример: Если аудитор может спросить "Что произойдет, если пользователь попытается войти с пустым паролем?", то задача для вашего UNIT-теста будет "Проверить, что метод `AuthService.authenticate` возвращает ошибку 'пустой пароль недопустим', если в качестве пароля передана пустая строка".

#### 5.1.4. Создание матрицы трассируемости

Разрабатывается матрица трассируемости, связывающая требования безопасности (из нормативных документов, ТЗ и ТУ), формализованные "вопросы" сертификации/контроля, и конкретные единицы кода (модули, функции), которые их реализуют. Эта матрица будет основой для определения приоритетов тестирования и демонстрации покрытия требований. Очень полезно создать таблицу, которая показывает связи между требованиями безопасности (из документов), формализованными "вопросами" и конкретными частями вашего кода (модулями/функциями), которые реализуют эти требования. Затем вы добавите в эту таблицу информацию о UNIT-тестах, которые проверяют эти части кода.

Эта таблица (матрица трассируемости) служит картой, которая помогает убедиться, что вы ничего не пропустили, и позволяет легко показать проверяющим, какие тесты подтверждают выполнение каких требований безопасности.

| Идентификатор требования (Документ, пункт) | Описание требования безопасности | Формализованный "вопрос" сертификации/контроля | Идентифицированная единица кода (Модуль, функция) | Идентификатор UNIT-теста(ов) (название класса/метода) | Примечание (Связь, реализация) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| РД ФСТЭК, Уровень доверия 4, п. X.Y | Система должна выполнять строгую аутентификацию пользователей. | Как система проверяет учетные данные пользователя? Какие методы аутентификации поддерживаются? | `AuthService`, методы `authenticate`, `verifyToken` | `AuthServiceTest.testAuthenticateValidCredentials`, `AuthServiceTest.testVerifyTokenExpired`, `AuthServiceTest.testAuthenticateInvalidCredentials`, `AuthServiceTest.testAuthenticateEmptyPassword`, `AuthServiceTest.testVerifyTokenInvalid`, `AuthServiceTest.testVerifyTokenExpired` | `authenticate` реализует проверку логина/пароля, `verifyToken` - проверку токенов сессии. Проверяем как успешные, так и неудачные сценарии для каждой функции. |
| ТЗ на СЗИ, раздел 3.2.1 | Все неуспешные попытки входа должны регистрироваться в журнале. | Фиксируются ли неудачные попытки входа в журнале аудита? | `AuthService`, метод `authenticate`; `AuditLogger`, метод `logEvent` | `AuthServiceTest.testAuthenticateInvalidPasswordLogsAttempt`, `AuthServiceTest.testAuthenticateNonExistentUserLogsAttempt` | `authenticate` вызывает `AuditLogger.logEvent` при любой неудаче аутентификации (неверный пароль, несуществующий пользователь). Тесты проверяют, что вызов `logEvent` с правильными параметрами *происходит* при неудаче. |
| ТУ на ПО, требование 5.1 | Пароль должен соответствовать политике сложности. | Как система проверяет сложность нового пароля? | `PasswordPolicyChecker`, метод `checkComplexity` | `PasswordPolicyCheckerTest.testCheckComplexityValid`, `PasswordPolicyCheckerTest.testCheckComplexityTooShort`, `PasswordPolicyCheckerTest.testCheckComplexityNoDigit`, `PasswordPolicyCheckerTest.testCheckComplexityNoSpecialChar`, `PasswordPolicyCheckerTest.testCheckComplexityTooLong` | `checkComplexity` реализует логику проверки всех правил сложности пароля (длина, наличие цифр, спецсимволов, верхнего/нижнего регистра). Тесты покрывают все условия проверки. |

Пример использования матрицы: Если аудитор спрашивает про аутентификацию (первая строка), вы можете показать ему тесты `AuthServiceTest`, которые подтверждают, что метод `authenticate` работает правильно в разных ситуациях.

### 5.2. Шаг 2: Проектирование UNIT-тестов

На основе результатов анализа и матрицы трассируемости разрабатываются детальные планы UNIT-тестов. Теперь, зная, что нужно проверить (из Шага 1), спланируйте, как вы это сделаете с помощью UNIT-тестов.

#### 5.2.1. Определение тестируемых единиц

Для каждой записи в матрице трассируемости, связанной с кодом, определяется конкретная тестируемая единица (Unit Under Test, UUT) — это может быть отдельный метод, функция или небольшой класс. Для каждой строчки в вашей матрице трассируемости, где указана часть кода, вы определяете, какой именно "юнит" будет тестироваться. Это может быть один метод, одна функция или один небольшой класс. Важно выбрать минимально возможный, но осмысленный для проверки безопасности кусок кода.

Пример: Если требование "Все события безопасности должны регистрироваться", а код, связанный с этим, находится в классах `EventProcessor` (который решает, какие события важны) и `AuditLogger` (который записывает их), то тестируемой единицей может быть метод `EventProcessor.processEvent`, который должен, получив определенный тип события, вызвать метод `AuditLogger.log`. UNIT-тест будет проверять только метод `processEvent` в изоляции, используя имитатор для `AuditLogger`.

#### 5.2.2. Определение тестовых сценариев

Для каждой UUT и связанного с ней требования/вопроса разрабатываются тестовые сценарии. Сценарий описывает последовательность действий, необходимых для проверки конкретного аспекта поведения UUT. Сценарии должны охватывать:
* **Позитивные сценарии:** Проверка корректного выполнения функции при валидных входных данных и условиях, соответствующих требованиям безопасности. Проверки того, что тестируемый код правильно выполняет свою задачу в нормальных, ожидаемых условиях, когда все входные данные корректны, а зависимости ведут себя как положено. Это подтверждает базовую работоспособность функции безопасности.
* **Негативные сценарии:** Проверка поведения UUT при некорректных, граничных, заведомо опасных или неожидаемых входных данных и условиях (например, некорректные учетные данные, попытка доступа без прав, превышение лимитов, специальные символы в полях ввода, имитация сбоев зависимостей). Особое внимание уделяется сценариям, имитирующим попытки нарушения безопасности. Проверка того, как тестируемый код реагирует на некорректные, неполные, граничные или заведомо "плохие" входные данные или условия. Это критически важно для безопасности, так как часто именно некорректная обработка ошибок или неожиданных данных приводит к уязвимостям.
* **Сценарии обработки исключений:** Проверка корректной реакции UUT на ошибки или исключительные ситуации, возникающие во время выполнения, включая ошибки, связанные с безопасностью (например, неверный формат ключа шифрования, попытка десериализации недоверенных данных). Проверка того, как тестируемый код ведет себя при возникновении внутренних ошибок или исключительных ситуаций, которые могут возникнуть в реальной работе или при попытке атаки (например, нет доступа к файлу, ошибка при обращении к базе данных, неверный формат данных). Нужно проверить, что ошибки обрабатываются безопасно и корректно.

Следующая таблица описывает основные типы тестовых сценариев, которые следует создавать.

| Тип тестового сценария | Цель сценария и на что он должен быть направлен | Пример (обобщенный) |
| :--- | :--- | :--- |
| Позитивные сценарии | Проверка того, что тестируемый код правильно выполняет свою задачу в нормальных, ожидаемых условиях, когда все входные данные корректны, а зависимости ведут себя как положено. Это подтверждает базовую работоспособность функции безопасности. | Проверка того, что функция аутентификации успешно выполняет вход при вводе правильных логина и пароля. Проверка того, что функция шифрования корректно шифрует данные валидным ключом. |
| Негативные сценарии | Проверка того, как тестируемый код реагирует на некорректные, неполные, граничные или заведомо "плохие" входные данные или условия. Это критически важно для безопасности, так как часто именно некорректная обработка ошибок или неожиданных данных приводит к уязвимостям. | Проверка того, что функция аутентификации отклоняет вход при неверном пароле, пустом логине, недопустимых символах в поле логина. Проверка того, что функция санитизации правильно удаляет опасные символы из строки. |
| Сценарии обработки исключений/ошибок | Проверка того, как тестируемый код ведет себя при возникновении внутренних ошибок или исключительных ситуаций, которые могут возникнуть в реальной работе или при попытке атаки (например, нет доступа к файлу, ошибка при обращении к базе данных, неверный формат данных). Нужно проверить, что ошибки обрабатываются безопасно и корректно. | Проверка того, что функция, читающая конфигурацию безопасности из файла, выбрасывает ожидаемое исключение, если файл не найден или имеет неверный формат. Проверка того, что функция доступа к ресурсу выбрасывает ошибку "доступ запрещен", если у пользователя нет прав. |

Пример: Для функции `checkComplexity` (проверка сложности пароля) нужно создать как минимум следующие сценарии:
* Позитивный: Пароль соответствует всем требованиям (длина, символы).
* Негативные: Пароль слишком короткий, нет цифр, нет заглавных букв, содержит недопустимые символы.
* Обработка исключений: Передан `null` или пустая строка (если это не считается негативным сценарием, а отдельным типом ошибки).

#### 5.2.3. Определение входных данных и ожидаемых результатов

Для каждого тестового сценария определяются:
* **Предусловия (Arrange):** Состояние системы или UUT до начала выполнения теста. Включает настройку зависимостей, инициализацию объектов, подготовку тестовых данных (например, создание тестового пользователя, настройка имитатора базы данных). Что нужно подготовить до теста.
* **Входные данные (Act):** Конкретные значения параметров или последовательность вызовов, применяемых к UUT. Что вы делаете для проверки.
* **Ожидаемые результаты (Assert):** Точные ожидаемые выходные данные, возвращаемые значения, изменения состояния UUT или его зависимостей, сгенерированные исключения или события. Ожидаемый результат должен быть строго определен на основе требований безопасности и спецификации поведения UUT. Что вы ожидаете получить в результате.

Пример для формализованного "вопроса": "Как функция хеширования пароля обрабатывает пустые или слишком короткие пароли?". Пример (используя шаблон AAA и псевдокод на Java-подобном языке) для сценария "Функция проверки сложности пароля: Пароль слишком короткий" (из 5.2.2):
* **UUT:** Метод `PasswordHasher.hashPassword(password, salt)`.
* **Сценарий:** Передача пустой строки в качестве пароля.
* **Входные данные:** `password=""`, `salt="some_salt"`.
* **Ожидаемый результат:** Должно быть сгенерировано исключение типа `InvalidPasswordFormatException` с определенным сообщением или возвращен специфический код ошибки, согласно спецификации реализации безопасности.

Пример (используя шаблон AAA и псевдокод на Java-подобном языке) для сценария "Функция проверки сложности пароля: Пароль слишком короткий" (из 5.2.2):
* **Arrange:** Создать экземпляр класса `PasswordPolicyChecker`. Настроить объект конфигурации (если он используется `PasswordPolicyChecker`) так, чтобы минимальная длина пароля была 8 символов.
* **Act:** Вызвать метод `passwordPolicyChecker.checkComplexity("Short1")`.
* **Assert:** Ожидается, что метод `checkComplexity` вернет значение `false`, или выбросит исключение типа `WeakPasswordException` с сообщением, указывающим на недостаточную длину.

#### 5.2.4. Определение необходимых имитаторов, заглушек и фейков

Для изоляции UUT определяются зависимости, которые необходимо заменить на тестовые двойники. Решите, какие зависимости вашего тестируемого кода (другие модули, доступ к файлам, базе данных, сети) нужно заменить на тестовые двойники (заглушки, имитаторы или фейки), чтобы тест был изолированным и повторяемым. Определите, какой тип двойника лучше подходит для каждой зависимости, исходя из того, что вы проверяете (только возвращаемое значение, взаимодействие или упрощенную логику).

* **Заглушка (Stub):** Предоставляет заранее определенные ответы на вызовы во время теста, не содержат никакой логики, кроме возврата зафиксированных значений. Используются для управления поведением зависимостей, необходимых для выполнения UUT.
* **Имитатор (Mock):** Позволяет верифицировать, что UUT правильно взаимодействует со своими зависимостями, проверяя, были ли вызваны определенные методы зависимостей с ожидаемыми параметрами и сколько раз. Используются для проверки взаимодействия, а не только возвращаемых значений.
* **Фейк (Fake):** Упрощенная реализация зависимости с рабочей логикой (например, in-memory база данных вместо реальной). Используются, когда заглушки или имитаторы недостаточны, но не требуется полная функциональность реальной зависимости.

Выбор типа тестового двойника зависит от того, какой аспект взаимодействия UUT с зависимостью тестируется: возвращаемое значение, факт вызова метода, параметры вызова.

Пример: Если метод `DataAccessService.readConfidentialData` (ваш UUT) обращается к службе журналирования (`AuditLogger`), чтобы зарегистрировать факт доступа, и к службе проверки прав (`PermissionChecker`), чтобы убедиться, что пользователь имеет доступ, то в UNIT-тесте для `DataAccessService.readConfidentialData` вам понадобятся:
* Имитатор (`Mock`) для `AuditLogger`: чтобы проверить, что метод `logEvent` был вызван после попытки доступа.
* Заглушка (`Stub`) для `PermissionChecker`: чтобы настроить, будет ли проверка прав успешной или нет для конкретного сценария теста (например, для негативного сценария "доступ запрещен" заглушка `PermissionChecker` должна вернуть `false`).

### 5.3. Шаг 3: Реализация UNIT-тестов

На этом этапе происходит непосредственное написание кода UNIT-тестов с использованием выбранного фреймворка. Теперь можно писать собственно код тестов, используя выбранный инструмент (фреймворк).

#### 5.3.1. Выбор фреймворка для UNIT-тестирования

Выбирается подходящий фреймворк для UNIT-тестирования, соответствующий языку программирования ПО. Примеры:
* Java: JUnit, TestNG
* C#: NUnit, xUnit.net, MSTest
* Python: unittest, pytest, nose
* C++: Google Test, Catch2, Boost.Test
* JavaScript: Jest, Mocha, Jasmine

Выбор фреймворка основывается на его возможностях, поддержке в среде разработки, наличии инструментов для работы с тестовыми двойниками, генерации отчетов и интеграции с CI/CD. Выберите подходящий набор инструментов (фреймворк) для написания и запуска UNIT-тестов. Выбор зависит от языка, на котором написана ваша программа.

| Язык программирования | Примеры популярных фреймворков для UNIT-тестирования |
| :--- | :--- |
| Java | JUnit, TestNG |
| C# | NUnit, xUnit.net, MSTest |
| Python | unittest, pytest, nose |
| C++ | Google Test, Catch2, Boost.Test |
| JavaScript | Jest, Mocha, Jasmine |
| ... | ... |

Пример: Если ваша программа написана на Java, вы выберете JUnit или TestNG в качестве фреймворка для UNIT-тестирования. Если на C#, то NUnit или xUnit.net.

#### 5.3.2. Написание кода тестов

Код каждого UNIT-теста пишется в соответствии с разработанным тестовым сценарием, используя синтаксис и возможности выбранного фреймворка. Каждый тест должен соответствовать структуре Arrange-Act-Assert (AAA) или Given-When-Then (GWT). Код каждого UNIT-теста должен соответствовать разработанному сценарию. Большинство тестов пишутся по простой структуре.
* **Arrange (Given):** Подготовка тестового окружения, создание UUT, настройка тестовых двойников, подготовка входных данных.
* **Act (When):** Вызов тестируемого метода или функции UUT с подготовленными входными данными.
* **Assert (Then):** Проверка ожидаемого результата с использованием утверждений (assertions), предоставляемых фреймворком. Проверяется возвращаемое значение, состояние UUT, взаимодействие с имитаторами, выброшенные исключения.

Следующая таблица описывает два популярных шаблона для структурирования кода UNIT-теста.

| Шаблон | Описание шагов и их назначение |
| :--- | :--- |
| Arrange-Act-Assert (AAA) | **Arrange (Подготовка):** Код, который создает все необходимые объекты, настраивает тестовое окружение, готовит тестовые данные и настраивает поведение тестовых двойников (заглушек, имитаторов). Цель: привести все в нужное состояние для проверки. <br>**Act (Действие):** Код, который вызывает тестируемый метод или функцию (UUT) с подготовленными входными данными. Цель: выполнить ту часть кода, которую мы проверяем. <br>**Assert (Проверка):** Код, который использует утверждения для проверки, что фактический результат выполнения UUT совпадает с ожидаемым результатом. Цель: удостовериться, что UUT повел себя правильно. |
| Given-When-Then (GWT) | **Given (Дано):** Описание исходного состояния системы или UUT перед началом теста. Похоже на Arrange. Цель: установить контекст теста. <br>**When (Когда):** Описание действия, которое выполняется над UUT. Похоже на Act. Цель: инициировать проверяемое поведение. <br>**Then (Тогда):** Описание ожидаемого результата или изменения состояния системы после выполнения действия. Похоже на Assert. Цель: проверить, соответствует ли фактический результат ожиданиям. |

Пример (используя шаблон AAA и псевдокод на Java-подобном языке) для сценария "Функция проверки сложности пароля: Пароль слишком короткий":

```java
@Test // Это специальная метка фреймворка, указывающая, что этот метод является тестом
void testCheckComplexityTooShortPassword() {
 // Arrange
 PasswordPolicyChecker policyChecker = new PasswordPolicyChecker(configMock); // Создаем тестируемый объект
 // Настраиваем mock configMock, чтобы он возвращал минимальную длину 8
 when(configMock.getMinPasswordLength()).thenReturn(8);

 // Act
 boolean result = policyChecker.checkComplexity("Short1"); // Вызываем тестируемый метод

 // Assert
 assertFalse(result, "Метод checkComplexity должен вернуть false для слишком короткого пароля"); // Проверяем ожидаемый результат с помощью утверждения
 // Дополнительные проверки, если нужно, например, проверка вызова метода логирования ошибки
}
````

#### 5.3.3. Использование утверждений (Assertions)

Утверждения являются ядром UNIT-теста. Они сравнивают фактический результат выполнения UUT с ожидаемым результатом. При тестировании безопасности утверждения должны быть максимально точными и проверять конкретные свойства. Утверждения — это специальные вызовы функций вашего фреймворка, которые проверяют, истинно ли какое-то условие. Если условие ложно, тест считается не прошедшим.

Примеры утверждений:

 * Равно ли фактическое значение ожидаемому (`assertEqual`, `assertEquals`).
 * Истинно ли условие (`assertTrue`).
 * Ложно ли условие (`assertFalse`).
 * Равен ли объект null (`assertNull`).
 * Не равен ли объект null (`assertNotNull`).
 * Было ли выброшено ожидаемое исключение (`assertThrows`).
 * Соответствует ли строка регулярному выражению.
 * Содержатся ли определенные элементы в коллекции.

При тестировании безопасности утверждения должны быть максимально точными и проверять конкретные свойства:

 * Корректность применения криптографического преобразования.
 * Строгое соответствие формату данных после sanitization или validation.
 * Факт отказа в доступе при нехватке прав.
 * Корректный код ошибки или сообщение при неудачной операции безопасности.
 * Отсутствие конфиденциальных данных в логах, если это запрещено.

Следующая таблица приводит примеры типовых утверждений и объясняет, что они проверяют.

| Тип утверждения (пример названия функции) | Что проверяет это утверждение | Применимость в контексте безопасности |
| :--- | :--- | :---07/01/2024
| `assertEqual(ожидается, факт)` | Проверяет, равны ли два значения (числа, строки, объекты). | Проверка, что функция хеширования вернула ожидаемый хеш для известного входа. Проверка, что функция санитизации вернула строку с правильно удаленными опасными символами. Проверка, что функция вернула ожидаемый код ошибки при неверном входе. |
| `assertTrue(условие)` | Проверяет, что условие является истинным. | Проверка, что функция `canAccessResource` вернула `true`, когда у пользователя есть права. Проверка, что функция `validatePassword` вернула `true` для сложного пароля. |
| `assertFalse(условие)` | Проверяет, что условие является ложным. | Проверка, что функция `canAccessResource` вернула `false`, когда у пользователя нет прав. Проверка, что функция `validatePassword` вернула `false` для простого пароля. |
| `assertNull(объект)` | Проверяет, что объект равен "ничему" (null). | Проверка, что функция, которая должна удалить временные данные после использования, установила ссылку на объект данных в null. |
| `assertNotNull(объект)` | Проверяет, что объект не равен "ничему" (null). | Проверка, что функция аутентификации успешно создала объект сессии (не null) после успешного входа. |
| `assertThrows(тип_исключения, код_вызова)` | Проверяет, что при выполнении определенного кода ожидается выброс исключения указанного типа. | Проверка, что попытка расшифровать данные неверным ключом приводит к выбрасыванию исключения `InvalidKeyException`. Проверка, что попытка записи в файл без прав приводит к выбрасыванию исключения `PermissionDeniedException`. |
| `assertContains(коллекция, элемент)` | Проверяет, что коллекция (список, набор) содержит определенный элемент. | Проверка, что список зарегистрированных событий аудита, полученный от имитатора, содержит запись о неудачной попытке входа. Проверка, что список разрешений для пользователя содержит конкретное разрешение "write". |
| Проверка вызова имитатора (mock assertion) | Не стандартное утверждение фреймворка, а функция библиотеки мокирования. Проверяет, был ли вызван определенный метод имитатора, сколько раз и с какими параметрами. | Проверка, что имитатор журнала аудита был вызван методом `logEvent` один раз с параметрами "неудачный вход" и именем пользователя. Проверка, что имитатор службы отправки писем был вызван методом `sendEmail` для уведомления администратора о событии безопасности. |

Выбирайте утверждения, которые наиболее точно проверяют ожидаемое поведение вашего кода в контексте безопасности. Например, вместо простого `assertTrue(result)`, если ожидается конкретное сообщение об ошибке, используйте `assertEqual("Пароль слишком короткий", result.getErrorMessage())`.

#### 5.3.4. Реализация тестовых двойников

Создаются заглушки, имитаторы и фейки для изоляции UUT. Используются специализированные библиотеки для мокирования (например, Mockito, Moq, unittest.mock). Создайте заглушки, имитаторы и фейки для всех зависимостей, которые вы определили на этапе планирования. Используйте для этого возможности вашего фреймворка для тестирования или специальные библиотеки для мокирования. Настройте их поведение так, чтобы они либо возвращали нужные тестовые данные (заглушки, фейки), либо ожидали определенных вызовов от тестируемого кода (имитаторы).

Пример (псевдокод с использованием библиотеки мокирования) для настройки имитатора журнала аудита:

```java
// Создаем имитатор для класса AuditLogger
AuditLogger auditLoggerMock = mock(AuditLogger.class);

// Настраиваем имитатор: ожидаем, что метод logEvent будет вызван один раз
// с любыми строковыми параметрами (это простой пример, обычно проверяют конкретные значения)
verify(auditLoggerMock, times(1)).logEvent(anyString(), anyString(), anyString());

// Теперь передаем этот имитатор в тестируемый объект (например, в конструктор AuthService)
AuthService authService = new AuthService(..., auditLoggerMock);

// ... Выполняем действие, которое должно привести к логированию события ...

// В части Assert проверяем, были ли вызваны ожидаемые методы имитатора
// verify(auditLoggerMock, times(1)).logEvent("Неудачный вход", "user123", "Неверный пароль"); // Более точная проверка параметров
```

#### 5.3.5. Управление тестовыми данными

Тестовые данные для UNIT-тестов должны быть строго определены и управляемы. Тестовые данные, которые вы используете в UNIT-тестах, должны быть четко определены.

 * **Генерация данных:** Использование библиотек или собственной логики для генерации реалистичных, граничных и некорректных данных (например, валидные и невалидные пароли, корректные и некорректные цифровые подписи, данные разного размера, данные с инъекциями). Используйте код или специальные инструменты для создания данных, которые выглядят как реальные, но не являются таковыми, и которые позволяют проверить все сценарии (например, разные типы паролей для проверки сложности, разные наборы прав доступа).
 * **Хранение данных:** Тестовые данные должны храниться рядом с тестами, предпочтительно в коде тестов или в легко доступных ресурсах (JSON, XML, CSV файлы), интегрированных в систему сборки. Использование внешних баз данных или файловых ресурсов, требующих сложной настройки, должно быть минимизировано. Храните тестовые данные рядом с кодом тестов.
 * **Очистка данных:** После выполнения теста состояние, созданное тестом (например, изменения в in-memory фейковой базе данных), должно быть очищено, чтобы не влиять на другие тесты. Используются механизмы фикстур фреймворка (setUp/tearDown, @BeforeEach/@AfterEach). После каждого теста убедитесь, что все данные или изменения состояния, которые создал тест, удалены, чтобы они не мешали другим тестам. Для этого используются фикстуры.

Пример создания тестовых данных:

 * Для тестирования функции проверки сложности пароля: создать строки `"CorrectP@ss123"`, `"short"`, `"NoDigits!"`, `"UpperCaseOnly"`, `"ПарольДлиннееСтаСимволов..."`.
 * Для тестирования функции проверки прав: создать объекты, имитирующие пользователя с ролью "admin" и пользователя с ролью "guest", и объекты, имитирующие защищаемые ресурсы "/settings" и "/public".

#### 5.3.6. Обработка чувствительных данных в тестах

При тестировании компонентов, работающих с конфиденциальной информацией (пароли, ключи, персональные данные), необходимо строго соблюдать правила безопасности:

 * Не использовать реальные конфиденциальные данные в тестах.
 * Генерировать тестовые данные, имитирующие реальные по структуре и свойствам, но не имеющие реальной ценности.
 * Не хранить чувствительные тестовые данные в открытом виде в репозитории исходного кода. Использовать безопасные механизмы для их генерации или получения в тестовом окружении.
 * Убедиться, что трассировка и логирование тестов не содержат чувствительных данных.

При работе с данными, которые в реальной системе являются конфиденциальными (пароли, ключи шифрования), **никогда не используйте реальные данные в тестах**. Создавайте специальные тестовые данные, которые имитируют формат и свойства реальных данных, но не имеют реальной ценности. Убедитесь, что эти тестовые данные не попадают в логи или отчеты тестов.

### 5.4. Этап 4: Выполнение UNIT-тестов

Автоматизированное выполнение разработанных UNIT-тестов. UNIT-тесты должны запускаться автоматически и очень часто, чтобы быстро находить ошибки.

#### 5.4.1. Интеграция в процесс сборки

UNIT-тесты должны быть интегрированы в процесс автоматизированной сборки ПО (например, с использованием Maven, Gradle, MSBuild, CMake). Запуск UNIT-тестов должен выполняться автоматически при каждой сборке или при каждом коммите в систему контроля версий (VCS). Настройте систему сборки вашего проекта так, чтобы UNIT-тесты запускались каждый раз, когда вносятся изменения в код (например, при каждом коммите в систему контроля версий). Это обычно делается с помощью инструментов Непрерывной Интеграции (CI).

Пример: В файле конфигурации вашей CI-системы (например, `.gitlab-ci.yml` для GitLab CI или `Jenkinsfile` для Jenkins) добавьте шаг, который после получения последних изменений исходного кода выполняет сборку проекта и команду запуска UNIT-тестов (например, `mvn test` для Maven или `pytest` для Python). Настройте этот шаг так, чтобы сборка считалась неуспешной, если хотя бы один UNIT-тест не прошел.

#### 5.4.2. Настройка тестового окружения

Тесты должны выполняться в контролируемом и повторяемом тестовом окружении. Это может быть выделенный сервер сборки, контейнер виртуализации (Docker) или виртуальная машина. Окружение должно содержать все необходимые зависимости, но при этом быть максимально изолированным от внешних систем, кроме тех, которые имитируются тестовыми двойниками. Тесты должны выполняться в специальном месте — тестовом окружении. Это может быть отдельный сервер или виртуальная машина. Важно, чтобы это окружение было всегда одинаковым и содержало только то, что нужно для тестов, без влияния внешних систем.

Пример: Используйте Docker-контейнер с минимальным набором зависимостей, необходимых для запуска тестов (среда выполнения языка, фреймворк для тестирования, библиотеки мокирования). Опишите это окружение в Dockerfile, чтобы оно могло быть легко воспроизведено где угодно. Убедитесь, что тестовое окружение не имеет доступа к реальным базам данных, сетевым ресурсам или конфиденциальным данным, используемым в "боевой" или тестовой среде интеграции.

#### 5.4.3. Регулярный запуск тестов

UNIT-тесты должны запускаться часто:

 * При каждом коммите разработчиком (локально или на CI сервере).
 * При каждом слиянии веток в VCS.
 * Регулярно по расписанию (например, nightly builds).

Частый запуск тестов позволяет быстро выявлять регрессионные дефекты, в том числе связанные с безопасностью, внесенные последними изменениями в код. Запускайте UNIT-тесты при каждом изменении кода. Это помогает сразу увидеть, "сломали" ли последние изменения какую-то функцию, в том числе связанную с безопасностью.

Пример: Настройте вашу CI-систему на запуск полного набора UNIT-тестов при каждом коммите в основную ветку репозитория (например, `main` или `master`) и при создании запросов на слияние (merge/pull requests) из других веток. Это обеспечивает быструю обратную связь разработчикам.

### 5.5. Этап 5: Анализ результатов и отчетность

Результаты выполнения UNIT-тестов должны быть проанализированы, а выявленные дефекты — зафиксированы и устранены. После выполнения тестов нужно посмотреть, что получилось, найти и исправить ошибки.

#### 5.5.1. Интерпретация результатов

Результат каждого UNIT-теста — "успех" (Passed) или "неудача" (Failed).

 * **Успех:** Ожидаемое поведение UUT подтверждено.
 * **Неудача:** Фактическое поведение UUT отличается от ожидаемого. Необходимо проанализировать причину неудачи: ошибка в тестируемом коде, ошибка в коде теста, проблема с тестовыми данными, некорректная настройка тестового окружения.

Пример: В отчете о тестировании вы видите, что тест `AuthServiceTest.testAuthenticateEmptyPassword` помечен как "Failed". Это означает, что когда вы передали пустую строку в метод `authenticate`, он не повел себя так, как вы ожидали (например, вернул `true` вместо `false` или не выбросил ожидаемое исключение).

#### 5.5.2. Анализ неудачных тестов

Причины неудач должны быть оперативно расследованы. Инструменты фреймворков предоставляют информацию о месте неудачи (строка кода теста и тестируемого модуля), трассировку стека, значения переменных. При необходимости используется пошаговая отладка теста и тестируемого кода. Если тест не прошел, нужно выяснить почему. Это может быть ошибка в коде, который вы тестируете, ошибка в самом тесте (например, неправильно настроен имитатор или ожидается неверный результат), или проблема с тестовыми данными или окружением. Инструменты для тестирования обычно показывают, в какой строке кода теста или тестируемого модуля произошла ошибка.

Пример: Вы видите, что тест `testAuthenticateEmptyPassword` не прошел. Вы смотрите в отчет, видите трассировку стека, указывающую на метод `AuthService.authenticate`. Вы переходите к коду этого метода и видите, что добавили новую проверку входа, но забыли добавить проверку на пустую строку в самом начале метода. Это ошибка в тестируемом коде.

#### 5.5.3. Фиксация дефектов

Выявленные ошибки в тестируемом коде, приведшие к неудаче теста, должны быть зафиксированы в системе отслеживания дефектов (например, Jira, Redmine). Дефектам присваивается приоритет в зависимости от их критичности, особенно если они связаны с реализацией требований безопасности. Найденные ошибки в коде, которые привели к неудаче теста, нужно записать в систему, где вы отслеживаете задачи и ошибки в проекте (например, Jira). Укажите, что это ошибка, найденная UNIT-тестом, и свяжите ее с соответствующим требованием безопасности (если возможно).

Пример: Создайте новую задачу в Jira с названием "Ошибка: Пустой пароль проходит аутентификацию в AuthService". Укажите, что ошибка найдена UNIT-тестом `testAuthenticateEmptyPassword`, приложите часть отчета или логов. Присвойте задаче высокий приоритет, так как это ошибка безопасности. Свяжите задачу с требованием "Строгая аутентификация" из матрицы трассируемости.

#### 5.5.4. Генерация отчетов

Фреймворки UNIT-тестирования генерируют отчеты о выполнении тестов в различных форматах (JUnit XML, HTML). Отчеты должны содержать:

 * Общее количество выполненных тестов.
 * Количество успешных и неуспешных тестов.
 * Список всех тестов, включая информацию о неудачных тестах (название теста, сообщение об ошибке, трассировка стека).
 * Время выполнения тестов.

При использовании инструментов покрытия кода (Code Coverage) отчеты также должны включать метрики покрытия по строкам, ветвлениям, функциям. Фреймворки UNIT-тестирования могут автоматически создавать отчеты о том, как прошли тесты.

Следующая таблица описывает информацию, которая должна содержаться в отчетах о UNIT-тестировании.

| Тип информации в отчете | Описание и назначение |
| :--- | :--- |
| Общее количество тестов | Сколько всего UNIT-тестов было запущено. |
| Количество успешных тестов | Сколько тестов завершилось успешно (все утверждения прошли). |
| Количество неудачных тестов | Сколько тестов не прошли (хотя бы одно утверждение провалилось). |
| Список неудачных тестов | Полный список тестов, которые не прошли, с указанием имени теста, сообщения об ошибке (что именно пошло не так) и трассировки стека (в какой строке кода произошла ошибка). |
| Время выполнения тестов | Сколько времени занял запуск всего набора UNIT-тестов. Важно для контроля скорости и возможности частых запусков. |
| Покрытие кода | (Если используются инструменты покрытия) Метрики, показывающие процент покрытия исходного кода тестами (по строкам, ветвлениям, функциям). Помогает оценить полноту тестирования. |
| Информация об окружении | (Опционально) Версия фреймворка, информация об операционной системе, среде выполнения. Помогает воспроизвести условия запуска тестов при необходимости. |
| Процедуры выполнения тестов | Описание шагов или команд для запуска UNIT-тестов, например, в рамках системы CI/CD. Формализует процесс запуска тестов. |
| Результаты анализа дефектов | Информация об ошибках, найденных с помощью UNIT-тестов, их описание, связь с требованиями безопасности, статус исправления. Демонстрирует эффективность тестирования. |

Пример: Отчет в формате HTML показывает, что из 150 UNIT-тестов 148 прошли успешно, а 2 теста (`testAuthenticateEmptyPassword`, `testCheckComplexityNoSpecialChar`) завершились неудачей. Для каждого неудачного теста приведено сообщение об ошибке и трассировка стека, указывающая на проблемные места в коде `AuthService.authenticate` и `PasswordPolicyChecker.checkComplexity`. Отчет о покрытии показывает, что 95% строк кода в модуле аутентификации покрыты тестами.

#### 5.5.5. Связь отчетов с требованиями/вопросами

С использованием матрицы трассируемости результаты UNIT-тестов связываются с соответствующими требованиями безопасности и формализованными "вопросами" сертификации/контроля. В отчеты может быть добавлена информация о покрытии требований тестами. Используйте вашу таблицу связей и отчеты о тестах, чтобы показать, какие требования безопасности и "вопросы" аудиторов покрыты вашими UNIT-тестами, и что эти тесты прошли успешно. Это демонстрирует, что программа соответствует требованиям, которые будут проверяться.

Пример: В документе, предоставляемом для сертификации, сошлитесь на матрицу трассируемости и отчеты о UNIT-тестировании. Укажите, что требование "Строгая аутентификация пользователей" подтверждается успешным прохождением всех UNIT-тестов, связанных с модулем `AuthService`, согласно матрице трассируемости, а детальные результаты доступны в автоматических отчетах тестирования. Факт быстрого обнаружения и исправления ошибок, найденных UNIT-тестами (например, с пустым паролем), можно также продемонстрировать, показав соответствующие записи в системе отслеживания дефектов.

## 6\. Важные технические детали

### 6.1. Изоляция и управление зависимостями

Обеспечение строгой изоляции является краеугольным камнем UNIT-тестирования, особенно для компонентов безопасности. Зависимости, которые могут сделать тест непредсказуемым, медленным или требующим сложной настройки, должны быть заменены на тестовые двойники. Чтобы UNIT-тест проверял только один кусок кода, нужно убрать влияние всего остального, от чего этот кусок кода зависит (другие модули, внешние системы). Для этого используются тестовые двойники.

Примеры зависимостей, требующих имитации:

 * Базы данных
 * Файловая система
 * Сетевые вызовы (HTTP, сокеты)
 * Системное время
 * Генераторы случайных чисел (для повторяемости)
 * Взаимодействие с операционной системой (системные вызовы)
 * Внешние библиотеки (особенно те, которые имеют побочные эффекты или требуют инициализации)
 * Компоненты, работающие с аппаратным обеспечением (криптографические акселераторы, токены)

Выбор типа тестового двойника (stub, mock, fake) зависит от того, что необходимо проверить: возвращаемое значение (stub), взаимодействие (mock) или упрощенную функциональность (fake).

Следующая таблица приводит примеры зависимостей, которые часто нужно заменять тестовыми двойниками, и объясняет, почему это важно.

| Тип зависимости тестируемого кода | Почему эту зависимость нужно заменять тестовым двойником в UNIT-тесте |
| :--- | :--- |
| Базы данных | Реальная база данных требует установки, настройки, может работать медленно, ее состояние может меняться между запусками тестов, что делает тесты ненадежными. Тестовый двойник (например, Fake in-memory база или Mock, проверяющий SQL-запросы) обеспечивает быстрый и контролируемый доступ к данным или проверку взаимодействия с БД. |
| Файловая система | Доступ к файлам может быть медленным, зависит от наличия файлов, прав доступа в операционной системе. Тестовый двойник файловой системы (например, Virtual In-Memory FS) позволяет быстро создавать и читать файлы в памяти, имитировать ошибки доступа (например, "файл не найден", "доступ запрещен"), что важно для тестирования функций контроля доступа к файлам. |
| Сетевые вызовы (HTTP, сокеты) | Зависят от доступности сети и удаленного сервиса, могут быть медленными, нестабильными. Тестовый двойник (Stub или Mock) позволяет мгновенно вернуть нужный ответ от "удаленного" сервиса или проверить, что тестируемый код правильно отправил запрос. Это критично для тестирования функций, взаимодействующих с внешними системами (например, сервисами аутентификации, серверами аудита по сети). |
| Системное время | Время постоянно меняется. Если логика кода зависит от времени, тест может давать разный результат при каждом запуске. Тестовый двойник системного времени позволяет "заморозить" время или переместить его в будущее/прошлое, делая тесты повторяемыми. |
| Генераторы случайных чисел | Если код использует случайные числа, результат может быть непредсказуемым. Для повторяемости тестов нужно, чтобы генератор всегда выдавал одну и ту же последовательность "случайных" чисел. Тестовый двойник позволяет контролировать последовательность, что важно, например, при тестировании функций генерации уникальных идентификаторов сессий или ключей (хотя криптографическая стойкость требует других проверок). |
| Взаимодействие с операционной системой | Системные вызовы, работа с окружением зависят от ОС и ее настроек. Тестовый двойник позволяет имитировать поведение ОС, например, возвращать определенные значения системных переменных окружения или имитировать успешное/неуспешное выполнение системных команд. |
| Внешние библиотеки | Некоторые библиотеки могут иметь сложные зависимости, требовать инициализации или иметь побочные эффекты. Если вам нужно проверить только логику вашего кода, использующего такую библиотеку, ее можно заменить тестовым двойником, чтобы избежать сложностей. |
| Компоненты, работающие с оборудованием | Например, модули, работающие с криптографическими токенами или аппаратными датчиками случайных чисел. Их использование в UNIT-тестах невозможно или крайне затруднено. Их заменяют имитаторами, которые имитируют ответы оборудования или проверяют правильность вызовов к нему. |

### 6.2. Тестирование функций безопасности на уровне модулей

UNIT-тесты особенно эффективны для проверки корректности реализации следующих функций безопасности на низком уровне. UNIT-тесты отлично подходят для детальной проверки небольших кусков кода, которые отвечают за безопасность.

 * **Аутентификация:**
 * Проверка логики верификации учетных данных (пароль, сертификат, токен) при корректных и некорректных входных данных. Проверка функции сравнения паролей: Правильно ли она сравнивает хеши паролей. Проверка функции валидации пароля: Соответствует ли пароль требованиям сложности (длина, наличие разных типов символов).
 * Тестирование обработки граничных случаев (пустые логин/пароль, недопустимые символы).
 * Проверка логики блокировки учетной записи после N неуспешных попыток (если эта логика реализована в тестируемом модуле). Проверка логики обработки неудачных попыток: Увеличивается ли счетчик неудачных попыток при неверном пароле, блокируется ли учетная запись после заданного числа попыток (если эта логика в тестируемом модуле). Проверка обработки специальных символов в логине/пароле.
 * **Авторизация/Разграничение Доступа:**
 * Проверка логики принятия решений о доступе к ресурсу на основе прав пользователя/роли/атрибутов. Проверка функции проверки прав доступа: Правильно ли она определяет, имеет ли субъект (пользователь/роль) право на действие над объектом (ресурс) на основе заданных правил/политик.
 * Тестирование сценариев доступа с достаточными и недостаточными привилегиями. Проверить сценарии с достаточными, недостаточными, отсутствующими правами.
 * Проверка корректности применения мандатных или дискреционных политик на уровне функции. Проверка применения мандатных/дискреционных правил: Правильно ли код реализует конкретные правила доступа, описанные в документации ФСТЭК или ТЗ.
 * **Контроль Целостности:**
 * Тестирование функций вычисления и проверки хеш-сумм, электронных подписей для различных типов данных. Проверка функций вычисления/сравнения хешей: Правильно ли вычисляются хеши для разных данных (файлы, строки), совпадают ли они для идентичных данных, различаются ли для измененных.
 * Проверка обработки измененных или некорректных данных, подписей. Проверка функций работы с электронной подписью: Правильно ли выполняется проверка подписи с использованием открытого ключа; проверка невалидных подписей, измененных данных.
 * **Криптографические Преобразования:**
 * UNIT-тесты могут проверять корректность вызова функций криптографических библиотек с правильными параметрами (ключи, векторы инициализации, режимы работы). Проверка вызова криптографических функций: Правильно ли код вызывает функции из криптографических библиотек, используя верные параметры (ключи, векторы инициализации, режимы работы).
 * Тестирование шифрования/расшифрования небольших блоков данных. Проверка шифрования/расшифрования: Зашифровать тестовые данные, затем расшифровать и проверить, что результат совпадает с исходными данными. Проверить работу с разными блоками данных.
 * Проверка генерации и верификации имитовставки. Проверка генерации/верификации имитовставки (MAC): Правильно ли вычисляется и проверяется MAC для данных.
 * Проверка генерации криптографически стойких случайных чисел (хотя полноценная криптографическая стойкость требует других методов анализа).
 * **Аудит Событий Безопасности:**
 * Использование имитаторов для верификации того, что UUT генерирует ожидаемые события аудита в соответствующих сценариях (успешный/неудачный вход, попытка доступа к запрещенному ресурсу, изменение прав). Проверка генерации событий: Используя имитатор журнала аудита, проверить, что тестируемый код вызывает функцию логирования при наступлении важных событий (успешный/неудачный вход, попытка доступа к запрещенному ресурсу, изменение настроек безопасности).
 * Проверка корректности передаваемых данных события аудита (идентификатор пользователя, время, тип события, результат операции). Проверка содержимого событий: Проверить, что в событие аудита записывается вся необходимая информация (тип события, время, пользователь, результат, детали операции).
 * **Санитизация и Валидация Входных Данных:**
 * Тестирование функций очистки (sanitization) и проверки (validation) входных данных на наличие опасных конструкций (SQL-инъекции, XSS-скрипты, внедрение команд ОС). Проверка функции очистки (Sanitization): Правильно ли функция удаляет или нейтрализует опасные символы или конструкции (например, HTML-теги, SQL-операторы) из пользовательского ввода.
 * Проверка обработки данных, содержащих специальные символы, некорректный формат, слишком длинные строки. Проверка функции проверки (Validation): Правильно ли функция определяет, соответствуют ли входные данные ожидаемому формату или диапазону значений. Проверить граничные значения, некорректные форматы.
 * **Обработка Конфиденциальной Информации:**
 * Тестирование функций, работающих с конфиденциальными данными (например, зануление памяти после использования, корректное удаление временных файлов, передача данных по защищенным каналам — верификация вызова соответствующих функций нижнего уровня). Проверка зануления памяти: Если код работает напрямую с данными в памяти (например, ключами шифрования или паролями), проверить, что после использования память очищается (заполняется нулями). Проверка вызова функций безопасного удаления: Если код создает временные файлы или структуры с конфиденциальными данными, проверить, что вызываются функции для их безопасного удаления (например, многократная перезапись перед удалением, если это требуется политикой).

Следующая таблица приводит примеры функций безопасности и описывает, какие аспекты каждой из них можно проверить UNIT-тестами.

| Функция безопасности | Что UNIT-тест может проверить на уровне кода (примеры) |
| :--- | :--- |
| Аутентификация пользователя | *Проверка функции сравнения паролей:* Правильно ли она сравнивает хеши паролей. *Проверка функции валидации пароля:* Соответствует ли пароль требованиям сложности (длина, наличие разных типов символов). *Проверка логики обработки неудачных попыток:* Увеличивается ли счетчик неудачных попыток при неверном пароле, блокируется ли учетная запись после заданного числа попыток (если эта логика в тестируемом модуле). *Проверка обработки специальных символов в логине/пароле.* |
| Авторизация/разграничение доступа | *Проверка функции проверки прав доступа:* Правильно ли она определяет, имеет ли субъект (пользователь/роль) право на действие над объектом (ресурс) на основе заданных правил/политик. Проверить сценарии с достаточными, недостаточными, отсутствующими правами. *Проверка применения мандатных/дискреционных правил:* Правильно ли код реализует конкретные правила доступа, описанные в документации ФСТЭК или ТЗ. |
| Контроль целостности | *Проверка функций вычисления/сравнения хешей:* Правильно ли вычисляются хеши для разных данных (файлы, строки), совпадают ли они для идентичных данных, различаются ли для измененных. *Проверка функций работы с электронной подписью:* Правильно ли выполняется проверка подписи с использованием открытого ключа; проверка невалидных подписей, измененных данных. |
| Криптографические преобразования | *Проверка вызова криптографических функций:* Правильно ли код вызывает функции из криптографических библиотек, используя верные параметры (ключи, векторы инициализации, режимы работы). *Проверка шифрования/расшифрования:* Зашифровать тестовые данные, затем расшифровать и проверить, что результат совпадает с исходными данными. Проверить работу с разными блоками данных. *Проверка генерации/верификации имитовставки (MAC):* Правильно ли вычисляется и проверяется MAC для данных. |
| Аудит событий безопасности | *Проверка генерации событий:* Используя имитатор журнала аудита, проверить, что тестируемый код вызывает функцию логирования при наступлении важных событий (успешный/неудачный вход, попытка доступа к запрещенному ресурсу, изменение настроек безопасности). *Проверка содержимого событий:* Проверить, что в событие аудита записывается вся необходимая информация (тип события, время, пользователь, результат, детали операции). |
| Санитизация и валидация входных данных | *Проверка функции очистки (Sanitization):* Правильно ли функция удаляет или нейтрализует опасные символы или конструкции (например, HTML-теги, SQL-операторы) из пользовательского ввода. *Проверка функции проверки (Validation):* Правильно ли функция определяет, соответствуют ли входные данные ожидаемому формату или диапазону значений. Проверить граничные значения, некорректные форматы. |
| Обработка конфиденциальной информации | *Проверка зануления памяти:* Если код работает напрямую с данными в памяти (например, ключами шифрования или паролями), проверить, что после использования память очищается (заполняется нулями). *Проверка вызова функций безопасного удаления:* Если код создает временные файлы или структуры с конфиденциальными данными, проверить, что вызываются функции для их безопасного удаления (например, многократная перезапись перед удалением, если это требуется политикой). |

### 6.3. Тестирование конфигурации, влияющей на безопасность

Многие аспекты безопасности ПО зависят от его конфигурации. UNIT-тесты могут проверять:

 * Корректность парсинга конфигурационных файлов, содержащих параметры безопасности (например, пути к ключевым файлам, настройки аудита, таймауты сессий).
 * Правильность применения конфигурационных параметров логикой UUT.
 * Поведение UUT при отсутствии или некорректных значениях критически важных параметров безопасности.

Использование фикстур для имитации различных конфигурационных сценариев является ключевым для данного типа тестов. Настройки программы часто определяют, как именно работают функции безопасности (например, какой таймаут сессии, какие алгоритмы шифрования использовать). UNIT-тесты могут помочь проверить, что код правильно использует эти настройки.

Используйте тестовые двойники или фикстуры, чтобы имитировать разные конфигурации (например, предоставить тестируемому коду "поддельные" настройки из памяти) и проверить, как код ведет себя при каждом варианте настроек безопасности. Например, протестировать функцию установления сессии, подавая разные значения таймаута сессии из имитированной конфигурации и проверяя, что сессия действительно завершается через заданное время.

## 7\. Инструменты и фреймворки

Выбор инструментов для UNIT-тестирования определяется языком программирования и особенностями проекта. Ниже приведены категории инструментов и их роль. Для создания и запуска UNIT-тестов используются различные инструменты и наборы библиотек (фреймворки).

| Категория инструмента | Техническое описание и роль в методике |
| :--- | :--- |
| Фреймворки UNIT-тестирования | Это набор библиотек и инструментов, который предоставляет основу для написания и запуска UNIT-тестов. Он определяет, как должны быть организованы тесты (например, в виде классов с методами, помеченными специальными метками), предоставляет функции для проверки результатов (утверждения — assert methods), управляет жизненным циклом теста (выполнение подготовительных действий перед тестом и завершающих после). Является ядром всего процесса UNIT-тестирования. |
| Библиотеки для имитации (Mocking libraries) | Это инструменты, которые облегчают создание тестовых двойников (заглушек, имитаторов). Они позволяют "подменять" реальные объекты зависимостей на специальные тестовые объекты, которые вы можете настроить для возврата нужных значений или проверки вызовов. Это позволяет изолировать тестируемый код от его зависимостей и полностью контролировать условия его работы. |
| Инструменты покрытия кода (Code Coverage) | Это программы, которые анализируют, какая часть исходного кода вашей программы была реально выполнена (пройдена) во время запуска UNIT-тестов. Они показывают процент покрытия по разным метрикам: количество пройденных строк кода, количество выполненных ветвлений (условий `if`/`else`), количество вызванных функций. Эти инструменты помогают увидеть, какие части кода вообще не были затронуты тестами, и понять, где есть пробелы в тестировании. Важно: высокий процент покрытия не гарантирует отсутствие ошибок, но низкий процент точно указывает на недостаток тестов. |
| Системы непрерывной интеграции (CI) | Это серверные программы, которые автоматизируют процесс сборки вашего программного обеспечения, запуска UNIT-тестов и других автоматических проверок каждый раз, когда разработчики вносят изменения в код и загружают их в общее хранилище (систему контроля версий). CI-системы помогают быстро выявлять ошибки (включая ошибки, нарушающие тесты безопасности), которые могли быть внесены последними изменениями. Они предоставляют централизованное место для запуска тестов и генерации отчетов. |

Выбор конкретных инструментов зависит от языка программирования вашего проекта и принятых в команде практик.

## 8\. Типовые ошибки и пути их предотвращения

При написании UNIT-тестов, особенно для задач безопасности и сертификации, можно допустить ряд ошибок, которые снизят их эффективность или сделают результаты ненадежными. Ниже приведено описание типовых ошибок и рекомендации по их предотвращению.

В следующей таблице описаны некоторые из таких типовых ошибок и даны рекомендации, как их избежать.

| Типовая ошибка | Описание ошибки и ее причина | Последствия в контексте сертификации ФСТЭК и безопасности | Пути предотвращения этой ошибки |
| :--- | :--- | :--- | :--- |
| **Недостаточная изоляция тестов** | UNIT-тест зависит от внешних факторов или реальных зависимостей (например, реальная база данных, внешний сервис по сети, системное время, файлы на диске) или от порядка выполнения других тестов. Это происходит, когда тестовые двойники не используются или используются неправильно. | Такие тесты часто нестабильны ("флуктуирующие"), их результаты могут меняться без видимых причин (например, из-за загрузки сети или изменения данных в базе). Это затрудняет поиск настоящих ошибок. Самое главное: невозможно проверить, как тестируемый код ведет себя при специфических, но важных для безопасности условиях (например, отказ доступа к файлу, очень долгий ответ от внешнего сервиса аутентификации), которые сложно или невозможно воспроизвести с реальными зависимостями. Аудиторы могут усомниться в надежности таких тестов. | **Обязательно используйте тестовые двойники** (заглушки, имитаторы, фейки) для всех внешних зависимостей тестируемого кода. Настройте их поведение, чтобы полностью контролировать условия теста. **Используйте фикстуры** для сброса состояния тестового окружения перед каждым тестом, чтобы тесты были независимы друг от друга. **Избегайте зависимости от системного времени или порядка выполнения тестов.** |
| **Неполное покрытие сценариев безопасности** | Написаны тесты только для "идеальных" ситуаций (правильные входные данные, все работает как должно), но проигнорированы негативные сценарии, граничные условия, некорректные или потенциально опасные входные данные, сценарии обработки ошибок, ситуации с недостаточными правами доступа. | Критически важные дефекты безопасности могут остаться необнаруженными на низком уровне. Ошибки в обработке некорректных или опасных данных, уязвимости, связанные с граничными условиями или неправильной обработкой ошибок, будут выявлены только на более поздних и дорогих этапах тестирования или, что хуже, аудиторами при сертификации/контроле. | **Проводите тщательный анализ требований безопасности и формализованных "вопросов"** для выявления всех потенциально опасных сценариев. **Проектируйте тестовые сценарии целенаправленно** для негативных условий, граничных значений, ошибочных ситуаций, связанных именно с безопасностью (неверные учетные данные, попытка инъекции, отказ в доступе). **Думайте как злоумышленник** при определении тестовых сценариев для функций безопасности. Используйте техники тест-дизайна (классы эквивалентности, граничные значения) при планировании тестов безопасности. |
| **Тестирование слишком крупных "единиц" кода** | UNIT-тест проверяет не одну маленькую функцию или метод, а большой блок кода, состоящий из нескольких классов или даже модулей. | При неудаче теста очень трудно быстро понять, в каком конкретном месте большого блока кода находится ошибка. Это замедляет исправление дефектов. Тесты становятся больше похожи на интеграционные, теряя главное преимущество UNIT-тестов — быстроту выполнения и точную локализацию проблем. | **Строго придерживайтесь принципа UNIT-тестирования:** Проверять минимальный изолируемый кусок кода (отдельный метод, функция, небольшой класс). Если логика слишком сложная и распределена между несколькими классами, возможно, стоит пересмотреть структуру кода (провести рефакторинг), чтобы сделать его более модульным и легко тестируемым на низком уровне. |
| **Отсутствие четкой связи тестов с требованиями** | UNIT-тест написан, но нет понятной связи между каждым тестом и конкретным требованием безопасности, правилом из документации или "вопросом" сертификации, который этот тест проверяет. | Невозможно легко показать аудиторам ФСТЭК, что все требования безопасности проверены тестами. Трудно доказать полноту покрытия требований. Сложно понять, почему был написан именно этот тест и какое правило безопасности он подтверждает. Теряется ценность UNIT-тестов как доказательной базы для сертификации. | **Обязательно ведите и поддерживайте в актуальном состоянии матрицу трассируемости,** связывающую требования безопасности, формализованные "вопросы", тестируемые единицы кода и UNIT-тесты. **Используйте аннотации или комментарии в коде самих тестов,** указывающие на соответствующее требование или "вопрос" (например, `@Requirement("РД.СЗИ.ТР.2012 п.4.1")`, `@FSTECQuestion("Аутентификация: пустой пароль")`). |
| **Тесты зависят от неконтролируемого окружения** | Тесты полагаются на специфические настройки операционной системы, переменные окружения, или используют общие ресурсы (например, временные папки), которые могут быть изменены другими процессами или тестами. | Тесты становятся невоспроизводимыми. Они могут проходить на одной машине и падать на другой, или проходить при одном запуске и падать при следующем без изменений в коде. Это делает результаты тестов ненадежными и затрудняет автоматизацию в CI-системах. | **Запускайте тесты в контролируемом, изолированном тестовом окружении** (например, в контейнере Docker или виртуальной машине), где все зависимости и настройки стандартизированы. **Избегайте использования общих или нестабильных ресурсов** в тестах. Если нужно имитировать окружение, используйте тестовые двойники. |
| **Недостаточно детальные или некорректные утверждения** | Утверждения в тесте проверяют только факт выполнения метода без ошибок, но не проверяют точность возвращаемых значений, корректность изменения состояния объекта, правильность параметров вызова зависимостей (через имитаторы), или не проверяют обработку всех ожидаемых типов ошибок. | Тест может пройти успешно, даже если тестируемый код выполнил операцию некорректно с точки зрения безопасности (например, вернул неправильно зашифрованные данные, неверно определил права доступа, записал в аудит неполную информацию, выбросил исключение неверного типа). Дефект безопасности останется незамеченным тестом. | **Пишите полные и точные утверждения,** которые проверяют все аспекты ожидаемого поведения UUT: возвращаемое значение, конечное состояние объекта UUT, все важные взаимодействия с имитаторами (какие методы были вызваны, сколько раз, с какими параметрами), тип и содержимое выброшенных исключений. **Базируйте утверждения на точной спецификации поведения UUT и требованиях безопасности.** |
| **Сложность или низкое качество кода тестов** | Код самих UNIT-тестов плохо написан: он сложен для понимания, содержит много повторений, не структурирован, плохо читается другими инженерами. | Такие тесты трудно поддерживать. При внесении изменений в тестируемый код (рефакторинг) приходится тратить много времени на изменение тестов, и при этом легко внести ошибки в сами тесты. Это снижает доверие к тестам и их актуальность со временем. | **Применяйте принципы "чистого кода" (Clean Code) и к коду тестов.** **Рефакторите тестовый код** так же, как и основной код. **Используйте вспомогательные методы и фикстуры** для устранения дублирования кода в тестах. **Код теста должен быть проще кода, который он тестирует.** |

## 9\. Верификация UNIT-тестов и документирование

Важно не только написать UNIT-тесты, но и убедиться, что сами тесты правильные (не содержат ошибок) и надежно проверяют нужные аспекты кода. А также нужно правильно оформить всю информацию о тестировании для проверяющих. Документация по UNIT-тестированию является важной частью доказательной базы для аудиторов ФСТЭК.

### 9.1. Верификация корректности UNIT-тестов

Сами UNIT-тесты могут содержать ошибки (например, некорректные утверждения, неправильная настройка имитаторов), что может привести к ложноположительным (тест проходит, хотя в коде есть дефект) или ложноотрицательным (тест не проходит, хотя код корректен) результатам. Для верификации тестов применяются следующие подходы. Даже в коде тестов могут быть ошибки. Как проверить, что ваши тесты работают так, как нужно, и действительно выявляют дефекты, а не дают ложные результаты?

 * **Анализ Покрытия Кода:** Высокий процент покрытия кода, особенно по ветвлениям и условиям, косвенно свидетельствует о том, что большинство путей выполнения кода проверено тестами. Низкое покрытие указывает на пробелы, которые могут быть источником ошибок в тестах или тестируемом коде. Использование инструментов покрытия кода (Code Coverage tools) для определения, какие части исходного кода были выполнены во время запуска тестов.
 * **Мутационное Тестирование (Mutation Testing):** Инструменты мутационного тестирования вносят небольшие, синтаксически корректные изменения (мутации) в исходный код ПО (например, заменяют оператор `>`, на `<`, изменяют константу, удаляют вызов метода). Затем запускаются UNIT-тесты. Если UNIT-тесты корректны и покрывают измененный код, большинство мутаций должны привести к падению одного или нескольких тестов ("мутация убита"). Если мутация не убита, это может свидетельствовать о недостатке в UNIT-тестах (тесты не проверяют измененную логику) или ошибке в самой мутации. Использование специальных инструментов, которые автоматически вносят маленькие, типовые ошибки (мутации) в исходный код программы (например, меняют логический оператор `&&` на `||`, заменяют константу, удаляют строку). Затем запускаются UNIT-тесты.
 * **Code Review Тестового Кода:** Проведение анализа (ревью) кода UNIT-тестов другими инженерами для выявления логических ошибок, некорректных утверждений, проблем с изоляцией или читаемостью. Процесс анализа кода UNIT-тестов другими инженерами из команды.
 * **Парное Программирование при Написании Тестов:** Написание тестов в парах способствует немедленному обсуждению и выявлению потенциальных ошибок в логике теста или проверяемых утверждениях. Практика, когда два инженера работают за одним компьютером: один пишет код (драйвер), другой наблюдает, обдумывает и предлагает идеи (навигатор).

В следующей таблице описаны подходы к проверке качества самих UNIT-тестов.

| Подход к верификации качества тестов | Как это работает и почему это помогает |
| :--- | :--- |
| Анализ покрытия кода | Использование инструментов покрытия кода (Code Coverage tools) для определения, какие части исходного кода были выполнены во время запуска тестов. **Почему помогает:** Если какая-то часть кода, особенно связанная с безопасностью, вообще не была выполнена тестами, это явный признак пробела в тестировании. Важно анализировать не только покрытие по строкам, но и покрытие по ветвлениям (условиям if/else) и функциям, чтобы убедиться, что проверены разные пути выполнения кода. |
| Мутационное тестирование | Использование специальных инструментов, которые автоматически вносят маленькие, типовые ошибки (мутации) в исходный код программы (например, меняют логический оператор `&&` на `||`, заменяют константу, удаляют строку). Затем запускаются UNIT-тесты. **Почему помогает:** Если UNIT-тест написан правильно и проверяет участок кода, где произошла мутация, он должен "сломаться" (тест "убивает" мутацию). Если тест не падает, это может означать, что тест недостаточно хорошо проверяет этот участок кода, и его нужно улучшить, или что мутация эквивалентна исходному коду (редко). |
| Code review тестового кода | Процесс анализа кода UNIT-тестов другими инженерами из команды. **Почему помогает:** Другой человек может заметить логические ошибки в тесте, неправильно написанные утверждения, некорректную настройку тестовых двойников, проблемы с изоляцией или плохую читаемость кода теста. Взгляд со стороны помогает выявить ошибки, которые мог пропустить автор теста. |
| Парное программирование при написании тестов | Практика, когда два инженера работают за одним компьютером: один пишет код (драйвер), другой наблюдает, обдумывает и предлагает идеи (навигатор). **Почему помогает:** При написании тестов в паре происходит немедленное обсуждение сценариев, входных данных, ожидаемых результатов и способов проверки (утверждений). Это позволяет на лету выявлять и исправлять логические ошибки, уточнять понимание требований и повышать качество кода тестов сразу в процессе написания. |

### 9.2. Документирование процесса и результатов UNIT-тестирования

Документация по UNIT-тестированию является важной частью доказательной базы для аудиторов ФСТЭК. Должны быть документированы: Важно не только проводить тесты, но и иметь возможность доказать, что тесты были проведены правильно, и показать их результаты. Документация — это часть этой доказательной базы.

 * **Методика Тестирования:** Настоящий документ является основой для описания подхода к UNIT-тестированию. Документ (например, настоящий), описывающий общий подход вашей команды к написанию UNIT-тестов, принципы, этапы процесса, используемые инструменты, стратегии тестирования (например, как тестируются функции безопасности).
 * **Матрица Трассируемости:** Документ, связывающий требования безопасности, формализованные "вопросы" и UNIT-тесты. Демонстрирует покрытие требований тестами. Таблица (как описано в разделе 5.1.4), связывающая требования безопасности, формализованные "вопросы" сертификации/контроля, тестируемые единицы кода и UNIT-тесты.
 * **Планы UNIT-тестов:** Описание разработанных тестовых сценариев, входных данных, ожидаемых результатов для критически важных модулей, если это требует дополнительной детализации сверх кода теста. Более детальное описание тестовых сценариев (входные данные, действия, ожидаемые результаты) для наиболее критичных с точки зрения безопасности модулей, если эта информация не полностью очевидна из кода тестов.
 * **Код UNIT-тестов:** Исходный код самих тестов, являющийся основным и наиболее точным описанием проверок. Код должен быть снабжен комментариями, объясняющими неочевидные моменты, особенно связанные со спецификой проверок безопасности. Сам код ваших UNIT-тестов.
 * **Отчеты о Выполнении Тестов:** Автоматически сгенерированные отчеты о каждом запуске набора UNIT-тестов, содержащие результаты (успех/неудача), информацию о покрытии кода. Автоматически сгенерированные отчеты после каждого запуска набора UNIT-тестов, содержащие информацию о количестве пройденных/неудачных тестов, деталях ошибок, покрытии кода.
 * **Информация о Тестовом Окружении:** Описание тестового окружения, в котором выполняются тесты, включая версии используемых инструментов (фреймворк, библиотеки мокирования), конфигурацию среды выполнения. Описание среды, в которой выполняются UNIT-тесты (операционная система, версии используемых фреймворков и библиотек, конфигурация).
 * **Процедуры Выполнения Тестов:** Описание процесса запуска UNIT-тестов (например, команды сборки и тестирования), интегрированного в CI/CD. Описание шагов или команд для запуска UNIT-тестов, например, в рамках системы CI/CD.
 * **Результаты Анализа Дефектов:** Фиксация выявленных в результате UNIT-тестирования дефектов, их связь с требованиями безопасности, статус устранения. Информация об ошибках, найденных с помощью UNIT-тестов, их описание, связь с требованиями безопасности, статус исправления.

Вся документация должна быть актуальной, точной и доступной для аудита. Вся документация должна быть актуальной, храниться в доступном месте и быть готовой для предоставления аудиторам.

В следующей таблице приведены основные типы документации, связанные с UNIT-тестированием в данном контексте.

| Тип документации | Что этот документ должен описывать и зачем он нужен |
| :--- | :--- |
| Методика тестирования | Документ (например, настоящий), описывающий общий подход вашей команды к написанию UNIT-тестов, принципы, этапы процесса, используемые инструменты, стратегии тестирования (например, как тестируются функции безопасности). **Зачем нужен:** Показывает аудиторам, что у вас есть формализованный, систематический процесс тестирования. |
| Матрица трассируемости | Таблица (как описано в разделе 5.1.4), связывающая требования безопасности, формализованные "вопросы" сертификации/контроля, тестируемые единицы кода и UNIT-тесты. **Зачем нужна:** Демонстрирует полноту покрытия требований безопасности UNIT-тестами, помогает убедиться, что все важные аспекты безопасности проверены, и облегчает поиск тестов, относящихся к конкретному требованию или "вопросу". |
| Планы UNIT-тестов (для критичных модулей) | Более детальное описание тестовых сценариев (входные данные, действия, ожидаемые результаты) для наиболее критичных с точки зрения безопасности модулей, если эта информация не полностью очевидна из кода тестов. **Зачем нужен:** Предоставляет дополнительное описание проверок для аудиторов, особенно для сложных сценариев или сценариев, связанных с нормативными требованиями. |
| Исходный код UNIT-тестов | Сам код ваших UNIT-тестов. **Зачем нужен:** Это наиболее точное и актуальное описание всех выполняемых проверок. Код должен быть чистым, понятным, с комментариями, объясняющими специфику проверок безопасности или использование тестовых двойников. |
| Отчеты о выполнении тестов | Автоматически сгенерированные отчеты после каждого запуска набора UNIT-тестов, содержащие информацию о количестве пройденных/неудачных тестов, деталях ошибок, покрытии кода. **Зачем нужны:** Являются объективным доказательством результатов тестирования. Показывают, что тесты регулярно выполняются, и помогают отслеживать качество кода. Могут быть представлены аудиторам в качестве подтверждения. |
| Информация о тестовом окружении | Описание среды, в которой выполняются UNIT-тесты (операционная система, версии используемых фреймворков и библиотек, конфигурация). **Зачем нужна:** Обеспечивает воспроизводимость результатов тестирования и позволяет аудиторам понять условия, в которых проводились тесты. |
| Процедуры выполнения тестов | Описание шагов или команд для запуска UNIT-тестов, например, в рамках системы CI/CD. **Зачем нужна:** Формализует процесс запуска тестов, показывает, что тесты являются частью автоматизированного процесса разработки. |
| Результаты анализа дефектов | Информация об ошибках, найденных с помощью UNIT-тестов, их описание, связь с требованиями безопасности, статус исправления. **Зачем нужна:** Демонстрирует, что процесс тестирования эффективен и позволяет выявлять и устранять дефекты, влияющие на безопасность. |

## 10\. Заключение

UNIT-тестирование, систематически применяемое и сфокусированное на вопросах безопасности и требованиях регуляторов, является мощным инструментом обеспечения качества и подтверждения соответствия программного обеспечения в процессе сертификации ФСТЭК и инспекционного контроля. Данная методика предоставляет структурированный инженерный подход к созданию эффективных, воспроизводимых и верифицируемых UNIT-тестов, позволяя на ранних этапах разработки выявлять и устранять дефекты, критичные для безопасности информации. Строгое следование описанным принципам и этапам, а также должное документирование процесса и результатов тестирования, способствует построению надежной доказательной базы для успешного прохождения процедур оценки соответствия. UNIT-тестирование — это необходимый и очень эффективный инструмент в процессе разработки программного обеспечения, особенно когда речь идет о подтверждении его соответствия строгим требованиям безопасности, как в случае сертификации ФСТЭК и инспекционного контроля.

Применение описанной методики позволяет систематизировать подход к созданию UNIT-тестов, сделать их сфокусированными на проверке критически важных с точки зрения безопасности аспектов программы и обеспечить их надежность. Использование тестовых двойников, тщательное планирование сценариев (включая негативные и ошибочные), автоматизация выполнения и анализ результатов с привязкой к требованиям — все это создает прочную основу для выявления дефектов на ранних этапах и формирования убедительной доказательной базы для аудиторов.

Следуя этой методике, инженеры могут создавать высококачественные UNIT-тесты, которые не только улучшают стабильность и надежность программы в целом, но и играют ключевую роль в успешном прохождении процедур оценки соответствия по требованиям безопасности информации.
