# Методика создания UNIT-тестов для вопросов проведения сертификации ПО во ФСТЭК и инспекционного контроля

## 1. Введение

Этот документ объясняет, как писать UNIT-тесты для компьютерных программ. Эти тесты помогают убедиться, что программа работает правильно, особенно в тех частях, которые важны для получения специального разрешения ФСТЭК России или при последующих проверках.

Мы подготовили эту методику для инженеров — людей, которые пишут программы или проверяют их работу. Она поможет создать автоматические тесты для проверки отдельных кусочков программы. Такие тесты нужны, чтобы найти ошибки и убедиться, что программа соответствует требованиям безопасности. Это особенно важно, когда программу проверяют для сертификации или во время инспекционного контроля.

Наша цель — дать понятные шаги для написания верифицируемых и воспроизводимых тестов, которые покажут, что отдельные части программы работают так, как ожидается, особенно в ситуациях, связанных с безопасностью информации.

## 2. Глоссарий терминов

В этом разделе собраны и объяснены специальные слова и понятия, которые используются в данном документе. Понимание этих терминов необходимо для правильного применения описанной методики.

| Термин | Определение |
| :--- | :--- |
| UNIT-тест (Юнит-тест) | Самый базовый вид автоматического теста. Он проверяет самую маленькую, отдельно работающую часть программы (например, одну функцию, один метод класса или небольшой класс). Цель — убедиться, что этот конкретный, изолированный кусочек кода выполняет свою задачу правильно при различных входных данных и условиях. |
| Программное Обеспечение (ПО) | Полный набор инструкций (программ), которые говорят компьютеру, что делать, а также связанных с ними данных. |
| ФСТЭК России | Федеральная служба по техническому и экспортному контролю. Государственный орган Российской Федерации, отвечающий, в частности, за регулирование в области защиты информации, выдачу сертификатов соответствия на средства защиты информации и информационные технологии. |
| Сертификация ПО во ФСТЭК | Процедура подтверждения соответствия программного обеспечения установленным требованиям безопасности информации, выполняемая органом по сертификации, аккредитованным ФСТЭК России. Результатом успешного прохождения процедуры является выдача сертификата соответствия, разрешающего использование ПО в информационных системах с определенным классом защищенности. |
| Инспекционный Контроль | Плановая или внеплановая проверка сертифицированного программного обеспечения, проводимая ФСТЭК России или аккредитованным органом по сертификации после выдачи сертификата. Цель — убедиться, что ПО продолжает соответствовать требованиям безопасности после внесения изменений или в процессе эксплуатации. |
| Вопросы проведения сертификации/инспекционного контроля | Конкретные пункты программы оценки соответствия, требования, тесты или проверки, выполняемые экспертами (аудиторами) органа по сертификации или ФСТЭК России в ходе сертификационных испытаний или инспекционного контроля. Они детализируют, какие аспекты безопасности ПО подлежат проверке. |
| Требования безопасности информации | Правила, стандарты, условия и спецификации, которым должно соответствовать программное обеспечение для обеспечения защиты информации от угроз (несанкционированный доступ, изменение, уничтожение, блокирование и др.). Они могут быть установлены законодательством, нормативными документами ФСТЭК, государственными стандартами, техническими заданиями. |
| Функции безопасности | Части программного кода или модули ПО, реализующие конкретные механизмы защиты информации. К ним относятся, например, функции аутентификации пользователя, авторизации (проверки прав доступа), контроля целостности данных, шифрования, регистрации событий аудита. |
| Недекларированные возможности | Функциональные возможности программного обеспечения, не описанные в документации, которые могут быть использованы для получения несанкционированного доступа к информации, изменения или уничтожения информации, а также для воздействия на функционирование программного обеспечения или информационной системы в целом. Проверяется их отсутствие. |
| Трассируемость | Возможность установить и проследить логическую связь между различными элементами проекта разработки (например, между требованием безопасности, соответствующим фрагментом исходного кода и UNIT-тестом, который этот фрагмент проверяет). Обеспечивает прозрачность и полноту проверки требований. |
| Тестовый сценарий | Подробное описание шагов, условий и ожидаемого результата, необходимых для выполнения конкретной проверки функциональности или свойства программного обеспечения. Используется как план для написания автоматического теста. |
| Тестовые двойники | Объекты или компоненты, созданные специально для тестирования, которые заменяют реальные зависимости тестируемого кода (другие модули, базы данных, сетевые сервисы, файловая система). Используются для изоляции UNIT-тестируемого кода и управления его окружением. Основные типы: Заглушка, Имитатор, Фейк. |
| Заглушка (Stub) | Простейший вид тестового двойника. Используется для подмены зависимости, когда тестируемому коду нужен только определенный заранее заданный ответ от этой зависимости. Заглушка просто возвращает фиктивное значение и не содержит сложной логики или проверок. |
| Имитатор (Mock) | Тестовый двойник, который не только возвращает заранее заданные значения, но и позволяет проверить, что тестируемый код правильно взаимодействует с этой зависимостью — вызывает определенные методы с нужными параметрами и в правильном порядке. Используется для проверки *взаимодействия*, а не только *результата*. |
| Фейк (Fake) | Тестовый двойник, который имеет упрощенную, но рабочую реализацию логики реальной зависимости (например, базу данных, которая работает только в памяти). Используется, когда заглушки или имитаторы недостаточны, но полная реальная зависимость избыточна или сложна для использования в тесте. |
| Утверждение (Assertion) | Оператор или вызов функции в коде теста, который проверяет истинность определенного условия — сравнивает фактический результат выполнения тестируемого кода с ожидаемым результатом. Если условие истинно, утверждение проходит. Если ложно, утверждение проваливается, и тест помечается как неудачный. |
| Фикстура (Fixture) | Код или данные, которые подготавливают тестовое окружение для выполнения одного или нескольких тестов (например, создают необходимые объекты, загружают тестовые данные, настраивают имитаторы) и очищают его после выполнения тестов. Гарантируют, что каждый тест выполняется в одинаковых, предсказуемых условиях. |
| UUT (Unit Under Test) | Единица (часть) программного обеспечения, которая непосредственно проверяется конкретным UNIT-тестом. |
| Arrange-Act-Assert (AAA) | Популярный шаблон организации кода UNIT-теста, разделяющий его на три логических части: Arrange (Подготовка окружения), Act (Выполнение тестируемого кода), Assert (Проверка результата с помощью утверждений). |
| Given-When-Then (GWT) | Альтернативный шаблон для организации UNIT-тестов, часто используемый в поведении-ориентированном тестировании. Структурирует тест в виде "Дано" (исходное состояние), "Когда" (происходит действие), "Тогда" (ожидаемый результат). |
| CI/CD (Continuous Integration / Continuous Delivery) | Набор практик в разработке ПО, направленных на частую и автоматическую интеграцию изменений кода, выполнение автоматизированных тестов (CI) и, при успешном прохождении тестов, автоматизированную подготовку к выпуску или выпуск новой версии ПО (CD). |
| Покрытие кода (Code Coverage) | Метрика, показывающая, какая часть исходного кода программы была выполнена (пройдена) во время выполнения определенного набора тестов. Помогает оценить, насколько полно тесты затрагивают различные части кода. Измеряется в процентах (по строкам, ветвлениям, функциям). |
| Мутационное тестирование (Mutation Testing) | Техника для оценки качества самих тестов. Специальные инструменты вносят небольшие автоматические изменения (мутации) в исходный код программы (например, меняют логический оператор `&&` на `||`, заменяют константу, удаляют строку). Затем запускаются тесты. Если тест разработан правильно и проверяет измененный участок кода, он должен "сломаться" ("убить" мутацию). Если тест не падает, возможно, он неэффективен. |

## 3. Контекст: сертификация ПО во ФСТЭК и инспекционный контроль

Сертификация ПО во ФСТЭК — это процесс, когда вашу программу проверяют на соответствие требованиям безопасности, чтобы подтвердить, что она может использоваться, например, для работы с конфиденциальной информацией. Это как пройти строгий технический осмотр. Эксперты смотрят, насколько хорошо программа защищает данные, нет ли в ней "дыр" для злоумышленников и соответствует ли она правилам, установленным ФСТЭК.

"Вопросы" во время сертификации и последующих проверок (инспекционного контроля) — это конкретные задания или проверки, которые эксперты проводят, чтобы убедиться в безопасности. Они могут касаться самых разных аспектов работы программы.

В следующей таблице приведены примеры типовых областей и связанных с ними "вопросов", которые могут возникнуть в процессе сертификации или контроля.

| Область проверки безопасности | Пример "вопроса" сертификации/контроля |
| :--- | :--- |
| Аутентификация пользователя | Как программа проверяет подлинность пользователя при входе? Какие требования к сложности пароля применяются? Что происходит при вводе неверных учетных данных? |
| Авторизация и разграничение доступа | Правильно ли программа определяет, к каким данным или функциям имеет доступ конкретный пользователь? Что происходит, если пользователь пытается получить доступ к запрещенному ресурсу? |
| Контроль целостности | Как программа убеждается, что важные файлы или данные не были изменены без разрешения? Проверяется ли целостность исполняемых файлов самой программы при запуске? |
| Обработка конфиденциальных данных | Как программа защищает чувствительные данные (например, пароли, персональные данные) во время их обработки и хранения? Правильно ли выполняется шифрование или обезличивание? |
| Регистрация и аудит событий безопасности | Какие действия пользователя или системные события регистрируются программой? Содержат ли записи аудита всю необходимую информацию (кто, что, когда, результат)? |
| Обработка ошибок и исключений | Как программа реагирует на ошибки, которые могут повлиять на безопасность (например, сбой при записи в журнал аудита)? Не раскрывает ли программа слишком много информации об ошибках, которая может быть использована злоумышленником? |
| Проверка ввода пользовательских данных | Как программа обрабатывает данные, которые вводит пользователь? Проверяются ли данные на наличие опасных символов или команд, которые могут привести к атакам (например, SQL-инъекции, XSS)? |

Инспекционный контроль — это проверка того, что программа остается безопасной после того, как вы ее обновили или внесли изменения. "Вопросы" тут часто связаны с тем, как эти изменения повлияли на функции безопасности.

## 4. Назначение UNIT-тестирования в контексте ФСТЭК

UNIT-тестирование — это мощный технический инструмент, который помогает удостовериться, что самые маленькие части вашей программы работают правильно. В контексте сертификации ФСТЭК и инспекционного контроля UNIT-тесты играют особую роль. Они не просто помогают найти ошибки; они создают основу доказательств того, что программа соответствует требованиям безопасности на уровне ее отдельных компонентов.

UNIT-тесты помогают:

* **Найти ошибки безопасности очень рано.** Обнаружить проблемы в коде, который отвечает за безопасность (например, ошибка в функции проверки пароля или неправильная обработка прав доступа), еще до того, как этот код будет собран с другими частями программы. Это значительно дешевле и быстрее, чем искать их позже, когда все части собраны вместе.
* **Убедиться, что конкретные требования выполнены.** Проверить, что отдельные функции или алгоритмы программы работают именно так, как требуют правила безопасности ФСТЭК или техническое задание. Например, удостовериться, что функция шифрования вызывает криптографическую библиотеку с правильными параметрами.
* **Получить надежные доказательства.** Автоматизированные UNIT-тесты можно запускать снова и снова, и они всегда дадут одинаковый результат (если код не менялся). Успешные тесты являются объективным доказательством того, что проверенный кусок кода ведет себя правильно в различных сценариях, в том числе важных для безопасности.
* **Снизить риски при проверках.** Если у вас есть большой набор UNIT-тестов, покрывающих критичные для безопасности части программы, вы можете показать аудиторам, что регулярно проверяете эти части, и что последние изменения не нарушили их работу. Это упрощает прохождение инспекционного контроля.
* **Сделать код более качественным.** Процесс написания UNIT-тестов часто подталкивает разработчиков создавать код, который легче тестировать. Такой код обычно более четко разделен на части, проще для понимания и поддержки, что само по себе снижает вероятность появления ошибок.

UNIT-тесты не заменяют другие виды проверок (тестирование всей программы в целом, поиск уязвимостей), но они создают прочную базу. Они подтверждают правильность работы базовых строительных блоков программы.

При разработке UNIT-тестов для целей сертификации и контроля ФСТЭК важно следовать основным принципам, чтобы тесты были эффективными и их результаты были надежными:

* **Изоляция.** Каждый тест должен проверять только один маленький кусок кода и не зависеть от других частей программы или внешних условий.
* **Автоматизация.** Тесты должны запускаться автоматически, без участия человека.
* **Повторяемость.** Один и тот же тест, запущенный несколько раз при тех же условиях, всегда должен давать один и тот же результат.
* **Независимость.** Результат одного теста не должен влиять на результат другого теста.
* **Быстрота.** Тесты должны выполняться очень быстро, чтобы их можно было запускать часто.
* **Связь с безопасностью.** В первую очередь нужно тестировать те части кода, которые напрямую связаны с функциями безопасности и требованиями ФСТЭК.
* **Трассируемость.** Должна быть четкая связь между тестом, кодом, который он проверяет, и правилом безопасности, для которого этот тест написан.
* **Читаемость.** Код тестов должен быть понятным другим инженерам.

## 5. Методология создания UNIT-тестов для вопросов сертификации

Процесс создания UNIT-тестов, полезных для сертификации ФСТЭК, состоит из нескольких последовательных шагов.

### 5.1. Шаг 1: Анализ требований и превращение "вопросов" в задачи для тестов

Этот шаг самый важный и требует внимательного изучения документов и понимания, что именно будут проверять аудиторы.

#### 5.1.1. Поиск правил безопасности, которые касаются вашей программы

На этом этапе вы изучаете все документы, где описаны требования к безопасности вашей программы. Цель — найти конкретные, измеримые требования, которые можно проверить.

Следующая таблица показывает, какие типы документов могут содержать такую информацию и на что в них нужно обращать внимание.

| Тип документа | Что искать в этих документах |
| :--- | :--- |
| Нормативные документы ФСТЭК России | Общие требования к уровням доверия ПО, требования к системам защиты информации. Ищите конкретные пункты, описывающие функции безопасности (например, требования к механизмам аутентификации, контроля доступа, аудита). |
| Техническое задание на создание системы защиты информации | Раздел, описывающий функции и механизмы защиты информации, которые должны быть реализованы в программе. Ищите детали о том, как именно должны работать эти механизмы (например, алгоритм хеширования паролей, правила разграничения доступа). |
| Техническое задание на программное обеспечение | Если отдельного ТЗ на СЗИ нет, требования безопасности могут быть включены в общее ТЗ на ПО. Ищите разделы, касающиеся безопасности, защиты данных, обработки ошибок, требований к надежности и устойчивости. |
| Эксплуатационная документация на ПО | Описание функций безопасности с точки зрения пользователя или администратора. Как настроить безопасность, как работают функции входа, управления пользователями, аудита. Это помогает понять ожидаемое поведение системы. |
| Технические условия (ТУ) на ПО | Документ, описывающий основные характеристики и требования к программе. Раздел, связанный с требованиями безопасности или специальными требованиями. |
| Иные стандарты или политики безопасности | Внутренние политики компании, отраслевые стандарты (если применимы). Могут содержать дополнительные требования к обработке данных, использованию криптографии, реагированию на инциденты. |

Из этих документов нужно "вытащить" конкретные формулировки, которые можно проверить. Например, из документа ФСТЭК может быть получено требование "Все события безопасности, связанные с доступом к конфиденциальным данным, должны быть зарегистрированы".

#### 5.1.2. Определение, какой код выполняет эти правила

После того как вы нашли конкретные требования безопасности, нужно понять, какие части вашего кода отвечают за их выполнение. Найдите модули, классы, функции или методы, которые реализуют каждое требование.

Например, если требование — "Все события безопасности, связанные с доступом к конфиденциальным данным, должны быть зарегистрированы", то, вероятно, это требование реализуется в методах, которые предоставляют доступ к этим данным, и в модуле, который отвечает за запись в журнал аудита. Например, метод `DataAccessService.readConfidentialData` должен после успешного или неудачного чтения вызвать метод `AuditLogger.logEvent`.

#### 5.1.3. Формализация "вопросов" сертификации/контроля

Подумайте, какие конкретные проверки или вопросы могут задать эксперты ФСТЭК или лаборатории, исходя из требований, которые вы нашли. Превратите эти возможные вопросы в четкие, проверяемые задания для ваших UNIT-тестов.

Следующая таблица показывает, как преобразовать типовые "вопросы" аудиторов в конкретные задачи для тестирования.

| Исходный "вопрос" сертификации/контроля | Как превратить в задачу для UNIT-теста (пример) |
| :--- | :--- |
| Как система проверяет учетные данные пользователя при входе? | *Задача теста:* проверить, что метод `checkLoginPassword` возвращает `true` для правильной пары логин/пароль и `false` для неправильной. Проверить граничные случаи: пустой логин, пустой пароль, очень длинные значения. |
| Правильно ли программа определяет, к каким данным имеет доступ конкретный пользователь? | *Задача теста:* проверить, что метод `canAccessResource` возвращает `true` для пользователя с ролью "администратор" при попытке доступа к ресурсу "/settings" и `false` для пользователя с ролей "гость". Проверить разные комбинации ролей и ресурсов согласно правилам доступа. |
| Как программа обрабатывает данные, которые вводит пользователь, на наличие опасных символов? | *Задача теста:* проверить, что функция `sanitizeInput` удаляет или преобразует специальные символы (например, `<script>`, `--`, `'`) из входной строки. Проверить, что функция правильно обрабатывает обычный текст без опасных символов. |
| Вызывают ли функции входа/выхода или изменения прав записи в журнал аудита? | *Задача теста:* используя имитатор для журнала аудита, проверить, что метод `processLogin` вызывает метод `logEvent` имитатора с типом события "успешный вход" и правильными параметрами (имя пользователя, время). Аналогично проверить неудачные входы и другие важные события. |
| Как функция шифрования работает с разными ключами и данными? | *Задача теста:* проверить, что метод `encryptData` успешно шифрует тестовые данные, используя валидный ключ. Проверить, что попытка расшифровать данные неверным ключом приводит к ошибке или возвращает некорректные данные. |
| Что происходит, если функция, работающая с файлами, пытается получить доступ к файлу без достаточных прав? | *Задача теста:* используя имитатор файловой системы, настроенный так, чтобы запретить доступ к определенному файлу, проверить, что метод `readFileContent` в этом случае выбрасывает ожидаемое исключение `PermissionDeniedException`. |

Например, если аудитор может спросить "Что произойдет, если пользователь попытается войти с пустым паролем?", то задача для вашего UNIT-теста будет "Проверить, что метод `AuthService.authenticate` возвращает ошибку 'пустой пароль недопустим', если в качестве пароля передана пустая строка".

#### 5.1.4. Создание матрицы трассируемости

Очень полезно создать таблицу, которая показывает связи между требованиями безопасности (из документов), формализованными "вопросами" и конкретными частями вашего кода (модулями/функциями), которые реализуют эти требования. Затем вы добавите в эту таблицу информацию о UNIT-тестах, которые проверяют эти части кода.

Эта таблица (матрица трассируемости) служит картой, которая помогает убедиться, что вы ничего не пропустили, и позволяет легко показать проверяющим, какие тесты подтверждают выполнение каких требований безопасности.

| Идентификатор требования (Документ, пункт) | Описание требования безопасности | Формализованный "вопрос" сертификации/контроля | Идентифицированная единица кода (Модуль, функция) | Идентификатор UNIT-теста(ов) (название класса/метода) | Примечание (Связь, реализация) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| РД ФСТЭК, Уровень доверия 4, п. X.Y | Система должна выполнять строгую аутентификацию пользователей. | Как система проверяет учетные данные пользователя? Какие методы аутентификации поддерживаются? | `AuthService`, методы `authenticate`, `verifyToken` | `AuthServiceTest.testAuthenticateValidCredentials`, `AuthServiceTest.testVerifyTokenExpired`, `AuthServiceTest.testAuthenticateInvalidCredentials`, `AuthServiceTest.testAuthenticateEmptyPassword`, `AuthServiceTest.testVerifyTokenInvalid`, `AuthServiceTest.testVerifyTokenExpired` | `authenticate` реализует проверку логина/пароля, `verifyToken` - проверку токенов сессии. Проверяем как успешные, так и неудачные сценарии для каждой функции. |
| ТЗ на СЗИ, раздел 3.2.1 | Все неуспешные попытки входа должны регистрироваться в журнале. | Фиксируются ли неудачные попытки входа в журнале аудита? | `AuthService`, метод `authenticate`; `AuditLogger`, метод `logEvent` | `AuthServiceTest.testAuthenticateInvalidPasswordLogsAttempt`, `AuthServiceTest.testAuthenticateNonExistentUserLogsAttempt` | `authenticate` вызывает `AuditLogger.logEvent` при любой неудаче аутентификации (неверный пароль, несуществующий пользователь). Тесты проверяют, что вызов `logEvent` с правильными параметрами *происходит* при неудаче. |
| ТУ на ПО, требование 5.1 | Пароль должен соответствовать политике сложности. | Как система проверяет сложность нового пароля? | `PasswordPolicyChecker`, метод `checkComplexity` | `PasswordPolicyCheckerTest.testCheckComplexityValid`, `PasswordPolicyCheckerTest.testCheckComplexityTooShort`, `PasswordPolicyCheckerTest.testCheckComplexityNoDigit`, `PasswordPolicyCheckerTest.testCheckComplexityNoSpecialChar`, `PasswordPolicyCheckerTest.testCheckComplexityTooLong` | `checkComplexity` реализует логику проверки всех правил сложности пароля (длина, наличие цифр, спецсимволов, верхнего/нижнего регистра). Тесты покрывают все условия проверки. |

Пример использования матрицы: Если аудитор спрашивает про аутентификацию (первая строка), вы можете показать ему тесты `AuthServiceTest`, которые подтверждают, что метод `authenticate` работает правильно в разных ситуациях.

### 5.2. Шаг 2: Спланировать, какие именно тесты нужно написать

На этом этапе вы подробно продумываете, как именно будете проверять каждый "юнит" кода, связанный с безопасностью, используя UNIT-тесты.

#### 5.2.1. Определение тестируемых единиц

Для каждой строчки в вашей матрице трассируемости, где указана часть кода, вы определяете, какой именно "юнит" будет тестироваться. Это может быть один метод, одна функция или один небольшой класс. Важно выбрать минимально возможный, но осмысленный для проверки безопасности кусок кода.

Пример: Если требование "Все события безопасности должны регистрироваться", а код, связанный с этим, находится в классах `EventProcessor` (который решает, какие события важны) и `AuditLogger` (который записывает их), то тестируемой единицей может быть метод `EventProcessor.processEvent`, который должен, получив определенный тип события, вызвать метод `AuditLogger.log`. UNIT-тест будет проверять только метод `processEvent` в изоляции, используя имитатор для `AuditLogger`.

#### 5.2.2. Определение тестовых сценариев

Для каждой тестируемой единицы и связанного с ней требования безопасности или "вопроса" нужно придумать тестовые сценарии. Сценарий описывает конкретную ситуацию, которую вы хотите проверить. Думайте о разных способах, как можно использовать этот кусок кода, включая те, которые могут привести к ошибкам или проблемам безопасности.

Следующая таблица описывает основные типы тестовых сценариев, которые следует создавать.

| Тип тестового сценария | Цель сценария и на что он должен быть направлен | Пример (обобщенный) |
| :--- | :--- | :--- |
| Позитивные сценарии | Проверка того, что тестируемый код правильно выполняет свою задачу в нормальных, ожидаемых условиях, когда все входные данные корректны, а зависимости ведут себя как положено. Это подтверждает базовую работоспособность функции безопасности. | Проверка того, что функция аутентификации успешно выполняет вход при вводе правильных логина и пароля. Проверка того, что функция шифрования корректно шифрует данные валидным ключом. |
| Негативные сценарии | Проверка того, как тестируемый код реагирует на некорректные, неполные, граничные или заведомо "плохие" входные данные или условия. Это критически важно для безопасности, так как часто именно некорректная обработка ошибок или неожиданных данных приводит к уязвимостям. | Проверка того, что функция аутентификации отклоняет вход при неверном пароле, пустом логине, недопустимых символах в поле логина. Проверка того, что функция санитизации правильно удаляет опасные символы из строки. |
| Сценарии обработки исключений/ошибок | Проверка того, как тестируемый код ведет себя при возникновении внутренних ошибок или исключительных ситуаций, которые могут возникнуть в реальной работе или при попытке атаки (например, нет доступа к файлу, ошибка при обращении к базе данных, неверный формат данных). Нужно проверить, что ошибки обрабатываются безопасно и корректно. | Проверка того, что функция, читающая конфигурацию безопасности из файла, выбрасывает ожидаемое исключение, если файл не найден или имеет неверный формат. Проверка того, что функция доступа к ресурсу выбрасывает ошибку "доступ запрещен", если у пользователя нет прав. |

Пример: Для функции `checkComplexity` (проверка сложности пароля) нужно создать как минимум следующие сценарии:
* Позитивный: Пароль соответствует всем требованиям (длина, символы).
* Негативные: Пароль слишком короткий, нет цифр, нет заглавных букв, содержит недопустимые символы.
* Обработка исключений: Передан `null` или пустая строка (если это не считается негативным сценарием, а отдельным типом ошибки).

#### 5.2.3. Определение входных данных и ожидаемых результатов

Для каждого придуманного сценария точно опишите:
* **Что нужно подготовить до теста (Arrange):** Какие объекты должны существовать, как должны быть настроены тестовые двойники (заглушки/имитаторы), какие начальные данные нужны.
* **Что вы делаете для проверки (Act):** Какие конкретные значения вы передаете тестируемому коду, какую функцию вызываете.
* **Что вы ожидаете получить в результате (Assert):** Какое значение должна вернуть функция, как должно измениться состояние объектов, какие методы тестовых двойников должны быть вызваны, какие ошибки (исключения) должны возникнуть. Ожидаемый результат должен быть однозначно определен на основе правил безопасности и логики работы кода.

Пример: Для сценария "Функция проверки сложности пароля: Пароль слишком короткий" (из 5.2.2):
* **Arrange:** Создать экземпляр класса `PasswordPolicyChecker`. Настроить объект конфигурации (если он используется `PasswordPolicyChecker`) так, чтобы минимальная длина пароля была 8 символов.
* **Act:** Вызвать метод `passwordPolicyChecker.checkComplexity("Short1")`.
* **Assert:** Ожидается, что метод `checkComplexity` вернет значение `false`, или выбросит исключение типа `WeakPasswordException` с сообщением, указывающим на недостаточную длину.

#### 5.2.4. Определение необходимых имитаторов, заглушек и фейков

Решите, какие зависимости вашего тестируемого кода (другие модули, доступ к файлам, базе данных, сети) нужно заменить на тестовые двойники (заглушки, имитаторы или фейки), чтобы тест был изолированным и повторяемым. Определите, какой тип двойника лучше подходит для каждой зависимости, исходя из того, что вы проверяете (только возвращаемое значение, взаимодействие или упрощенную логику).

Пример: Если метод `DataAccessService.readConfidentialData` (ваш UUT) обращается к службе журналирования (`AuditLogger`), чтобы зарегистрировать факт доступа, и к службе проверки прав (`PermissionChecker`), чтобы убедиться, что пользователь имеет доступ, то в UNIT-тесте для `DataAccessService.readConfidentialData` вам понадобятся:
* Имитатор (`Mock`) для `AuditLogger`: чтобы проверить, что метод `logEvent` был вызван после попытки доступа.
* Заглушка (`Stub`) для `PermissionChecker`: чтобы настроить, будет ли проверка прав успешной или нет для конкретного сценария теста (например, для негативного сценария "доступ запрещен" заглушка `PermissionChecker` должна вернуть `false`).

### 5.3. Шаг 3: Написание самого кода UNIT-тестов

На этом этапе вы пишете реальный код UNIT-тестов на выбранном языке программирования, используя фреймворк для тестирования.

#### 5.3.1. Выбор фреймворка для UNIT-тестирования

Выберите подходящий набор инструментов (фреймворк) для написания и запуска UNIT-тестов. Выбор зависит от языка, на котором написана ваша программа.

| Язык программирования | Примеры популярных фреймворков для UNIT-тестирования |
| :--- | :--- |
| Java | JUnit, TestNG |
| C# | NUnit, xUnit.net, MSTest |
| Python | unittest, pytest, nose |
| C++ | Google Test, Catch2, Boost.Test |
| JavaScript | Jest, Mocha, Jasmine |
| ... | ... |

Выбирайте фреймворк, который широко используется, хорошо документирован, поддерживает создание тестовых двойников и интегрируется с вашей системой сборки.

Пример: Если ваша программа написана на Java, вы выберете JUnit или TestNG в качестве фреймворка для UNIT-тестирования. Если на C#, то NUnit или xUnit.net.

#### 5.3.2. Написание кода тестов

Код каждого UNIT-теста должен соответствовать разработанному сценарию. Большинство тестов пишутся по простой структуре.

Следующая таблица описывает два популярных шаблона для структурирования кода UNIT-теста.

| Шаблон | Описание шагов и их назначение |
| :--- | :--- |
| Arrange-Act-Assert (AAA) | **Arrange (Подготовка):** Код, который создает все необходимые объекты, настраивает тестовое окружение, готовит тестовые данные и настраивает поведение тестовых двойников (заглушек, имитаторов). Цель: привести все в нужное состояние для проверки. <br>**Act (Действие):** Код, который вызывает тестируемый метод или функцию (UUT) с подготовленными входными данными. Цель: выполнить ту часть кода, которую мы проверяем. <br>**Assert (Проверка):** Код, который использует утверждения для проверки, что фактический результат выполнения UUT совпадает с ожидаемым результатом. Цель: удостовериться, что UUT повел себя правильно. |
| Given-When-Then (GWT) | **Given (Дано):** Описание исходного состояния системы или UUT перед началом теста. Похоже на Arrange. Цель: установить контекст теста. <br>**When (Когда):** Описание действия, которое выполняется над UUT. Похоже на Act. Цель: инициировать проверяемое поведение. <br>**Then (Тогда):** Описание ожидаемого результата или изменения состояния системы после выполнения действия. Похоже на Assert. Цель: проверить, соответствует ли фактический результат ожиданиям. |

Пример (используя шаблон AAA и псевдокод на Java-подобном языке) для сценария "Функция проверки сложности пароля: Пароль слишком короткий":

```java
@Test // Это специальная метка фреймворка, указывающая, что этот метод является тестом
void testCheckComplexityTooShortPassword() {
 // Arrange
 PasswordPolicyChecker policyChecker = new PasswordPolicyChecker(configMock); // Создаем тестируемый объект
 // Настраиваем mock configMock, чтобы он возвращал минимальную длину 8
 when(configMock.getMinPasswordLength()).thenReturn(8);

 // Act
 boolean result = policyChecker.checkComplexity("Short1"); // Вызываем тестируемый метод

 // Assert
 assertFalse(result, "Метод checkComplexity должен вернуть false для слишком короткого пароля"); // Проверяем ожидаемый результат с помощью утверждения
 // Дополнительные проверки, если нужно, например, проверка вызова метода логирования ошибки
}
